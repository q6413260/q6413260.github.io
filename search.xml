<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>行为金融学典型偏差分享</title>
      <link href="2023/12/12/behaviorfinance/"/>
      <url>2023/12/12/behaviorfinance/</url>
      
        <content type="html"><![CDATA[<img src="/2023/12/12/behaviorfinance/mangge.png" width="60%/">查理·芒格曾在《穷查理宝典》一书中提到，要拥有跨学科思维并用普世智慧来指导我们的投资乃至生活。行为金融学正是如此，它融合了金融学、心理学、行为学、社会学等多学科理论。“人类的感知和认知系统中那些总体上很有用的倾向往往会出错，如果不对此加以小心提防，就会很容易受到别人故意的操控。”查理基于自己过往的工作生活经历总结整理了人们常见的25种倾向。<h2 id="一、传统金融学"><a href="#一、传统金融学" class="headerlink" title="一、传统金融学"></a>一、传统金融学</h2><p>传统金融学（Traditional Finance）是指基于理性经济人假设和有效市场假设的经济学和金融学理论体系。它主要关注市场参与者的理性行为和市场的有效性，以及通过分析市场价格和资产定价来实现投资组合优化和风险管理。传统金融学的核心假设包括：</p><ul><li>理性经济人假设：传统金融学假设市场参与者在做出决策时是理性的，能够全面地评估信息和风险，并根据最大化效用的原则做出最优决策。</li><li>有效市场假设：传统金融学假设市场是有效的，即市场价格能够准确地反映所有可得信息，并且投资者无法通过分析市场价格来获得超额利润。除非你有内幕消息，否则无法跑赢大盘，被动投资，买指数基金。所以做主动投资的都是基于市场无效假设</li><li>均衡理论：传统金融学中的均衡理论是指通过分析市场参与者的行为和市场机制，寻找市场价格和资产价格的均衡状态。它基于供求关系和投资者的理性行为假设，试图解释市场中资产价格的形成和变动。</li></ul><p>代表人物：</p><ul><li>马科维茨：投资者在选择投资组合时应该考虑风险和回报之间的权衡关系。他引入了方差作为衡量投资组合风险的指标，并将投资组合的期望回报和方差结合起来进行优化；马科维茨假设投资者是风险厌恶的，他们在做出投资决策时会考虑风险和回报之间的权衡。他引入了效用函数的概念，用于衡量投资者对不同风险和回报水平的偏好。</li><li>威廉夏普：提出了资本资产定价模型（Capital Asset Pricing Model，CAPM），这是一种用于确定资产预期回报的模型。CAPM基于马科维茨的投资组合理论，通过考虑资产的系统性风险（β值）和市场风险溢价来估计资产的预期回报。</li></ul><p>马科维茨与威廉夏普和默顿米勒同时荣获1990年诺贝尔经济学奖。</p><h2 id="二、行为金融学"><a href="#二、行为金融学" class="headerlink" title="二、行为金融学"></a>二、行为金融学</h2><p>行为金融学（Behavioral Finance）是金融学、心理学、社会行为学的交叉性学科，力图解释金融市场上出现的各种异象，发掘投资者非理性行为和决策背后的一般规律。行为金融学与经典金融学最根本的差异就是对人的假定。经典金融学遵循的是“理性人”假设，即人是理性的，投资者的行为都是基于理性分析，为了实现对自己最有利的结果。行为金融学则认为人可以是非理性的，市场上投资者的行为并不是考虑利弊得失之后的最优结果。这构成了行为金融学和经典金融学之间最大的分歧。</p><img src="/2023/12/12/behaviorfinance/behavioralFinance.png" width="60%/"><h2 id="2-1、代表人物"><a href="#2-1、代表人物" class="headerlink" title="2.1、代表人物"></a>2.1、代表人物</h2><ul><li>丹尼尔·卡尼曼（Daniel Kahneman）：他是行为金融学的奠基人之一，于2002年获得诺贝尔经济学奖。他的研究揭示了人类决策和判断中的心理偏差，并对经济学和金融学产生了深远影响。</li><li>理查德·塞勒（Richard Thaler）：他是行为经济学和行为金融学的重要代表人物，于2017年获得诺贝尔经济学奖。他的研究关注人类行为中的非理性因素，并提出了“助推理论”和“选择架构”等概念，对行为金融学的发展做出了重要贡献。</li><li>罗伯特·希勒（Robert Shiller）：他是行为金融学和资产定价领域的知名学者，于2013年获得诺贝尔经济学奖。他的研究涉及资产价格形成、市场波动和投资者行为等方面，对行为金融学的发展做出了重要贡献。</li></ul><p>这些行为金融学家的研究成果对经济学和金融学产生了深远影响，推动了对人类行为和决策非理性因素的更深入研究，为我们更好地理解和解释市场现象提供了重要的理论基础。</p><h2 id="2-2、典型偏差"><a href="#2-2、典型偏差" class="headerlink" title="2.2、典型偏差"></a>2.2、典型偏差</h2><p>认知错误(Cognitive Error)：主要是由于错误推理或缺乏理性所导致。主要包含信念毅力偏差(Belief Perseverance Biases，对先前结论或决策存在执念，以至非理性的抗拒新信息)和信息处理偏差(Information-Processing Biases，信息处理错误，导致对于信息做出了不够客观、完备或是有偏的分析)两类偏差</p><ul><li>代表性偏差(Representativeness bias)：基于过去的经验和分类方法，对新的信息进行简单分类处理，往往由于样本量太小，造成以偏概全，错误分类<ul><li>举例：热爱天文学和物理学&amp;扎实的物理学基础&amp;好奇心 天体物理学家 or 老师 </li><li>后果：采纳几乎完全基于新信息或小样本的观点或预测。例如，在评估投资经理时，金融市场参与者可能过分强调一、两年或三年期间的高回报，而忽略了这种回报发生的基本概率。因此，投资者可能会在雇用投资经理时，没有充分考虑这种回报持续的可能性。</li><li>克服：意识到代表性偏差的存在（理论上所有偏差都应该意识到其存在），使用统计工具和概率思维，寻求多方意见和反馈</li></ul></li><li>控制错觉偏差(Illusion of Control bias)：指人们倾向于相信自己可以控制或影响结果，但实际上不能<ul><li>举例：如果我做了某件事情，可能结果就不同了</li><li>克服：需要认识到成功的投资是一种概率活动；寻求相反的观点；保留记录</li></ul></li><li>确认性偏差(Confirmation bias)：人们倾向于寻找和注意能证实他们信念的东西，而忽略或低估与他们信念相矛盾的东西<ul><li>举例：哈马斯VS以色列问题，你的立场决定了你更支持谁</li><li>后果：社交媒体基于算法推荐你有兴趣的信息流，容易造成信息茧房</li><li>克服：积极寻找挑战信念的信息，确认偏误的影响可能会得到纠正或减少。有意识地收集和处理消极信息(挑战信念的信息)和积极信息，提供了更完整的信息</li></ul></li><li>保守性偏差(Conservatism bias)：人们通过不充分吸收新信息来维持自己先前的观点或预测<ul><li>后果：对新信息没有反应或反应缓慢，错过了一些好的机会</li><li>克服：对新信息进行适当的分析和加权，可以纠正或减少保守偏差的影响</li></ul></li><li>后视偏差(Hindsight bias)：人们可能认为过去的事件是可以预测的，是可以合理预期的<ul><li>举例：事后诸葛亮</li><li>后果：高估对投资结果的预测程度，盲目自信</li><li>克服：做决策之前记录自己的想法</li></ul></li><li>框架依赖偏差(Framing bias)：人们根据提问的方式(框架)对问题做出不同的回答。<ul><li>举例：小和尚问师傅“我可以在念经的时候抽烟吗”，“中国艾滋病比例 1/850”，“生的概率75%”</li><li>后果：当人们基于一个狭窄的参考框架来评估信息并做出决定时，就会出现狭窄框架(narrow frame)。人们会忽略大局，只关注一两个特定的点。例如，消费者在考虑购买汽车时可能会关注样式或设计，但忽略了安全特性、燃油经济性和可靠性。金融市场参与者在选择证券时也可能表现出类似的行为</li><li>克服：全面思考</li></ul></li><li>锚定与调整偏差(Anchoring and adjustment bias)：当需要估计一个大小未知的值时，人们通常先设想一个初始的默认数字（锚），然后向上或向下调整以反映后续的信息和分析<ul><li>举例：一家商店原本定价一件商品为100元。然后商店决定打折促销，将商品的价格调整为80元，消费者觉得很划算；中国2023年GDP 5%  崩溃？<img src="/2023/12/12/behaviorfinance/gdp.png" width="60%/"></li></ul></li><li>心理账户偏差(Mental accounting bias)：即人们对一笔钱和另一笔同样大小的钱的区别对待，是基于这笔钱被分配给哪个心理账户<ul><li>举例：心理账户是基于诸如金钱来源（如工资、奖金、遗产、赌博）或计划使用（如休闲、生活必需品）这样的任意分类。将上述资产分组到不同的心理账户中，对经济结果进行编码、分类和评估</li><li>后果：忽视通过组合低相关性资产来降低风险的机会，不合理地区分来自收入的回报和来自资本增值的回报</li><li>克服：将资产当做一个整体来评估组合的风险</li></ul></li><li>可得性偏差(Availability bias)：容易回忆起的结果通常被认为比那些更难回忆或理解的结果更有可能。<ul><li>举例：人们通常会忽略或忘记发生在几年前的事件。例如，如果你上周发生了一场车祸，在一段时间内，你会比平时更小心地开车，这是很自然的。然而，随着时间的推移，你可能会恢复正常的驾驶行为。</li><li>后果：社交媒体往往会利用确认性偏差和可得性偏差来推送信息，影响人们做决定。</li><li>克服：多样化信息来源：寻找和接触来自不同来源的信息，而不仅仅依赖于个人经验或特定的信息源。通过获取多样化的信息，可以减少对某些特定信息的过度依赖，从而减少可得性偏差的影响。 </li></ul></li></ul><p>情感偏差(Emotional Bias)：主要是受感觉或情绪影响的推理的偏差。    </p><ul><li>损失厌恶偏差(Loss - aversion bias)：人们倾向于强烈地避免损失而不是获得收益的偏差，面对收益时risk reverse，面对损失risk seeking<ul><li>举例：不好的事情往往比好的事情给人印象更深。更倾向于 realize gain，不愿意 realize loss。在一项对美国共同基金经理的研究中，研究者分析了从1980到2002年间近3万支共同基金的交易表现。研究发现，基金经理偏好卖出赚钱的资产（当该资产还在赚钱的时候就卖出！），而死扛亏损的资产（当该资产亏损的时候仍然持有！）<img src="/2023/12/12/behaviorfinance/LossAversionBias.png" width="60%/"></li></ul></li><li>过度自信偏差(Overconfidence bias)：是指人们对自己的直觉推理、判断、认知能力表现出毫无根据的信任</li><li>自我控制偏差(Self - control bias)：由于缺乏自律(self-discipline)而无法在追求长期、首要的目标时采取行动</li><li>维持现状偏差(Status quo bias)：人们选择什么都不做（维持现状），而不是做出改变。<ul><li>举例：台湾问题</li></ul></li><li>禀赋偏差(Endowment bias)：是一种情感偏差，当人们拥有某项资产的权利时，他们会比不拥有该资产时更看重该资产<ul><li>举例：从父母那继承了某些资产，对其价值特别看重，不愿意处置</li></ul></li><li>后悔厌恶偏差(Regret - aversion bias)：人们倾向于避免做出会导致行动的决定，因为他们害怕决定结果会很糟糕。后悔厌恶可以引发羊群行为(herding behavior)</li></ul><h2 id="三、启示"><a href="#三、启示" class="headerlink" title="三、启示"></a>三、启示</h2><ol><li>认识自己的行为偏差：行为金融学研究了人们在金融决策中常常表现出的行为偏差，例如过度自信、损失厌恶和羊群效应等。通过了解这些行为偏差，我们可以更好地认识自己在工作和生活中的决策倾向，避免犯下类似的错误。</li><li>理性思考与情绪管理：行为金融学强调了情绪对决策的影响。在工作和生活中，我们常常会受到情绪的影响而做出冲动或不理性的决策。通过学习行为金融学，我们可以更好地理解情绪对决策的影响，并学会管理情绪，以更理性的方式做出决策。</li><li>长期规划与目标设定：行为金融学研究了人们对即时回报的偏好，即倾向于追求眼前的利益而忽视长期利益。在工作和生活中，我们常常会陷入短期利益的诱惑，而忽视了长期规划和目标的重要性。行为金融学提醒我们要更加注重长期规划，并设定明确的目标，以实现更长远的成功。</li><li>风险管理与投资决策：行为金融学研究了人们在面对风险时的行为模式和决策偏好。在工作和生活中，我们常常需要做出风险决策，例如职业选择、投资决策等。通过学习行为金融学，我们可以更好地理解风险决策的心理机制，并学会更有效地管理风险，做出更明智的决策。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFA </tag>
            
            <tag> 金融 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统稳定性建设杂谈</title>
      <link href="2023/04/02/stability/"/>
      <url>2023/04/02/stability/</url>
      
        <content type="html"><![CDATA[<h2 id="一、个人认知迭代"><a href="#一、个人认知迭代" class="headerlink" title="一、个人认知迭代"></a>一、个人认知迭代</h2><p>自从2022年7月4日JD机房断电故障后，ITU持续投入了大量人力来加固PaaS组件的稳定性，希望验证和强化组件在机房级别故障下的容灾能力，降低故障RTO时间。我近半年个人的工作重心也转移到建设公司级别的容灾演练平台上了，在此过程中，在系统稳定性上也有了一些认知迭代，想和大家分享下。</p><h3 id="1-1、墨菲定律"><a href="#1-1、墨菲定律" class="headerlink" title="1.1、墨菲定律"></a>1.1、墨菲定律</h3><p>在互联网领域，高性能、高并发、高可用相关的讨论屡见不鲜，三高问题中高性能和高并发大家工作中接触较多，对于高可用，往往是纸上谈兵。前几年提到高可用，什么同城容灾架构、异地容灾架构、两地三中心方案层出不穷，坊间还充斥着支付宝CTO剪网线、饿了么CTO主动做IDC断网测试等各种段子，美团在2019年也组织过GQ、YF机房整体断网演练。前几年业界内没有发生大规模的机房级别故障，我也会怀疑是否有必要投入高昂的成本来建设机房容灾能力。然而最近两年，先后出现亚马逊机房故障、美团0704故障到最近的阿里云香港机房故障，这些故障也印证了墨菲定律：如果事情有变坏的可能，不管这种可能性有多小，那么它总会发生</p><h3 id="1-2、AZ容灾的ROI"><a href="#1-2、AZ容灾的ROI" class="headerlink" title="1.2、AZ容灾的ROI"></a>1.2、AZ容灾的ROI</h3><p>仅从单量损失看，美团0704故障订单损失约3%~5%，金额损失好像是700多万。而从AZ容灾的投入看，人力投入成本加上机房建设成本必然是远超过这个数字。但是除账面损失外，故障时候大量客诉显然让公司付出了更大的隐性损失，“#美团挂了”一度登上微博热搜，这也违背了“以客户为中心，长期有耐心”的美团价值观。巧合的是最近阿里云香港机房故障，张勇也提到“任何故障的发生，对阿里是万分之一、百万分之一的概率，一旦发生在每个客户身上就是百分之百。我们必须急客户所急，想客户所想，既主动解决客户看得到的问题，更要把客户尚未感知到的风险防患于未然”。所以建设AZ容灾能力短期收益可能不高，也不太可能一蹴而就，需要持续去提升，可以看做是一个长期价值投资。</p><h3 id="1-3、顺势而为"><a href="#1-3、顺势而为" class="headerlink" title="1.3、顺势而为"></a>1.3、顺势而为</h3><p>JD 0704故障后，可以明显感受到公司自上而下都更重视AZ容灾能力建设了，每周都会组织各种稳定性会议进行吹风讨论。从ITU的各个中间件到业务部门，在建设和验证AZ容灾能力上基本能达成共识。这对于我们是一个绝佳的机会，我们应该抓住这个风口来建设并打磨演练工具。在平台建设上，我们要形成一套具备高实操性的服务容灾常态化演练机制，尽可能降低组件方接入成本，奉行“把困难留给自己，把简单交给用户”的策略来支持更多的组件进行各类容灾演练，以演练作为抓手来提升组件的容灾能力。</p><h2 id="二、系统稳定性建设模型"><a href="#二、系统稳定性建设模型" class="headerlink" title="二、系统稳定性建设模型"></a>二、系统稳定性建设模型</h2><p>根据公司和业内的一些经验，我们可以从以下几个方面作为抓手来建设系统的稳定性。具体到每个子模型，按照从低到高提出了L0、L1、L2和L3四个不同级别的能力模型。</p><h3 id="2-1、流程规范"><a href="#2-1、流程规范" class="headerlink" title="2.1、流程规范"></a>2.1、流程规范</h3><p>大公司一般对流程规范这项都很看重，只要是人都难免会犯错，公司希望通过一些规章制度来避免由于人为不规范操作导致的线上故障，例如我司的COE”六要两不要”生产规则，就是严格的高压线，一旦违反就可能会有严重的后果。</p><table>  <tr>    <th colspan="2">安全生产准则</th>    <th>是否违规</th>    <th>违规说明</th>  </tr>  <tr>    <td rowspan="6"><b>六要</b></td>    <td>要测试</td>    <td></td>    <td></td>  </tr>  <tr>    <td>要周知</td>    <td></td>    <td></td>  </tr>  <tr>    <td>要审核</td>    <td></td>    <td></td>  </tr>  <tr>    <td>要灰度</td>    <td></td>    <td></td>  </tr>  <tr>    <td>要观测</td>    <td></td>    <td></td>  </tr>  <tr>    <td>要可回滚</td>    <td></td>    <td></td>  </tr>  <tr>    <td rowspan="2"><b>两不要</b></td>    <td>不要瞒报故障</td>    <td></td>    <td></td>  </tr>  <tr>    <td>不要违规变更数据</td>    <td></td>    <td></td>  </tr></table><p>流程规范：团队内部应用的关于线上系统运维的流程、规章制度等。</p><ul><li>L0：没有流程机制，完全依赖RD的个人经验。</li><li>L1：有完善的流程机制，如值班机制、故障复盘机制、故障处理流程等，但缺少落地保障机制。</li><li>L2：将流程机制沉淀为经验库，形成SOP。并将部分流程机制线上化，通过系统进行辅助。</li><li>L3：流程规范线上化，成为研发交付标准流程和卡点，基本上不再依赖人的经验。</li></ul><h3 id="2-2、变更管控"><a href="#2-2、变更管控" class="headerlink" title="2.2、变更管控"></a>2.2、变更管控</h3><p>对所有线上变更操作的管控</p><ul><li>L0：变更随意，缺少对线上变更操作的评估和管控。</li><li>L1：有流程和机制来约束线上变更操作，有对应的应急预案。是否落地执行依赖RD经验，无法有效管控。</li><li>L2：评估影响范围且有对应的应急预案。完善的线上变更操作SOP，并有系统进行支撑。沉淀各类线上变更的评估项，形成经验库。</li><li>L3：线上变更具备灰度、降级、快速回滚能力，具备自动发现系统异常能力，对业务零影响。</li></ul><h3 id="2-3、风险感知"><a href="#2-3、风险感知" class="headerlink" title="2.3、风险感知"></a>2.3、风险感知</h3><p>发现和定位线上系统问题</p><ul><li>L0：系统缺少监控报警，线上问题完全依赖客服商服等人工反馈。</li><li>L1：监控覆盖了部分核心业务场景，部分场景有遗漏。</li><li>L2：监控覆盖全部核心业务场景，业务正确性监控覆盖部分业务场景。具备较完善的系统资源、应用、业务立体化的监控告警能力。</li><li>L3：监控覆盖全部核心业务场景，业务正确性监控覆盖全部核心业务场景。具备风险预防能力，能提前发现系统潜在隐患并及时修复。部分场景具备秒级发现和定位问题的能力。</li></ul><h3 id="2-4、风险控制"><a href="#2-4、风险控制" class="headerlink" title="2.4、风险控制"></a>2.4、风险控制</h3><p>控制线上已经出现的线上故障，确保系统具备服务能力</p><ul><li>L0：故障处理缺少预案、工具辅助，导致线上故障升级。系统缺少自我保护。</li><li>L1：核心场景有预案，具备快速止血能力，但需要有经验的RD负责组织协调，依赖个人经验主义。</li><li>L2：预案覆盖关键的核心和非核心场景，人工干预少。系统具有快速止损和恢复能力，平均恢复时长在30分钟以内。</li><li>L3：达成1-5-10目标，1分钟发现，5分钟定位，10分钟恢复。预案操作初步实现自动化。</li></ul><h3 id="2-5、容量评估"><a href="#2-5、容量评估" class="headerlink" title="2.5、容量评估"></a>2.5、容量评估</h3><p>评估业务流量与系统资源之间的关系、系统资源调度能力</p><ul><li>L0：缺少容量评估意识、动作，无弹性扩容能力。</li><li>L1：具备全链路压测能力，核心资源具备弹性扩容能力。</li><li>L2：具备分钟级的弹性调度能力，30分钟内完成扩容且系统恢复正常。</li><li>L3：具备秒级弹性扩容能力，10分钟内完成扩容且系统恢复正常。</li></ul><h3 id="2-6、预防与演练"><a href="#2-6、预防与演练" class="headerlink" title="2.6、预防与演练"></a>2.6、预防与演练</h3><p>提前发现和预防潜在的风险</p><ul><li>L0：核心场景缺少巡检、演练。</li><li>L1：日常有进行周期性巡检，对潜在风险提前优化。核心场景有预案但没有演练，RD对预案操作不熟悉。</li><li>L2：巡检工具代替人工巡检。定期进行预案演练，RD对预案操作非常熟练。</li><li>L3：具备在线破坏检测能力，真正落地混沌工程。</li></ul><h3 id="2-7、容灾架构"><a href="#2-7、容灾架构" class="headerlink" title="2.7、容灾架构"></a>2.7、容灾架构</h3><p>系统发生故障时,能够尽可能地保证业务的连续性</p><ul><li>L0：单AZ内多机部署，并支持单机故障自动迁移（依赖PasS侧），单AZ故障，服务一定不可用。</li><li>L1：多AZ内多机部署（同城或异地），并支持单AZ故障自动迁移（依赖PaaS侧N+1容灾能力），非核心服务可通过降级进行容灾</li><li>L2：核心服务（含依赖PaaS资源）做SET化部署，SET间两两互备，互备SET异地部署，数据双向实时同步且保障最终一致；数据无法分片且被SET服务频繁访问的服务做City部署，依赖数据做异地主从集群部署；其他服务做中心部署。 单AZ故障，SET服务（含依赖PaaS资源）及City服务通过人工切换到互备SET实现容灾，City服务依赖PaaS及中心服务依赖PaaS侧N+1容灾能力进行容灾，非核心服务可通过人工降级进行容灾。</li><li>L3：核心服务（含依赖PaaS资源）做SET化部署，SET间两两互备，互备SET异地部署，数据双向实时同步且保障最终一致，SET自身数据与互备SET备份数据独立集群存储；数据无法分片且被SET服务频繁访问的服务做City部署，依赖数据在每个SET部署只读副本；其他服务做中心部署。 单AZ故障，SET服务（含依赖PaaS资源）及City服务通过人工切换到互备SET实现容灾，City服务依赖PaaS及中心服务依赖PaaS侧N+1容灾能力进行容灾，非核心服务可通过自动降级进行容灾。</li></ul><h3 id="2-8、服务治理"><a href="#2-8、服务治理" class="headerlink" title="2.8、服务治理"></a>2.8、服务治理</h3><p>服务链路依赖、容量、架构、代码风险治理</p><ul><li>L0：服务具备基本的弹性和韧性(超时、限流、熔断、重试)配置，服务Owner及团队对服务的容量具备感性的认知，但缺乏服务治理的理论依据。 服务接入统一框架，具备基本的内部和外部请求链路图，服务Owner及团队在接新需求和重构过程中具备基本的统一框架认知。 建立统一代码规范，各团队感知并初步解决代码扫描暴露的风险。 涉及协议：MThrift Http。</li><li>L1：服务的弹性和韧性配置相关的阈值在逐步形成的统一巡检标准范围内，服务Owner及团队理解统一巡检的各项规则。 服务利用统一框架对自身上下游链路形成画像，通过内外步链路图指导其开发迭代和容量风险评估。 各团队根据统一代码规范，完善代码，代码扫描保留出的风险逐步收敛。 涉及协议：MThrift Http Mafka Zebra Cache。</li><li>L2：服务的弹性和韧性配置相关的阈值与统一服务治理理论相一致，服务Owner及团队具备服务治理的理论依据，并共同逐步完善理论。服务治理统一化、常态化、部分自动化。 服务链路依赖全面基于统一框架迭代，各类标签健全。 各团队根据统一代码规范迭代，常态的代码扫描暴露的风险数平稳。 涉及协议：全部。</li><li>L3：服务的弹性和韧性全面自动化，并具备一定的预测能力。 通过服务画像自动识别迭代中存在的链路风险。 涉及协议：全部。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统稳定性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZK架构设计与优化</title>
      <link href="2023/02/03/zkarch/"/>
      <url>2023/02/03/zkarch/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ZK基础"><a href="#一、ZK基础" class="headerlink" title="一、ZK基础"></a>一、ZK基础</h2><hr><p>ZK，全称为 ZooKeeper，是一个分布式协调服务，由雅虎公司开发并开源。ZK 提供了一个高可用、高性能（Raptor测试链接同机房直连ZK节点Avg耗时0.1ms）、分布式的协调服务，用于解决分布式系统中的一些协调问题，如分布式锁、分布式协调、分布式配置中心、分布式队列等。被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型开源分布式系统中，公司内部的Squirrel、MNS、Crane、Mafka、DTS以及一些业务系统也广泛使用ZK来实现数据订阅、Leader选举、分布式锁等。</p><hr><h3 id="1-1、ZK名词解释"><a href="#1-1、ZK名词解释" class="headerlink" title="1.1、ZK名词解释"></a>1.1、ZK名词解释</h3><p>LocalSession：本地会话指客户端与 ZooKeeper 服务器之间的一次连接。当客户端与 ZooKeeper 服务器建立连接时，会创建一个本地会话。本地会话的生命周期与客户端与服务器之间的连接一致。如果客户端与服务器之间的连接断开，那么本地会话也会被关闭。主要用于创建临时节点、处理读请求。<br>GlobalSession：全局会话是指客户端与 ZooKeeper 集群之间的一次连接。当客户端与 ZooKeeper 集群中的任意一个服务器建立连接时，会创建一个全局会话。全局会话的生命周期与客户端与集群之间的连接一致。如果客户端与集群之间的连接断开，那么全局会话也会被关闭。所有的全局会话都会同步到Leader节点，由Leader节点来统一检测其超时时间。</p><ul><li>TxnLog：事务日志文件，每次写请求都会转化成一个事务日志操作，一阶段提交时候会将事务日志顺序写入到事务日志文件.</li><li>SnapLog：内存快照文件，内存Database对应的快照文件，满足一定条件就会将内存Database序列化后生成一份快找文件。</li><li>Zxid：全局事务ID，用于标识 ZooKeeper 中的每个事务。每个 ZooKeeper 事务都有自己的 zxid，用于标识该事务的唯一性和顺序。每次新的事务请求，Zxid都会加1。</li><li>Epoch：纪元，Epoch 用于标识 ZooKeeper 服务器的状态和版本信息，简单理解没新产生一个Leader，Epoch都会加1。</li><li>MyId：节点ID，ZK集群中每个ZK节点的唯一标识。</li><li>Proposal：Leader节点向所有Follower节点发送的一阶段事务提议请求。</li><li>Commit：Leader节点向所有Follower节点发送的二阶段事务提交请求。</li></ul><h3 id="1-2、ZK数据结构模型"><a href="#1-2、ZK数据结构模型" class="headerlink" title="1.2、ZK数据结构模型"></a>1.2、ZK数据结构模型</h3><p>ZooKeeper 中的数据结构模型采用了类似文件系统的树形结构，每个节点都唯一关联一个路径Path，每个节点可能又会存在多个Children节点。如下图，“/mns/prod/com.sankuai.crayfish.sign”代表一个节点的Path，节点详情展示了节点的Value（data字段）以及其他属性字段值。<br><img src="/2023/02/03/zkarch/zktree.png" width="50%/"><br>ZK会将上述树形结构包含的所有节点缓存到内存当中，生成一个内存Database，实现原理特别简单。大体上就是维护了一个 ConcurrentHashMap，其中 Key 是节点的Path，Value是节点数据 DataNode。ZK会将上述所有的节点，例如 “/”、“/leader”、“/mns”、“/mns/sankuai”、“/mns/sankuai/prod”、“/mns/sankuai/prod、com.sankuai.crayfish.sign”等等全部保存到ConcurrentHashMap中。简述下从Database中读、修改、新增数据过程</p><ul><li>读数据：传入Path，从 ConcurrentHashMap 中获取DataNode，若读请求中带有watch标识，需要向该Path注册一个Watcher，后续用来监听数据变更并通知客户端。</li><li>修改数据：传入Path和Value，从 ConcurrentHashMap 中获取DataNode，修改 data 的值，然后修改 stat 信息，最后触发该Path上所有注册的Watcher</li><li>新增数据：传入Path和Value，根据传入Path解析出父节点的Path，根据parentPath从ConcurrentHashMap中获取父节点数据DataNode，父节点的children中添加传入的子节点Path。根据传入Path，创建一个新的DataNode，将其数据插入到ConcurrentHashMap中。完成上述操作后，触发该Path上所有注册的Watcher。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataNode</span> <span class="token keyword">implements</span> <span class="token class-name">Record</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//节点value</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>    <span class="token comment">//节点stat数据，上图中的czxid、mzxid、ctime等等</span>    <span class="token keyword">public</span> <span class="token class-name">StatPersisted</span> stat<span class="token punctuation">;</span>    <span class="token comment">//节点children，存储子节点Path列表</span>    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> children <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、ZK架构设计"><a href="#二、ZK架构设计" class="headerlink" title="二、ZK架构设计"></a>二、ZK架构设计</h2><h3 id="2-1、整体架构"><a href="#2-1、整体架构" class="headerlink" title="2.1、整体架构"></a>2.1、整体架构</h3><img src="/2023/02/03/zkarch/zkarch.png" width="50%/">如上图所示，ZK集群服务端包括一个Leader节点、若干个Follower节点、若干个Observer节点（可选），其中 Leader 和 Follower 节点统称为Voter节点（会参与事务处理、Leader选举投票）。Leader节点会与所有Follower节点和Observer节点建立一个Socket双向通信链接，主要用作集群内部之间的通信，实现Leader选举、数据同步、数据广播和心跳检测等功能。在上述节点中，Voter节点主要有以下两个作用:</li><li>参与Leader选举：所有voter节点会参与Leader竞选和投票</li><li>参与写请求二阶段处理：对于客户端的任意一个写请求，都需要半数以上的 Voter 节点ACK后，才能最终提交。</li></ul><p>由于ZK采用类似二阶段提交协议来处理写请求，故出于性能考虑，不能配置太多的Follower节点，基于此ZK引入了Observer节点，通过水平扩容Observer节点来提升整个ZK集群处理读请求性能。<br>ZK客户端启动后会随机选择一个ZK节点与其建立连接，链接建立好之后，即可发起读、写、监听等各类请求。</p><h3 id="2-2、数据广播"><a href="#2-2、数据广播" class="headerlink" title="2.2、数据广播"></a>2.2、数据广播</h3><p>ZK客户端与集群中的任一ZK节点建立链接之后，即可发起读写请求。对于读请求，不管客户端当前连接的节点是Leader、Follower还是Observer，收到客户端请求之后，直接从内存Database中查到数据返回给客户端即可。对于写请求，ZK集群处理逻辑较为复杂，整体上类似一个二阶段提交的过程，详细过程参考 <a href="/2023/01/15/zkprocess/">ZK处理客户端请求流程梳理</a> ：<br><img src="/2023/02/03/zkarch/guangbo.png" width="50%/"></p><ol><li>假设客户端与ZK集群一个Follower节点已经建立了链接，于是向该节点发送一个写请求来更新指定ZK节点的Value。</li><li>Follower收到请求后，判断是写请求，需要向Leader发送Request请求，将写请求转发给Leader。</li><li>Leader收到Follower的Request后，先生成一个全局事务Zxid，然后将该写请求转化成一个事务请求Proposal。</li><li>Leader自身完成一阶段处理，并向集群中的所有Follower节点发送一阶段Propose请求，同时记录向每个Follower节点发送请求的具体时间（心跳检测会用到），然后等待Follower节点响应。</li><li>Follower节点收到Propose后，开始一阶段处理，主要会完成两件事情：<ul><li>事务日志落盘：将事务请求Proposal同步写入事务日志文件TxnLog，类似于MySQL WAL机制，将随机读写磁盘转换成一个顺序写磁盘的记录日志操作。</li><li>生成快照文件（根据条件触发）：从上次生成快照文件之后，新增的事务日志条数或者事务日志占用的内存大小是否超过一定阈值，若超过阈值，开启一个子线程将当前内存中的Database数据序列化后生成一个快照文件SnapLog。</li><li>完成上述操作后，会在内存中记录当前处理的Zxid</li></ul></li><li>Follower节点向Leader节点发送ACK，表示一阶段已经成功执行。</li><li>Leader节点陆续接受到Follower节点的ACK，若加上Leader节点自己处理成功的个数超过Voter节点总数的一半，则判断一阶段整体执行成功。（Leader节点要么收到从节点的ACK，要么在规定超时时间内没有收到从节点ACK请求，不存在从节点发送操作失败情况，所以不存在主动通知Follower节点回滚逻辑）</li><li>Leader节点自身完成二阶段处理，同时向所有Follower节点发送二阶段Commit请求，向所有Observer节点发送Inform请求，此过程Leader节点不关注其他节点处理结果。</li><li>Follower节点收到Commit请求后，会先判断Zxid是否与一阶段Pending的Zxid是否相同<ul><li>若不同，表示由于网络丢包或者其他异常，Follower节点可能遗漏掉一些事务请求，Follower节点会直接关闭与客户端的所有链接，同时会断开和Leader的链接，直接进入“重启过程”。</li><li>若相同，根据事务请求的Path和Value，更新内存中Database 的数据。同时将当前已经成功Commit的事务日志缓存到内存队列committedLog（默认500条）中，并修改内存队列中的minCommittedLog 和 maxCommittedLog。</li><li>Observer节点收到Inform请求，处理逻辑与Follower节点基本相似，不再赘述。</li></ul></li><li>Follower节点二阶段处理成功后，返回客户端操作成功（只会由最初收到客户端写请求的那个Follower节点来返回给客户端Response）。</li></ol><p>综述，ZK基于共识协议，对于任意写请求，都交由Leader节点来协调，采用两阶段提交，第一阶段完成事务日志落盘，第二阶段完成内存Database数据更新。在不明显降低写性能的情况下，保证极端故障情况下只要Commit的数据都不会出现丢失。</p><h3 id="2-3、心跳同步检测"><a href="#2-3、心跳同步检测" class="headerlink" title="2.3、心跳同步检测"></a>2.3、心跳同步检测</h3><p>Leader节点与Follower节点启动后会相互创建Socket来与对方进行通信，主要是通过相互发送Ping来实现心跳检测，心跳检测主要包含两个作用：</p><ul><li>检测节点维度是否超时或者故障：以Leader为例，若发现读写Socket失败，会认为Follower异常而关闭Socket；对于Follower节点，若发现读写Socket失败，会认为Leader节点已经失效，会将自己的状态从 Following 状态变为 Looking 状态，进而发起一轮新的选举过程。</li><li>检测全局会话维度是否出现超时：在 ZK 集群中，客户端与ZK节点会建立一个本地Session，若客户端存在写请求，则会将该本地Session升级为全局Session，即ZK节点会将该Session信息同步到Leader节点，后续由Leader节点统一来检测所有的全局会话是否超时。</li></ul><p>梳理下Leader和Follower节点心跳同步的过程：</p><ol><li>Leader每次向Follower节点发起Ping之前，会判断当前时间与上次收到Follower节点请求的时间之差是否大于超时时间，若超时，Leader节点会认为Follower节点已经失效，会主动关闭Socket链接。</li><li>Leader向Follower节点发送Ping请求。</li><li>Follower节点收到请求后，将本机的全局会话信息封装到 Ping 请求中。</li><li>Follower节点向Leader节点发送Ping请求。</li><li>Leader节点收到Ping请求，更新维护的全局会话信息（会单独启动一个线程基于该信息来检测全局会话是否超时）</li></ol><p>间隔0.5*TickTime后，会进入到下一次心跳同步阶段，以此循环往复。</p><img src="/2023/02/03/zkarch/heartbeat.png" width="50%/"><h3 id="2-4、Leader选举"><a href="#2-4、Leader选举" class="headerlink" title="2.4、Leader选举"></a>2.4、Leader选举</h3><p>ZK节点在运行过程中存在以下几个状态：LOOKING（竞选或者寻找Leader状态）、FOLLOWING（Follower节点状态）、LEADING（Leader节点状态）、OBSERVING（Observer节点状态）。上文已经提到，当Leader正常运行时候，Follower节点会以阻塞的方式循环读取与Leader之间创建的Socket数据；一旦Leader出现故障，读取Socket会抛异常，导致循环中断，Leader会从FOLLOWING状态变更到LOOKING 状态，进而会发起一次新的Leader选举，具体选举过程如下：</p><ol><li>Leader出现故障，Follower1和Follower2两个节点感知到Leader故障，然后相继发起新的Leader选举。</li><li>初次投票，Follower节点默认都会提议自身作为Leader候选人，会将自身的Epoch、Zxid、节点ID信息同步给集群中的其他Follower。<ul><li>先以Follower1的视角来分析第一轮选举的结果，Follower1提议自己作为Leader候选，后续又收到了Follower2提议的候选人Follower2，Follower1节点判断自身的Zxid较大，故依然维持自己的判断，但是由于获得票数只有1票，未超过集群 Voter节点的一半2个（3个Voter），故还需要等待。</li><li>然后以Follower2的视角来分析第一轮选举的结果，Follower2同样提议自己作为Leader候选，后续又收到了Follower1提议的候选人Follower1，Follower2节点判断Follower1节点Zxid较大，会修改自己的Leader候选人，并将最新提议的候选人广播给集群中其他节点，然后进行等待。</li></ul></li><li>Follower2重新投票后，Follower1节点收到消息后，此时Follower1节点判断自身已经得到了2票，超过集群Voter节点一半，故Follower1当选为Leader节点，然后会发出广播告知其他节点已经完成Leader选举</li><li>Follower2节点接受到广播消息后，就会与新的Leader节点建立链接。</li></ol><img src="/2023/02/03/zkarch/elect.png" width="50%/"><h3 id="2-5、数据同步"><a href="#2-5、数据同步" class="headerlink" title="2.5、数据同步"></a>2.5、数据同步</h3><p>此处提到的数据同步主要指节点初始化需要与Leader节点进行数据同步以保证数据一致，完成数据同步后，该节点才能对外提供服务。数据同步包含以下几种形式：</p><ul><li>新节点加入集群：新的节点加入到一个ZK集群，该节点需要与Leader进行数据同步。</li><li>原先故障节点重新加入集群：同新节点加入集群类似，只是在数据同步之前需要先从快照文件SnapLog和事务日志文件TxnLog中恢复数据，然后同Leader进行数据同步。</li><li>集群选出新的Leader：集群重新选举出新的Leader后，其余所有节点都要与Leader进行数据同步。</li></ul><p>Follower启动数据同步过程如下：</p><ol><li>从磁盘上加载快照文件到内存，生成内存Database，并记录当前处理的最大maxZxid。</li><li>从磁盘上加载事务日志文件，对于事务日志文件中Zxid大于步骤1中maxZxid的事务，都需要按照顺序加载到Database（同二阶段处理Commit请求类似直接修改Database中的数据），记录下此时最新的Zxid。</li><li>加载数据完成后Follower节点开始加入集群，寻找到Leader后，与其建立连接，并发送当前最新的Zxid。</li><li>Leader接受建链请求，创建Socket，读取到Follower传过来的Zxid，将其与minCommittedLog和maxCommittedLog进行比较，比较逻辑如下：<ul><li>Zxid == maxCommittedLog，Leader 节点发送一个空的DIFF请求给Follower，Follower 收到该请求后，无需处理，直接结束数据同步过程，可以对外提供服务。</li><li>Zxid &gt; maxCommittedLog，说明Follower节点数据比当前Leader还新，不合理。此时，Leader节点会发送TRUNC请求给 Follower，Follower收到请求后，根据Leader传过来的maxCommittedLog，从事务日志文件中删除大于其的事务日志，然后根据快照文件和事务日志文件恢复数据。</li><li>minCommittedLog&lt;=Zxid&lt;maxCommittedLog，那么Leader 节点会遍历内存队列committedLog中的事务日志，对于大于Zxid的事务日志，Leader会向Follower节点发起Commit请求，Follower节点接受到请求后，将其顺序加载到Database。</li><li>Zxid &lt; minCommittedLog，说明Follower节点数据太旧，Leader内存队列中已经没有缓存该事务日志，Leader节点会先从事务日志文件中找到事务ID=Zxid的日志，若事务日志文件中可以找到该Zxid的日志，且从该Zxid的日志开始到maxCommittedLog总的日志大小在制定阈值范围之内，那么Leader节点会将这些事务日志按照顺序向Follower节点发起Commit请求；若不满足上述条件，Leader节点需要向Follower节点发起一个SNAP请求，然后会将内存Database中的数据全部序列化进行发送，Follower节点接收到SNAP请求后，从Socket中读取Leader发过来的数据，将其加载到内存。加载完成后即完成了数据同步过程。</li></ul></li></ol><img src="/2023/02/03/zkarch/sync.png" width="50%/"><h2 id="三、ZK数据一致性分析"><a href="#三、ZK数据一致性分析" class="headerlink" title="三、ZK数据一致性分析"></a>三、ZK数据一致性分析</h2><h3 id="3-1、CAP简介"><a href="#3-1、CAP简介" class="headerlink" title="3.1、CAP简介"></a>3.1、CAP简介</h3><p>ZooKeeper 是一个分布式协调服务，它的设计目标是提供高可用性和一致性的服务。从 CAP 系统定义的角度来看，ZooKeeper 更加注重一致性和分区容错性，而在可用性方面做了一定的牺牲。</p><ul><li>分区容器性（Partition Tolerance）：ZooKeeper 采用了主从复制的架构，将数据复制到多个节点上，以保证数据的可靠性和容错性。当主节点发生故障时，ZooKeeper 会自动切换到备用节点，保证系统的可用性和稳定性</li><li>一致性（Consistency）：因为 ZooKeeper 主要用于实现分布式锁、配置管理、服务发现等功能，这些功能对数据的一致性要求非常高。ZooKeeper 通过使用 Paxos 算法和 ZAB 协议来保证数据的一致性和可靠性，即使在网络分区或节点故障的情况下，ZooKeeper 也能够保持数据的一致性。</li><li>可用性（Availability）：ZooKeeper 采用了一些措施来保证系统的可用性，例如使用心跳机制来检测节点的健康状态，使用多个备用节点来保证系统的容错性，以及使用会话超时机制来避免死锁等问题。但是，为了保证数据的一致性和可靠性，ZooKeeper 在某些情况下可能会牺牲一定的可用性，例如在进行 leader 选举时，ZooKeeper 会暂停对外服务，直到选举完成。<h3 id="3-2、ZK一致性讨论"><a href="#3-2、ZK一致性讨论" class="headerlink" title="3.2、ZK一致性讨论"></a>3.2、ZK一致性讨论</h3>根据 <a href="https://zookeeper.apache.org/doc/current/zookeeperInternals.html">ZK官方</a> 的描述，其数据一致性实际是处于强一致性和顺序一致性之间。下文简述下一致性的各个级别，严格级别从上到下层层降低。</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">The consistency guarantees of ZooKeeper lie between sequential consistency and linearizability. In this section,we explain the exact consistency guarantees that ZooKeeper provides.Write operations in ZooKeeper are linearizable. In other words, each write will appear to take effect atomically at some point between when the client issues the request and receives the corresponding response. This means that the writes performed by all the clients in ZooKeeper can be totally ordered in such a way that respects the real-time ordering of these writes. However, merely stating that write operations are linearizable is meaningless unless we also talk about read operations.Read operations in ZooKeeper are not linearizable since they can return potentially stale data. This is because a read in ZooKeeper is not a quorum operation and a server will respond immediately to a client that is performing a read. ZooKeeper does this because it prioritizes performance over consistency for the read use case. However, reads in ZooKeeper are sequentially consistent, because read operations will appear to take effect in some sequential order that furthermore respects the order of each client&#39;s operations. A common pattern to work around this is to issue a sync before issuing a read.This too does not strictly guarantee up-to-date data because sync is not currently a quorum operation. To illustrate, consider a scenario where two servers simultaneously think they are the leader, something that could occur if the TCP connection timeout is smaller than syncLimit * tickTime. Note that this is unlikely to occur in practice, but should be kept in mind nevertheless when discussing strict theoretical guarantees. Under this scenario, it is possible that the sync is served by the “leader” with stale data, thereby allowing the following read to be stale as well. The stronger guarantee of linearizability is provided if an actual quorum operation (e.g., a write) is performed before a read.Overall, the consistency guarantees of ZooKeeper are formally captured by the notion of ordered sequential consistency or OSC(U) to be exact, which lies between sequential consistency and linearizability.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>强一致性/线性一致性（linearizability）：所有操作不论读写、不论是来自哪个客户端session，都是全局有序的，因为全局有序，所以需要有全局时钟，并且一定能读到最新数据。ZK写请求达到了强一致性</li><li>顺序一致性（Sequential consistency）：每个session的请求是保证严格有序的，但是不需要全局时钟。所有的session看到数据的顺序都必须和全局操作的执行顺序一致。也就是说，虽然所有操作并不是按照严格时序执行的，但是所有session读取时看到的顺序都是唯一确定的。你也可以这么理解：线性一致性会把所有请求按请求时间戳排队，任何时刻读取都能读取到最新的数据。而顺序一致性保证任何时刻读取的数据顺序都是一致的即可，也就是不要求一定读到最新数据。ZK读请求实现了顺序一致性</li><li>因果一致性（Causal consistency）：每个session的请求是保证严格有序的，其他session读到的数据不一定是按全局顺序的，但是一个session发出的请求顺序一定是确定的。比如某个session更新a=2后再更新a=1,其他session可以拿不到a=1这个最新值,但是不能拿到a=1之后又拿到a=2，因为这和更新者发起的顺序不相符。但是如果a=2和a=1是不同session发出的，那对于其他session来说，谁先谁后就无任何要求<br><br>顺序一致性和因果一致性的区别就在于：系统是否需要对多个来源的数据重新排队，需要重排队的就是顺序一致。不需要重排队，保证每个数据来源顺序一致就可以的话，是因果一致。</li><li>最终一致性（Eventual consistency）：最终一致性只是定义了系统停止新的写入后，在一段时间内，任何session读取的数据都将一致。此外什么也不保证，“一段时间”是多久也没说，属于最弱的一致性。</li></ul><p>ZK Leader节点和Follower节点基于TCP链接的FIFO特性来保证节点接受到的读写请求一定能按照顺序被节点执行。对于写请求来说，由于都会经由Follower节点转发到Leader节点统一处理，Leader节点根据接受到的请求顺序来执行两阶段提交过程。由于在二阶段Commit阶段，节点对于写请求的处理是单线程串行执行，所以对于写请求，不会出现旧数据覆盖新数据的情况。<br>对于读请求，出于性能考虑，集群中任一ZK节点都能直接响应客户端的读请求，直接从内存Database查询到数据后即可返回给客户端，故读请求有可能读到旧的数据，同数据库、Redis其他存储组件读取从库也有概率读取到旧数据类似。当然ZK也提供了解决方案，在每次读请求之前，客户端可以先发起一个Sync请求，收到Sync请求后的ZK节点会从Leader节点同步最新数据，显然该操作会降读请求的性能，同时给Leader带来较大压力，一般不建议使用。</p><h2 id="四、ZK中潜在优化点"><a href="#四、ZK中潜在优化点" class="headerlink" title="四、ZK中潜在优化点"></a>四、ZK中潜在优化点</h2><h3 id="4-1、事务日志同步落盘影响写入性能"><a href="#4-1、事务日志同步落盘影响写入性能" class="headerlink" title="4.1、事务日志同步落盘影响写入性能"></a>4.1、事务日志同步落盘影响写入性能</h3><p>我们知道ZK一般更适合于读多写少的业务，根据线下环境对一个类似MNS的集群进行压测，该集群能支撑最高1000QPS的写入请求（ZK集群机器配置、以及写入数据大小不一导致性能可能会有差异）。上次机房故障，MNS集群和外卖公用集群由于整体写入明显增加导致集群近乎不可用。</p><p><b>性能瓶颈原因</b>：通过上文对ZK写入过程的剖析以及测试，我们不难发现影响整体写入的瓶颈主要是在一阶段，Leader节点和Follower节点对于每条事务日志请求都需要同步落盘。根据测试结果，每条事务日志落盘大致耗时10ms（取决于写入大小），两阶段提交网络通信耗时2ms，其他过程耗时几乎可以忽略。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token function">newTransaction</span><span class="token punctuation">(</span><span class="token string">"ZK"</span><span class="token punctuation">,</span> <span class="token string">"commitTxnLog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>logStream <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">FileOutputStream</span> log <span class="token operator">:</span> streamsToFlush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//forceSync默认为true，每次写请求都需要将事务日志刷盘</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>forceSync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">long</span> startSyncNS <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> log<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          channel<span class="token punctuation">.</span><span class="token function">force</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          syncElapsedMS <span class="token operator">=</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startSyncNS<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>syncElapsedMS <span class="token operator">></span> fsyncWarningThresholdMS<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>serverStats <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              serverStats<span class="token punctuation">.</span><span class="token function">incrementFsyncThresholdExceedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>              <span class="token string">"fsync-ing the write ahead log in &#123;&#125; took &#123;&#125;ms which will adversely effect operation latency."</span>              <span class="token operator">+</span> <span class="token string">"File size is &#123;&#125; bytes. See the ZooKeeper troubleshooting guide"</span><span class="token punctuation">,</span>              <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              syncElapsedMS<span class="token punctuation">,</span>              channel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token class-name">ServerMetrics</span><span class="token punctuation">.</span><span class="token function">getMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>FSYNC_TIME<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>syncElapsedMS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>streamsToFlush<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        streamsToFlush<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// Roll the log file if we exceed the size limit</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>txnLogSizeLimit <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> logSize <span class="token operator">=</span> <span class="token function">getCurrentLogSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logSize <span class="token operator">></span> txnLogSizeLimit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Log size limit reached: &#123;&#125;"</span><span class="token punctuation">,</span> logSize<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">rollLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      transaction<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      transaction<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/02/03/zkarch/disk.png" width="50%/"><p><b>优化方案</b>：一阶段提交，每次只需要将事务日志写入到文件Buffer，即返回给Leader节点ACK。单独启动一个线程来异步的Buffer中的数据输入到磁盘，刷入策略支持每收集到N条事务日志或者每间隔N秒将一批事务日志写入到磁盘。以上策略类似MySQL  sync_binlog配置，sync_binlog支持0、1、N三种不同配置</p><ul><li>0：binlog sync磁盘由操作系统负责，性能最好，有较大概率丢失数据。</li><li>1：每次事务请求都需要将Binlog刷盘，适合于对数据一致性有严格要求。</li><li>N：每收到N次事务请求将Binlog批量刷盘，兼顾性能和数据一致性。</li></ul><p>ZK的事务日志写入当前支持类似0和1两种配置，尚不支持N配置。<br><b>改造收益评估</b>：采用优化方案，相同机器配置集群支撑最大写入QPS预计从1000至少提升到5000，端到端平均耗时也从10ms降低到2ms，集群整体稳定性会有明显提升。<br><b>改造风险评估</b>：极端情况下，Leader和Follower节点同时故障情况下，集群最多会丢失N条数据。当前现在线上集群一般是1个Leader2个Follower配置，Leader和其中一个Follower节点同时故障出现的情况概率极低。假设真的出现，相较于集群整体会不可用，丢失几条数据带来的影响几乎可以忽略。</p><h3 id="4-2、Leader节点压力较大"><a href="#4-2、Leader节点压力较大" class="headerlink" title="4.2、Leader节点压力较大"></a>4.2、Leader节点压力较大</h3><p>ZK Leader节点对于集群整体可用性尤其关键，一旦Leader节点出现故障，集群会重新选举Leader，在重新选出Leader节点之前的这段时间，集群都处于不可用的状态。而在以下方面，由于现在架构的设计，导致Leader节点承担了较大的压力。</p><ul><li>ZK Leader节点接收到过半数Voter节点的ACK后，需要通知所有Follower节点进行二阶段Commit，同时还需要通知所有的Observer节点。现在线上多数集群都是1个Leader、2个Follower，但是Observer节点数特别多，以MNS集群为例，有100多个Observer节点，相当于每次写请求，Leader节点通知次数都需要放大100多倍。<br><br>解决方案：升级到3.6版本，开启ObserverMaster模式，开启该模式后，Follower会作为Observer的代理Leader，后续Leader不再负责二阶段Observer数据的同步，由余下的Follower节点来均衡的负责Observer节点数据的同步，显著降低了Leader的压力（Leader节点网卡出入流量成比例下降，由于压测QPS不高、Observer节点个数不多，cpu降低不明显）。</li><li>全局会话GlobalSession超时会由Leader广播给所有ZK节点，一旦Leader处理大量连接超时、断开时，会将断链请求传导到全集群，导致全集群节点因处理“断链请求”繁忙，不能响应客户端keepalive请求，诱发客户端超时重连。之前线上MNS集群出现过类似情况，值得注意的是，由于之前线上Sgagent会直连ZK集群，导致全局会话过多，加大了上述现象出现的概率。（当前MNS集群出现该Case概率明显降低）<br><br>解决方案：修改代码，Leader发现GlobalSession超时，只需要向该Session关联的节点发起断链请求，无需向其他节点发起断链请求。</li></ul><h3 id="4-3、不太合理的重启机制"><a href="#4-3、不太合理的重启机制" class="headerlink" title="4.3、不太合理的重启机制"></a>4.3、不太合理的重启机制</h3><p>ZK现有设计中，较多异常场景下都会触发各种重启操作，例如以下场景：</p><ol><li>客户端写入或者读取数据超过1MB，服务端会直接断开客户端链接（并不能从根本上解决问题，断开链接后，客户端重连依然会读取或者写入大数据）</li><li>代码很多地方抛了一个异常，就会触发系统退出</li><li>Follower节点Commit阶段与Propose阶段Zxid不一致，Follower节点直接退出JVM进程</li></ol><p>目前线上没有统计出异常情况导致进程退出的具体数目，同线上其他Java服务类似，当前ZK进程被supervisord托管，即使出现进程退出，也会很快被重新拉起来，所以这个问题暂时没有造成太大影响。个人猜测，ZK直接退出进程可能是由于当前架构较为复杂，客户端、主从之间需要频繁进行通信来保持集群数据一致，对于一些特殊的异常，没有思考清楚应该如何优雅处理。只能依赖进程退出，节点重启后加入集群会经过数据同步而恢复到可用状态。<br>优化方案：可以针对这类情况，先添加Raptor打点，后面出现问题再分析具体报错日志，针对性解决问题，尽可能缩小影响范围。（例如对于场景3，可以采用上文提到的数据同步来恢复不一致数据，从而无需机器重启）</p><h3 id="4-4、3-4版本ZK集群每次初始化都需要重新加载快照文件"><a href="#4-4、3-4版本ZK集群每次初始化都需要重新加载快照文件" class="headerlink" title="4.4、3.4版本ZK集群每次初始化都需要重新加载快照文件"></a>4.4、3.4版本ZK集群每次初始化都需要重新加载快照文件</h3><p>ZK 3.4.X版本在以下场景下：1节点宕机重启、2集群产生了新的Leader节点需要连接到新Leader、3节点与Leader由于网络故障恢复后重连等场景下节点都需要重新加载磁盘上的快照文件，加载快照文件会消耗大量的磁盘IO和CPU资源，同时整个过程耗时较长。实际上除了场景1，场景2和场景3由于节点内存Database数据还在，理论上并不需要重新加载快照文件。在3.6.X版本，ZK已经进行了优化，仅仅只有宕机重启才需要加载快照文件，其他场景已经无需加载快照文件。<br>后续优化方案：尽快推动3.4.X版本集群尽快升级到3.6.X。</p><h3 id="4-5、Zxid超过2亿会溢出"><a href="#4-5、Zxid超过2亿会溢出" class="headerlink" title="4.5、Zxid超过2亿会溢出"></a>4.5、Zxid超过2亿会溢出</h3><p>Zxid包含8个字节，共64位，高32位用来表示Epoch，低32位表示事务序列号，如果没有产生过新的Leader，则Zxid最多只能2^32（2亿多） 个事务；若产生了一个新的Leader，则高32位自增加1，低32位重新置为0。线上DTS集群由于写入较多（不太合理），每间隔一段时间就可能会出现 Zxid溢出情况<br><img src="/2023/02/03/zkarch/zxid.png" width="50%/"></p><h3 id="4-6、不支持客户端批量读取功能"><a href="#4-6、不支持客户端批量读取功能" class="headerlink" title="4.6、不支持客户端批量读取功能"></a>4.6、不支持客户端批量读取功能</h3><p>当前ZK服务端和C语言客户端暂不支持一些常用API的批量读取功能，诸如MNS一些重度依赖ZK的组件在服务启动阶段往往需要读取大量配置，导致启动过程耗时较长。目前我们已经对ZK服务端源码和C语言客户端源码做了二次开发来支持批量读取功能，目前本地测试功能OK，预计下个Q会开始在线下环境进行测试。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZK </tag>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZK处理客户端请求流程梳理</title>
      <link href="2023/01/15/zkprocess/"/>
      <url>2023/01/15/zkprocess/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ZK整体构成包括Leader、Follower、Observer以及客户端，其中Leader、Follower参与Leader竞选，并负责对于写请求进行投票。由于每次写请求，Leader都必须和所有Follower基于类似两阶段提交协议来决定写入是否成功，所以Follower节点不能过多。同时为了提高集群整体的读性能，进而引入了Observer节点。下图描述了从客户端发起一次请求到服务端响应的整个过程（假设客户端此时连接的是Follower节点，相比于连接Leader处理过程更为复杂）</p><img src="/2023/01/15/zkprocess/process.png" width="60%/"><h2 id="二、读请求处理过程"><a href="#二、读请求处理过程" class="headerlink" title="二、读请求处理过程"></a>二、读请求处理过程</h2><ol><li>客户端向直连的ZK发起一次请求</li><li>ZK 服务端启动时候会创建 NIOServerCnxn（3.6版本支持Netty，可以采用NettyServerCnxn），来监听客户端读写请求。收到客户端请求后，经过一系列处理，最终交由 FollowerRequestProcessor 进行处理。（ZK中会有一系列 RequestProcessor，基于Java责任链模式，每个 RequestProcessor 会同时持有下一个待执行的 RequestProcessor。一般每个  RequestProcessor 会缓存一个待处理的请求队列，类似生产者消费者模型：若下一个 RequestProcessor 是耗时操作，当前 RequestProcessor 会把请求提交到下一个 Rrocessor 的队列当中，下一个 RequestProcessor 会有一个线程来轮询处理队列中的请求；若下一个操作是非耗时操作，会直接提交下一个RequestProcessor 进行处理 ）</li><li>FollowerRequestProcessor 将请求传递给 CommitProcessor，CommitProcessor 判断若是读请求，会直接交由一个线程池调用下一个 FinalRequestProcessor 进行处理。</li><li>FinalRequestProcessor 直接查询本地zkDb中的数据，然后返回给客户端。</li></ol><h2 id="三、写请求处理过程"><a href="#三、写请求处理过程" class="headerlink" title="三、写请求处理过程"></a>三、写请求处理过程</h2><ol><li>（Follower处理）若 CommitProcessor 判断是写请求，会将客户端 request 缓存到叫 pendingRequests的队列，同时将写请求转发给 Leader 节点（Leader 节点会通过 Socket 与所有Follower和Observer建立一个双向通信链接，此时 Follower 会向Leader发送一个 Leader.Request Packet。）</li><li>（Leader处理）Leader 节点收到请求Packet后，经过反序列化，最终由 LearnerHandler 将请求传递给 PrepRequestProcessor。对于写请求，会将其转换成对数据存储的操作，并最终由后续Processor进行处理</li><li>（Leader处理）PrepRequestProcessor 将请求传递给 ProposalRequestProcessor ，Proposal 会向所有 Follower 发起第一阶段提交协议，即 Proposal 请求，然后调用下一个Processor CommitProcessor进行处理。同时自身也会调用 SyncRequestProcessor ，最终经由 AckRequestProcessor 调用 Leader.processAck 方法，该方法会判断是否有过半节点 ACK（包括leader自身），由于此时只有 Leader 处理成功，暂时不能提交。</li><li>（Follower处理）Follower 节点收到 Leader 的Proposal 请求后，交由 SyncRequestProcessor 进行处理，SyncRequestProcessor 提交事务操作和写入快照snapshot后，将请求转发给 SendAckRequestProcessor，SendAckRequestProcessor 会向 Leader 发送 ACK Packet。</li><li>（Leader处理）Leader 收到 ACK Packet 后，经过反序列化，最终调用 Leader.processAck 方法进行判断，同上述步骤3中判断，若过半节点 ACK 成功，则会向所有Follower发送二阶段提交请求 Commit，同时向所有 Observer 发送 Inform 请求（方便 Observer 及时更新最新数据）。然后将请求添加到 CommitProcessor 的 commitedRequests队列中，CommitProcessor 最终将请求传递给 FinalRequestProcessor，在 FinalRequestProcessor 中，会完成对 ZKDB数据的更新操作。</li><li>（Follower处理）Follower 节点收到 Leader 的 Commit 请求后，经过反序列化后交由 CommitProcessor 进行处理。以上图中的 Follower 1为例，从 pendingRequests 中获取到最初客户端缓存的请求，然后交由 FinalRequestProcessor 进行处理，FinalRequestProcessor 完成 ZKDB 数据更新之后，即可将 response 返回给客户端。对于其他 Follower 节点，只需更新 ZKDB数据即可。</li><li>（Observer处理）Observer 收到 Inform Packet 后，待补充</li></ol><h2 id="四、可优化点"><a href="#四、可优化点" class="headerlink" title="四、可优化点"></a>四、可优化点</h2><ol><li>当前除正常的写请求以外，所有的创建连接、关闭连接（全局链接，只要有写操作就是全局链接）请求也会转给给 Leader ，然后 Leader 进行两阶段提交。极端情况，若Leader检测到大量链接超时，会向所有 Follower 和 Observer 发起两阶段请求关闭链接（之前出过 case，一个重要原因还是之前 sgagent会直连 zk，导致 leader 节点全局链接过多），导致集群中多个节点不可用。<br><br>改进点：创建连接和关闭连接应该不需要同步给集群中所有节点，只需要同步给指定节点。</li><li>对于所有的写请求，在二阶段提交的时候，都需要由 Leader 将请求同步给所有的 Observer，以 MNS ZK  集群为例，当前有 100多个 Observer，每次写请求 Leader 都需要转发 100多次请求。<br><br>改进点：为了降低 Leader 压力，可以将 Inform 操作交由 Follower 节点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Binlog性能优化</title>
      <link href="2022/04/26/binlog/"/>
      <url>2022/04/26/binlog/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近一段时间，一到业务午高峰，外卖集群的一些订阅机器就会出现Binlog消费大量延时。出现Binlog延时的原因主要是：一般11点开始，外卖业务进入中午午高峰，数据库的Binlog QPS会逐渐增加，一旦订阅服务出现性能瓶颈，处理Binlog的能力跟不上Binlog生成的速度，就会导致消费Binlog出现延时，并且延时时间会越来越长。业务在BCP上配置的核对规则一般最小是60s，一旦Binlog延时时间超过60s，那么规则就会大量误告。<br><img src="/2022/04/26/binlog/cat1.png" width="60%/"><br><img src="/2022/04/26/binlog/cat2.png" width="60%/"></p><h2 id="二、Binlog消费线程分析"><a href="#二、Binlog消费线程分析" class="headerlink" title="二、Binlog消费线程分析"></a>二、Binlog消费线程分析</h2><p>排查性能瓶颈之前，需要先梳理出当前订阅服务消费Binlog的整体流程，如下图，整体流程大致包含7个步骤</p><table><thead><tr><th>步骤</th><th>过程描述</th><th>影响性能因素</th><th>Binlog延时原因分析</th></tr></thead><tbody><tr><td>1</td><td>启动一个独立线程，实现了MySQL同步协议，伪装成Slave，从业务DB实时拉取Binlog字节流，并将其解析成常规的Binlog结构</td><td>外部原因：网络原因导致的MySQL主从同步延时；内部原因：Binlog解析出现性能瓶颈</td><td>Raptor监控看，当前无主从同步延时；另外根据以往测试，目前单库Binlog极限解析速度能达到20000QPS（外卖午高峰单库QPS最多5000+）</td></tr><tr><td>2</td><td>解析出来的Binlog写入到内存中的LinkedBlockingQueue（历史架构图原因，之前Binlog解析和拉取是两个独立服务，通过Netty交互，后来合并成一个服务）</td><td>步骤3拉取Binlog过慢，导致步骤2写入Binlog出现阻塞</td><td>根据1的分析，理论上2的写入速度能达到20000QPS，故该步骤无性能瓶颈</td></tr><tr><td>3</td><td>Binlog拉取线程从LinkedBlockingQueue中拉取Binlog</td><td>步骤2写入Binlog过慢，导致步骤3拉取Binlog出现阻塞</td><td>单纯从LinkedBlockingQueue中拉取Binlog，显然无性能瓶颈</td></tr><tr><td>4</td><td>将拉取到的Binlog基于业务主键进行hashCode交由不同的BlockingQueue，提高性能的同时保证Binlog处理局部有序性</td><td>步骤5拉取Binlog过慢，导致步骤4写入Binlog出现阻塞</td><td>该步骤仅根据Binlog计算hashCode，耗时基本可以忽略，无性能瓶颈</td></tr><tr><td>5</td><td>Binlog聚合线程从LinkedBlockingQueue中拉取Binlog，对每条Binlog执行业务配置的Aviator filter脚本和Java匹配脚本，对满足提交的Binlog进行压缩序列化</td><td>同一条Binlog上关联的业务规则较多，需要执行较多业务配置的filter脚本和Java核对脚本</td><td>存在性能瓶颈</td></tr><tr><td>6</td><td>将聚合好的Binlog交由Binlog存储线程池进行处理</td><td>存储线程池处理性能</td><td>线程池没有抛出拒绝策略，且阻塞队列也没有积压，无性能瓶颈</td></tr><tr><td>7</td><td>将Binlog写入到Squirrel</td><td>Squirrel性能</td><td>Raptor监控看，Squirrel各项指标正常，耗时没有明显增加，写入没有报错，无性能瓶颈</td></tr></tbody></table><p>总结：整体上看，订阅服务Binlog消费过程是一个典型的生产消费者模型：</p><ul><li>生产者：步骤1、2</li><li>消费者：步骤3、4、5、6、7</li></ul><p>当前生产者理论上能达到20000QPS，外卖午高峰单库QPS 5000+，故生产者当前无性能瓶颈；消费者3、4、5、6、7中，3、4、5基本是同步处理，其中一个步骤处理慢就会影响整个过程。6和7是异步处理的，和3、4、5基本独立，不会影响3、4、5的性能。故整体性能瓶颈在3、4、5，其中3和4都是很轻量级的操作，耗时基本忽略不计，所以性能瓶颈大概率是步骤5<br><img src="/2022/04/26/binlog/parser.jpeg" width="60%/"></p><h2 id="三、Binlog聚合线程分析"><a href="#三、Binlog聚合线程分析" class="headerlink" title="三、Binlog聚合线程分析"></a>三、Binlog聚合线程分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processMultiBinlog</span><span class="token punctuation">(</span><span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EventEntry</span><span class="token punctuation">></span></span> changedEvents<span class="token punctuation">,</span> <span class="token keyword">int</span> threadNo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">EventEntry</span> eventEntry <span class="token operator">=</span> rowChangedEvents<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Transaction</span> t1 <span class="token operator">=</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token function">newTransaction</span><span class="token punctuation">(</span><span class="token string">"processBinlogMsg"</span><span class="token punctuation">,</span> rowChangedEvent<span class="token punctuation">.</span><span class="token function">getJdbcRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SubMsgConfigDTO</span> config <span class="token operator">:</span> configMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Transaction</span> t2 <span class="token operator">=</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span><span class="token function">newTransaction</span><span class="token punctuation">(</span><span class="token string">"createCacheValue"</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        filterConfig <span class="token operator">=</span> <span class="token function">createCacheValue</span><span class="token punctuation">(</span>rawData<span class="token punctuation">,</span> config<span class="token punctuation">,</span> sb<span class="token punctuation">,</span> config<span class="token punctuation">.</span><span class="token function">getSaveToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        t2<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    t1<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内层 Transaction 耗时<br><img src="/2022/04/26/binlog/cat3.png" width="60%/"></p><p>外层 Transaction 耗时<br><img src="/2022/04/26/binlog/cat4.jpeg" width="60%/"></p><p>看Raptor监控，内层Transaction：createCacheValue平均耗时0ms，而外层Transaction：processBinlogMsg 平均耗时1.1ms（理论上最高qps 1000）。数据上看比较奇怪，即使内层循环执行70次，外层平均耗时应该也还是0，只能怀疑单个内层循环执行时间太短，导致被统计成0ms了。故优化思路：将串行执行createCacheValue修改成并行执行。</p><p>并行化优化后，平均处理时间从1.1变成0了。<br><img src="/2022/04/26/binlog/cat5.png" width="60%/"></p><h2 id="四、确定最终优化方案"><a href="#四、确定最终优化方案" class="headerlink" title="四、确定最终优化方案"></a>四、确定最终优化方案</h2><p>优化方案与初始方案不同在于：初始方案使用了4个线程分别拉取4个不同的阻塞队列，优化方案使用4个线程拉取同一个阻塞队列。粗看上去，两个方案似乎没有区别。仔细分析下初始方案，由于生产方步骤4产生Binlog较快，故很自然的就想到了使用4个不同的阻塞队列，交由4个不同的线程去处理。但是考虑下面一种情形，若BlockingQueue1满容，此时聚合线程1的上一个任务还没有结束，步骤4又产生了一条Binlog，将Binlog写入BlockingQueue1就会阻塞，进而就阻塞了整个处理流程。反过来看优化方案，若BlockingQueue1满容，即使聚合线程1的上一个任务还没有结束，聚合线程2、3、4只要任务结束，就会从队列中拉取Binlog，后续步骤4产生一条新的Binlog写入队列也不会阻塞。<br><img src="/2022/04/26/binlog/solution.png" width="60%/"></p><p>线上开启5个Binlog聚合线程进行测试，外卖订单waimaiorderidwest02_waimai_product单库Binlog消费速度达到320K/min（当前外卖午高峰一般150K/min）<br><img src="/2022/04/26/binlog/cat6.png" width="60%/"></p><p>接下来其实还做了进一步的优化：将优化方案中的聚合线程串行执行Aviator和Java脚本改成并行执行Aviator和Java脚本本以为能进一步提升速度，测试下来性能反而下降。后来发现在执行Aviator脚本时候，会进行加锁操作，故实际耗时可能更长。故最终方案是多个聚合线程拉取同一个阻塞队列，聚合线程内部串行执行Aviator和Java脚本<br><img src="/2022/04/26/binlog/cat7.png" width="60%/"></p><h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2><p>一个完整链路的数据处理流程，整体性能主要取决于性能最弱的一环，显然优化思路就是先分通过监控打点或者代码找出性能最弱的一个缓解，然后进行针对性的优化。常见优化方式就就是串行改并行，同步转异步。同时并行修改后，还要考虑到会不会引入锁冲突问题，这个往往容易被忽视。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA调试Elasticsearch源码</title>
      <link href="2021/10/22/es-debug/"/>
      <url>2021/10/22/es-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Mac上安装es"><a href="#一、Mac上安装es" class="headerlink" title="一、Mac上安装es"></a>一、Mac上安装es</h2><hr><p>最近在调研Elasticsearch（后续简称es）的translog，在Mac上安装了es单机版和集群版本，这里推荐使用docker搭建，简单叙述下过程：<br><strong>安装Docker环境</strong><br>首先需要在Mac上安装Docker运行环境，这里推荐直接安装 docker-for-mac，安装完成并启动成功后Mac右上方会显示running<br><img src="/2021/10/22/es-debug/docker.png" width="30%/"><br>安装完docker-for-mac后，建议修改镜像源，默认镜像源拉取镜像太慢了。修改方式如下：依次点击Preferences -&gt; Docker Engine</p><figure><img src="/2021/10/22/es-debug/docker-preference.png" width="30%/"><img src="/2021/10/22/es-debug/docker-engine.png"></figure><p><strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/docker.html">安装es单机版</a></strong></p><ol><li>拉取镜像，docker pull docker.elastic.co/elasticsearch/elasticsearch:7.12.0</li><li>启动容器，docker run –name es01-test -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node” docker.elastic.co/elasticsearch/elasticsearch:7.12.0</li><li>当容器退出后，下次需要启动该容器，可以执行 docker ps -a 显示当前所有容器（docker ps显示运行时容器，-a会显示包括非运行在内所有容器），找到对应的container id名称，然后 docker  start 891f7a68c705<br><img src="/2021/10/22/es-debug/docker-ps.png" alt="docker-ps"></li></ol><p><strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/docker.html">安装es集群版本</a></strong>  </p><ol><li>创建docker-compose.yml<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2.2'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">es01</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>7.12.0    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> es01    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> node.name=es01      <span class="token punctuation">-</span> cluster.name=es<span class="token punctuation">-</span>docker<span class="token punctuation">-</span>cluster      <span class="token punctuation">-</span> discovery.seed_hosts=es02<span class="token punctuation">,</span>es03      <span class="token punctuation">-</span> cluster.initial_master_nodes=es01<span class="token punctuation">,</span>es02<span class="token punctuation">,</span>es03      <span class="token punctuation">-</span> bootstrap.memory_lock=true      <span class="token punctuation">-</span> <span class="token string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span>    <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>      <span class="token key atrule">memlock</span><span class="token punctuation">:</span>        <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">-1</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> data01<span class="token punctuation">:</span>/usr/share/elasticsearch/data    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 9200<span class="token punctuation">:</span><span class="token number">9200</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> elastic  <span class="token key atrule">es02</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>7.12.0    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> es02    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> node.name=es02      <span class="token punctuation">-</span> cluster.name=es<span class="token punctuation">-</span>docker<span class="token punctuation">-</span>cluster      <span class="token punctuation">-</span> discovery.seed_hosts=es01<span class="token punctuation">,</span>es03      <span class="token punctuation">-</span> cluster.initial_master_nodes=es01<span class="token punctuation">,</span>es02<span class="token punctuation">,</span>es03      <span class="token punctuation">-</span> bootstrap.memory_lock=true      <span class="token punctuation">-</span> <span class="token string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span>    <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>      <span class="token key atrule">memlock</span><span class="token punctuation">:</span>        <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">-1</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> data02<span class="token punctuation">:</span>/usr/share/elasticsearch/data    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> elastic  <span class="token key atrule">es03</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.elastic.co/elasticsearch/elasticsearch<span class="token punctuation">:</span>7.12.0    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> es03    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> node.name=es03      <span class="token punctuation">-</span> cluster.name=es<span class="token punctuation">-</span>docker<span class="token punctuation">-</span>cluster      <span class="token punctuation">-</span> discovery.seed_hosts=es01<span class="token punctuation">,</span>es02      <span class="token punctuation">-</span> cluster.initial_master_nodes=es01<span class="token punctuation">,</span>es02<span class="token punctuation">,</span>es03      <span class="token punctuation">-</span> bootstrap.memory_lock=true      <span class="token punctuation">-</span> <span class="token string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span>    <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>      <span class="token key atrule">memlock</span><span class="token punctuation">:</span>        <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">-1</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> data03<span class="token punctuation">:</span>/usr/share/elasticsearch/data    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> elastic<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">data01</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> local  <span class="token key atrule">data02</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> local  <span class="token key atrule">data03</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> local<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">elastic</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> bridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在同目录下执行 docker-compose up 创建集群</li><li>执行 curl -X GET “localhost:9200/_cat/nodes?v=true&amp;pretty” 确认集群是否启动</li></ol><h2 id="二、IDEA编译es源码"><a href="#二、IDEA编译es源码" class="headerlink" title="二、IDEA编译es源码"></a>二、IDEA编译es源码</h2><p><strong>环境准备：</strong> </p><ul><li>JDK 16：版本要求可以参考CONTRIBUTING.md，es对jdk版本要求较高，建议直接使用最新版本，下载完成后，建议配置JAVA_HOME</li><li>IDEA 2021.1：低版本的IDEA貌似不太支持高版本的JDK，根据自己情况选择。</li><li>ElasticSearch 7.8.1代码分支：刚开始编译master分支代码和7.12.0一直有问题，后改成7.8.1版本</li><li>ElasticSearch 7.8.1服务端：建议下载服务端完整包，后续启动时候一些配置路径可以直接指向完整安装包中的目录</li><li><a href="https://gradle.org/releases/">Gradle 7.0</a>：下载完成后，建议配置GRADLE_HOME和PATH，最好修改gradle镜像源为阿里云，在 ~/.gradle目录创建 init.gradle 文件</li></ul><p><strong><a href="https://github.com/elastic/elasticsearch">github pull代码</a></strong><br>es代码挺大的，第一次拉取很慢，后面从google应用商店下载了github加速插件，拉代码速度提升很明显。安装完成后，会有一个加速按钮</p><figure><img src="/2021/10/22/es-debug/github-speed.png" width="45%/"><img src="/2021/10/22/es-debug/github-speed2.png" width="45%/"></figure><p><strong>编译es代码</strong></p><ol><li>切换分支 git checkout v7.8.1</li><li>两种方式导入IDEA：我是使用第二种方式导入的，第一种一直报错。<ul><li>cd到代码根目录，执行./gradlew idea，会下载6.5版本的gradle来编译源代码（或者执行gradle idea，直接使用之前环境准备配置的es版本），生成 IML, IPR, IWS 3个文件，然后导入 elasticsearch.ipr。</li><li>IDEA直接 File -&gt; Open 打开es根目录的 build.gradle，然后等待编译源码</li></ul></li></ol><p><strong>运行es代码</strong><br>es启动类位于 ：elasticsearch\server\src\main\java\org\elasticsearch\bootstrap\Elasticsearch.java</p><ol><li>ERROR: the system property [es.path.conf] must be set<br>添加VM options： -Des.path.conf=/Users/dianping/Downloads/elasticsearch-7.8.1/config，这里可以直接指向成之前下载的es 7.8.1的config目录<img src="/2021/10/22/es-debug/es-vm.png" width="85%/"> </li><li>Exception in thread “main” java.lang.IllegalStateException: path.home is not configured<br>添加VM options： -Des.path.home=/Users/dianping/Downloads/elasticsearch-7.8.1</li><li>Exception in thread “main” java.lang.NullPointerException: Cannot invoke “String.hashCode()” because “<local3>“ is null<br>直接注释**InternalSettingsPreparer.checkSettingsForTerminalDeprecation()**for循环代码，不影响启动<img src="/2021/10/22/es-debug/InternalSettingsPreparer.png" width="85%/"> </local3></li><li>ERROR Could not register mbeans java.security.AccessControlException: access denied (“javax.management.MBeanTrustPermission” “register”)<br>添加VM options：-Dlog4j2.disable.jmx=true 禁用jmx</li><li>java.security.AccessControlException: access denied (“java.lang.RuntimePermission” “createClassLoader”)<br>创建java.policy文件，然后 -Djava.security.policy=/Users/dianping/Downloads/elasticsearch-7.8.1/config/java.policy<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">grant &#123;permission java.lang.RuntimePermission &quot;createClassLoader&quot;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>解决上述问题后，es应该就能在IDEA中启动了，后续调试的话即可debug模式启动 Elasticsearch.java main函数   </p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于本地日志的可靠消息型事务</title>
      <link href="2021/04/15/distributiontransaction/"/>
      <url>2021/04/15/distributiontransaction/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>业务经常会使用消息中间件进行上下游解耦或者异步削峰填谷的目的。通常处理流程是如下：</p><ol><li>操作本地数据库，完成自身业务逻辑</li><li>发送消息，通知下游业务 </li></ol><p>上述过程可能会出现操作数据库成功，发送消息失败的情形，这就导致上下游数据不一致了。为了解决上述问题，业务可以配置定时任务，对发送失败的消息进行重试，直到消息发送成功，当然下游业务必须保证接口幂等。<br>该方案虽然能实现最终一致性，每条业务线实现上述方案，研发成本比较高，故我们希望调研一套通用的可靠消息通知型事物。</p><h2 id="二、目标"><a href="#二、目标" class="headerlink" title="二、目标"></a>二、目标</h2><p>设计一套基于本地事务的可靠消息通知型事物方案，降低业务研发成本；同时尽可能降低对业务代码的侵入性，业务通过注解即可接入。</p><h2 id="三、技术设计"><a href="#三、技术设计" class="headerlink" title="三、技术设计"></a>三、技术设计</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Created by yeming on 2021/3/2. */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocalTransactionRetryService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span>      <span class="token annotation punctuation">@SwanReliableNotifyTransactional</span><span class="token punctuation">(</span>            domain <span class="token operator">=</span> <span class="token string">"yeming_test_retry"</span><span class="token punctuation">,</span>            callbackMethod <span class="token operator">=</span> <span class="token string">"sendBizMsg"</span><span class="token punctuation">,</span>            retryFor <span class="token operator">=</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">reliableInform</span><span class="token punctuation">(</span><span class="token class-name">Object</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> object <span class="token operator">=</span> orderService<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RetryContext</span> context <span class="token operator">=</span> <span class="token class-name">RetryTransactionContextUtil</span><span class="token punctuation">.</span><span class="token function">getRetryContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">putMtraceParams</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> object<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendBizMsg</span><span class="token punctuation">(</span><span class="token class-name">LocalRetryTransaction</span> transaction<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RetryContext</span> context <span class="token operator">=</span> <span class="token class-name">RetryTransactionContextUtil</span><span class="token punctuation">.</span><span class="token function">getRetryContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> mtraceParams <span class="token operator">=</span>  context<span class="token punctuation">.</span><span class="token function">getMtraceParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> mtraceParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sendBizMsg success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案整体上分为以下步骤：</p><ol><li>框架启动：扫描特定注解的方法，基于AOP对该方法织入统一的事务处理逻辑；</li><li>事务运行时：首先运行上述切面逻辑，开启Spring事务，在执行业务方法reliableInform成功后，在同一个事务里面插入事务日志，方法执行完成后，Spring事务自动关闭；然后通过反射调用callbackMethod指定的方法，成功后删除事务日志</li><li>事务异常重试（可选）：扫描步骤2中的事务日志表，若扫描到事务日志，则调用sendBizMsg方法，直到该方法成功后，删除事务日志。</li><li>若事务多次重试失败，事务日志会上传服务端，并大象通知，业务可以在Swan管理平台人工重试</li></ol><h3 id="3-1、事务启动过程"><a href="#3-1、事务启动过程" class="headerlink" title="3.1、事务启动过程"></a>3.1、事务启动过程</h3><img src="/2021/04/15/distributiontransaction/process.png" width="60%/"><ol><li>框架启动时候，扫描是否有方法标注了@SwanReliableNotifyTransactional</li><li>注解，如果没有则跳过后续AOP处理流程，继续后续启动过程</li><li>扫描到上述注解后，解析出注解的全局事务名称domain和回调方法callbackMethod（该方法就配置成背景中提到的发送消息方法的名称）</li><li>检查是否配置了Spring事务管理器 DataSourceTransactionManager ，如果没有配置该注解，则直接抛出异常，终止启动流程（由于本方案基于Spring事务实现）</li><li>获取事务管理器关联的DataSource</li><li>判断DataSource类型，这里我们只支持Zebra ShardDataSource和GroupDataSource ，不支持 ZebraRoutingDataSource在内的其他DataSource</li><li>如果是GroupDataSource，或者虽然是ShardDataSource，但是是单库分表，则获取该DataSource对应的 SqlSessionFactory ，然后构建操作事务日志的Dao，方便后续操作事务日志</li><li>如果是ShardDataSource，我们需要通过反射获取ShardDataSource 中关联的真实操作不同分库的 GroupDataSource，并基于AOP对GroupDataSource 的 getConnection 方法进行拦截</li></ol><p>重点介绍下上述 getConnection 方法：我们每次的数据库操作，都会首先调用DataSource的 getConnection 方法获取一个链接，上文提到我们基于Spring事务的方案，Spring事务每次调用 getConnection方法获取链接后，会将该链接绑定到当前线程，后续同一个线程中的操作使用同一根链接自然能保证事务。对于分库分表事务 ShardDataSource，后续同线程调用 getConnection方法 获取到的是 ShardConnection，这里由于还执行到解析业务分表规则逻辑，故不知道后续会访问哪一个分库，故我们采用代理 ShardDataSource 中不同分库对应的 GroupDataSource 对象的方案</p><ol><li>如果调用了GroupDataSource的 非 getConnection方法，则执行被代理对象自身方法</li><li>如果调用了GroupDataSource的getConnection方法，在获取到connection后，将该connection绑定到当前线程，后续插入事务日志直接从当前线程获取连接，即可保证在同一事务。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">DataSource</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> dataSourcePool<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">ProxyFactory</span> proxyFactory<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">setTarget</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">MethodInterceptor</span> methodInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token comment">//只有ShardDataSource才会调用invoke方法</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//仅仅拦截getConnection方法</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"getConnection"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//只有SwanReliableNotifyTransactional标注的方法才会把链接绑定到当前线程</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">LocalTransactionContext</span><span class="token punctuation">.</span><span class="token function">isLocalTransactionStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token class-name">Connection</span> connection <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">LocalTransactionContext</span><span class="token punctuation">.</span><span class="token function">bindConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">LocalTransactionContext</span><span class="token punctuation">.</span><span class="token function">bindDataSource</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> connection<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//非SwanReliableNotifyTransactional标注的方法走原有逻辑</span>            <span class="token keyword">return</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">addAdvice</span><span class="token punctuation">(</span>methodInterceptor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> proxy <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2、事务运行时"><a href="#3-2、事务运行时" class="headerlink" title="3.2、事务运行时"></a>3.2、事务运行时</h3><img src="/2021/04/15/distributiontransaction/run.png" width="60%/"><ol><li>判断当前方法是否存在事务注解，若不存在，则执行被代理对象自身方法</li><li>开启Spring事务（这里利用Spring事务传播特性，如果业务方法使用Spring默认注解，将会自动添加到同一事务），执行业务操作，然后获取当前线程绑定的Connection，若是分库分表情况，由于框架启动时候我们代理了ShardDataSource中的GroupDataSource getConnection方法，该方法获取Connect后会绑定到当前线程，故此时我们能获取到与业务操作同库的Connection，基于该Connection插入事务日志（分库分表场景业务方法必须保证只能访问同一个库）；若获取不到Connection，说明是单库场景，我们直接使用事务日志Dao插入事务日志。上述操作保证事务日志的写入和业务在同一个事务中，若失败，则抛出异常，事务回滚 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">createTransaction</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> userMethodInvocation<span class="token punctuation">,</span> <span class="token class-name">LocalRetryTransaction</span> transaction<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//执行事务注解标记的业务真实方法逻辑</span>  <span class="token class-name">Object</span> object <span class="token operator">=</span> userMethodInvocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">LocalTransactionContext</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>connection <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//分库分表情况下直接获取线程绑定的GroupConnection操作</span>    <span class="token class-name">SortedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> params <span class="token operator">=</span> <span class="token function">buildShardParams</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">JdbcUtils</span><span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> <span class="token class-name">RetryDBRepository</span><span class="token punctuation">.</span>INSERT_SQL<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token comment">//非分库分表情况走原有swanLocalTransactionDao逻辑</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> params <span class="token operator">=</span> <span class="token function">buildGroupParams</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>    swanLocalTransactionDao<span class="token punctuation">.</span><span class="token function">insertTransactionLog</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span>  object<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>执行业务定义的callBack方法，若执行失败，则抛出异常（这里业务评估下是否需要抛出异常）。如果业务对性能有要求，callBack方法可以支持异步操作</li><li>删除事务日志，若执行失败，catch住异常。</li></ol><p>上述步骤2执行成功后，业务逻辑实际成功，后续3和4由框架重试保证最终执行成功，故要求业务callback方法支持幂等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis如何从DAO到SQL</title>
      <link href="2021/04/03/mybatis/"/>
      <url>2021/04/03/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Mybatis简介"><a href="#1、Mybatis简介" class="headerlink" title="1、Mybatis简介"></a>1、Mybatis简介</h2><hr><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。在项目中通过配置不同的mapper和xml，然后即可方便的对数据库进行操作。对于Mybatis的使用方法大家应该都很熟悉，本文不再赘述，本文重点叙述Mybatis的原理，详细分析Mybatis如何完成从mapper到sql的转化过程。下文会重点叙述两个方面：</p><ol><li>启动时候Mybatis如何扫描并解析Mapper</li><li>运行时如何完成从对Mapper方法的调用转化成Sql</li></ol><h2 id="2、Mybatis扫描Mapper过程"><a href="#2、Mybatis扫描Mapper过程" class="headerlink" title="2、Mybatis扫描Mapper过程"></a>2、Mybatis扫描Mapper过程</h2><hr><h3 id="2-1、Mapper扫描过程源码分析"><a href="#2-1、Mapper扫描过程源码分析" class="headerlink" title="2.1、Mapper扫描过程源码分析"></a>2.1、Mapper扫描过程源码分析</h3><p>对于dataSource和SqlSessionFactory大家应该都比较了解，我们不难猜测MapperScannerConfigurer主要完成对Mapper的扫描和解析。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.apache.commons.dbcp.BasicDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>$&#123;jdbc.driverClassName&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>$&#123;jdbc.url&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>$&#123;jdbc.username&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>$&#123;jdbc.password&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    //负责加载解析mapper对应的xml配置，将mapper和mappedStatements等配置信息保存到DefaultSqlSessionFactory的configuration属性<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapperLocations<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath*:*.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.dao<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactoryBeanName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--事务管理器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sourceDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MapperScannerConfigurer实现BeanDefinitionRegistryPostProcessor接口，在对Bean实例化之前，通过回调postProcessBeanDefinitionRegistry方法register Mapper对应的BeanDefinition。最终将Mapper对应的Bean包装成MapperFactoryBean，并指定调用父类SqlSessionDaoSupport的setSqlSessionFactory方法给子类MapperFactoryBean添加对应的sqlSessionFactory属性。上述过程最终将Mapper转化成了MapperFactoryBean，如果对FactoryBean比较了解的话，应该知道后续我们通过@Autowired注解注入Mapper时候，会调用MapperFactoryBean的getObject()方法构造Mapper的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperScannerConfigurer</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">,</span> <span class="token class-name">BeanNameAware</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>processPropertyPlaceHolders<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">processPropertyPlaceHolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">ClassPathMapperScanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathMapperScanner</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//扫描指定的mapper</span>    scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">tokenizeToStringArray</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>basePackage<span class="token punctuation">,</span> <span class="token class-name">ConfigurableApplicationContext</span><span class="token punctuation">.</span>CONFIG_LOCATION_DELIMITERS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassPathMapperScanner</span> <span class="token keyword">extends</span> <span class="token class-name">ClassPathBeanDefinitionScanner</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">></span></span> <span class="token function">doScan</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> basePackages<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//调用父类方法扫描xml配置的mapper路径，返回对应的beanDefinitions</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">></span></span> beanDefinitions <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doScan</span><span class="token punctuation">(</span>basePackages<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinitions<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"No MyBatis mapper was found in '"</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>basePackages<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"' package. Please check your configuration."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//上述beanDefinitions 包装成MapperFactoryBean</span>      <span class="token function">processBeanDefinitions</span><span class="token punctuation">(</span>beanDefinitions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> beanDefinitions<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">></span></span> beanDefinitions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">GenericBeanDefinition</span> definition<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionHolder</span> holder <span class="token operator">:</span> beanDefinitions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      definition <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">GenericBeanDefinition</span><span class="token punctuation">)</span> holder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将mapper对应的beanDefinitions包装成MapperFactoryBean</span>      <span class="token class-name">MapperFactoryBean</span>      definition<span class="token punctuation">.</span><span class="token function">getConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addGenericArgumentValue</span><span class="token punctuation">(</span>definition<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// issue #59</span>      definition<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mapperFactoryBean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      definition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"addToConfig"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>addToConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> explicitFactoryUsed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">//如果xml配置了SqlSessionFactory调用父类SqlSessionDaoSupport的setSqlSessionFactory方法给子类MapperFactoryBean添加对应的sqlSession属性，最终每个Mapper都会创建一个SqlSessionTemplate</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactoryBeanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        definition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sqlSessionFactory"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeBeanReference</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactoryBeanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        explicitFactoryUsed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        definition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sqlSessionFactory"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        explicitFactoryUsed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">//如果xml配置了SqlSessionTemplate，调用父类SqlSessionDaoSupport的setSqlSessionTemplate方法给子类MapperFactoryBean添加对应的sqlSession属性，此时所有Mapper共享一个SqlSessionTemplate(线程安全)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplateBeanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitFactoryUsed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        definition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sqlSessionTemplate"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeBeanReference</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplateBeanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        explicitFactoryUsed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplate <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>explicitFactoryUsed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        definition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"sqlSessionTemplate"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>        explicitFactoryUsed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>explicitFactoryUsed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Enabling autowire by type for MapperFactoryBean with name '"</span> <span class="token operator">+</span> holder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"'."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        definition<span class="token punctuation">.</span><span class="token function">setAutowireMode</span><span class="token punctuation">(</span><span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">.</span>AUTOWIRE_BY_TYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionDaoSupport</span> <span class="token keyword">extends</span> <span class="token class-name">DaoSupport</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> externalSqlSession<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSqlSessionFactory</span><span class="token punctuation">(</span><span class="token class-name">SqlSessionFactory</span> sqlSessionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>externalSqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSqlSessionTemplate</span><span class="token punctuation">(</span><span class="token class-name">SqlSessionTemplate</span> sqlSessionTemplate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSession <span class="token operator">=</span> sqlSessionTemplate<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>externalSqlSession <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2、MapperFactoryBean构造真实Mapper"><a href="#2-2、MapperFactoryBean构造真实Mapper" class="headerlink" title="2.2、MapperFactoryBean构造真实Mapper"></a>2.2、MapperFactoryBean构造真实Mapper</h3><p>上文已经叙述过Spring依赖注入Mapper时候，会调用getObject方法来返回真实的实例，然后经由一系列过程调用MapperRegistry的getMapper方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperFactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">SqlSessionDaoSupport</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//上文已经知道getSqlSession()会返回SqlSessionTemplate的一个实例</span>    <span class="token keyword">return</span> <span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mapperInterface<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionDaoSupport</span> <span class="token keyword">extends</span> <span class="token class-name">DaoSupport</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> externalSqlSession<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSqlSessionFactory</span><span class="token punctuation">(</span><span class="token class-name">SqlSessionFactory</span> sqlSessionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>externalSqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionTemplate</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSession</span><span class="token punctuation">,</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">(</span><span class="token class-name">SqlSessionFactory</span> sqlSessionFactory<span class="token punctuation">,</span> <span class="token class-name">ExecutorType</span> executorType<span class="token punctuation">,</span>      <span class="token class-name">PersistenceExceptionTranslator</span> exceptionTranslator<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">notNull</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">,</span> <span class="token string">"Property 'sqlSessionFactory' is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">notNull</span><span class="token punctuation">(</span>executorType<span class="token punctuation">,</span> <span class="token string">"Property 'executorType' is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>executorType <span class="token operator">=</span> executorType<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator <span class="token operator">=</span> exceptionTranslator<span class="token punctuation">;</span>    <span class="token comment">//又是使用动态代理，对sqlSessionProxy方法的调用最终都会调用SqlSessionInterceptor的invoke方法</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionProxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SqlSession</span><span class="token punctuation">)</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>        <span class="token class-name">SqlSessionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token class-name">SqlSession</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">SqlSessionInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token comment">//返回sqlSessionFactory对应的Configuration</span>  <span class="token keyword">public</span> <span class="token class-name">Configuration</span> <span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MapperRegistry的getMapper方法会调用MapperProxyFactory的newInstance方法，该方法通过<font color="red"><strong>jdk动态代理</strong></font>来代理Mapper，后续对该Mapper所有方法的调用都会调用MapperProxy的invoke方法，至此完成了启动时Spring对Mapper的加载过程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperRegistry</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Configuration</span> config<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">,</span> <span class="token class-name">MapperProxyFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> knownMappers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">,</span> <span class="token class-name">MapperProxyFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">MapperRegistry</span><span class="token punctuation">(</span><span class="token class-name">Configuration</span> config<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> config<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">,</span> <span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">MapperProxyFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxyFactory <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MapperProxyFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> knownMappers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapperProxyFactory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Type "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">" is not known to the MapperRegistry."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> mapperProxyFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Error getting mapper instance. Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperProxyFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> mapperProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperProxy</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> mapperInterface<span class="token punctuation">,</span> methodCache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">newInstance</span><span class="token punctuation">(</span>mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、Mapper到sql的转化过程"><a href="#3、Mapper到sql的转化过程" class="headerlink" title="3、Mapper到sql的转化过程"></a>3、Mapper到sql的转化过程</h2><hr><p>通过上文我们知道在调用Mapper.insert(其他方法类似)时，会通过动态代理调用MapperProxy.invoke方法，该方法从缓存中获取MapperMethod，如果不存在就创建一个MapperMethod并缓存，然后调用MapperMethod.execute方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDefaultMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">invokeDefaultMethod</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//从缓存中获取MapperMethod，如果不存在就创建一个MapperMethod并缓存</span>    <span class="token keyword">final</span> <span class="token class-name">MapperMethod</span> mapperMethod <span class="token operator">=</span> <span class="token function">cachedMapperMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mapperMethod<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MapperMethod的execute方法又会调用SqlSessionTemplate的同名方法，上文提到由于sqlSessionProxy是代理对象，对其任何方法调用，会调用SqlSessionInterceptor的invoke方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperMethod</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">SqlSession</span> sqlSession<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Object</span> result<span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">case</span> INSERT<span class="token operator">:</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Object</span> param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//此处sqlSession为启动过程创建的SqlSessionTemplate</span>            result <span class="token operator">=</span> <span class="token function">rowCountResult</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">case</span> UPDATE<span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span> param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token function">rowCountResult</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">case</span> DELETE<span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span> param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token function">rowCountResult</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">case</span> SELECT<span class="token operator">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">hasResultHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token function">executeWithResultHandler</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>              result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsMany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token function">executeForMany</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token function">executeForMap</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              result <span class="token operator">=</span> <span class="token function">executeForCursor</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>              <span class="token class-name">Object</span> param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>              result <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token keyword">case</span> FLUSH<span class="token operator">:</span>            result <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">flushStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Unknown execution method for: "</span> <span class="token operator">+</span> command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">returnsVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Mapper method '"</span> <span class="token operator">+</span> command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token operator">+</span> <span class="token string">" attempted to return null from a method with a primitive return type ("</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">")."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionTemplate</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSession</span><span class="token punctuation">,</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> statement<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionProxy<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>statement<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SqlSessionInterceptor的invoke方法首先获取一个SqlSession(DefaultSqlSession)，然后通过反射调用DefaultSqlSession的对应方法，如果当前不存在事务，则直接commit。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//getSqlSession方法是后续Spring处理事务的核心，这里叙述下其过程：如果当前不存在事务，则每次都重新创建一个SqlSession；如果当前存在事务，则从Spring Transaction Manager获取，并将获取的SqlSession缓存到当前线程。这里判断是否存在、获取或者缓存SqlSession都是基于ThreadLocal的，后续在Spring事务博客中会详细介绍</span>      <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token class-name">SqlSessionUtils</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span>          <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">,</span>          <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>executorType<span class="token punctuation">,</span>          <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//反射调用DefaultSqlSession的同名方法</span>        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果当前不存在事务，则直接commit</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSqlSessionTransactional</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// force commit even on non-dirty sessions because some databases require</span>          <span class="token comment">// a commit/rollback before calling close()</span>          sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Throwable</span> unwrapped <span class="token operator">=</span> <span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> unwrapped <span class="token keyword">instanceof</span> <span class="token class-name">PersistenceException</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>          sqlSession <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>          <span class="token class-name">Throwable</span> translated <span class="token operator">=</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator<span class="token punctuation">.</span><span class="token function">translateExceptionIfPossible</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">PersistenceException</span><span class="token punctuation">)</span> unwrapped<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>translated <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            unwrapped <span class="token operator">=</span> translated<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">throw</span> unwrapped<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSession <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> <span class="token class-name">SqlSessionTemplate</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上文已经提到，启动过程中在构造sqlSessionFactory时候，会解析mapper对应的xml，并将配置信息缓存到configuration。我们知道在每个xml文件中需要配置一个namespace，然后还有很多sql，每个sql都对应的id，上述信息都会缓存到configuration的mappedStatements中。其中key=namespace+id，value是每条sql详细的配置信息。在获取到我们对应的MappedStatement后，然后调用executor.update方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSqlSession</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSession</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">String</span> statement<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      dirty <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment">//这里的statement就是xml配置的[namespace+id]从configuration获取指定的MappedStatement</span>      <span class="token class-name">MappedStatement</span> ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> executor<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token class-name">ExceptionFactory</span><span class="token punctuation">.</span><span class="token function">wrapException</span><span class="token punctuation">(</span><span class="token string">"Error updating database.  Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">ErrorContext</span><span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SimpleExecutor的doUpdate方法构造StatementHandler和prepareStatement，然后调用andler.update(stmt)，最终会调用SimpleStatementHandler的update方法。到这个方法我们终于看到具体的sql了，通过标准的Jdbc接口操作数据库。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">BaseExecutor</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">doUpdate</span><span class="token punctuation">(</span><span class="token class-name">MappedStatement</span> ms<span class="token punctuation">,</span> <span class="token class-name">Object</span> parameter<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Statement</span> stmt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">StatementHandler</span> handler <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">newStatementHandler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> <span class="token class-name">RowBounds</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      stmt <span class="token operator">=</span> <span class="token function">prepareStatement</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> ms<span class="token punctuation">.</span><span class="token function">getStatementLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> handler<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      <span class="token function">closeStatement</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> statement<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> sql <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getSql</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> parameterObject <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getParameterObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">KeyGenerator</span> keyGenerator <span class="token operator">=</span> mappedStatement<span class="token punctuation">.</span><span class="token function">getKeyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rows<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>keyGenerator <span class="token keyword">instanceof</span> <span class="token class-name">Jdbc3KeyGenerator</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      statement<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> <span class="token class-name">Statement</span><span class="token punctuation">.</span>RETURN_GENERATED_KEYS<span class="token punctuation">)</span><span class="token punctuation">;</span>      rows <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">getUpdateCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      keyGenerator<span class="token punctuation">.</span><span class="token function">processAfter</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> mappedStatement<span class="token punctuation">,</span> statement<span class="token punctuation">,</span> parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>keyGenerator <span class="token keyword">instanceof</span> <span class="token class-name">SelectKeyGenerator</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      statement<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>      rows <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">getUpdateCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      keyGenerator<span class="token punctuation">.</span><span class="token function">processAfter</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> mappedStatement<span class="token punctuation">,</span> statement<span class="token punctuation">,</span> parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      statement<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>      rows <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">getUpdateCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> rows<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何进行JVM GC调优</title>
      <link href="2021/01/20/gcresearch/"/>
      <url>2021/01/20/gcresearch/</url>
      
        <content type="html"><![CDATA[<p>下文通过3个案例来叙述JVM GC问题的根因定位和优化方案。</p><h2 id="一、CMS-background-gc导致服务频繁GC排查优化"><a href="#一、CMS-background-gc导致服务频繁GC排查优化" class="headerlink" title="一、CMS background gc导致服务频繁GC排查优化"></a>一、CMS background gc导致服务频繁GC排查优化</h2><h3 id="1-1、现象"><a href="#1-1、现象" class="headerlink" title="1.1、现象"></a>1.1、现象</h3><p>10.196.177.28一分钟触发了11次fullgc，查看监控，基本判断是old区达到设置阈值导致的fullgc。奇怪的是GC后old区内存是被回收了，但还是发生了11次fgc。这种情况大概率就是因为 cms background gc 导致的<br><img src="/2021/01/20/gcresearch/gc1.png" width="60%/"><br><img src="/2021/01/20/gcresearch/gc2.png" width="60%/"></p><h3 id="1-2、排查"><a href="#1-2、排查" class="headerlink" title="1.2、排查"></a>1.2、排查</h3><img src="/2021/01/20/gcresearch/gc3.png" width="60%/">CMS Final Remark 后，发生了一次 promotion failed，由于配置了 CMSScavengeBeforeRemark，在remark之前会进行一次younggc，但是younggc后，to space 不为空（正常younggc后，将eden和from中内存整理后，幸存的对象拷贝到to后，然后from取变成to，内存应该为0的，如下图）。to space 不为空，就是后续触发 gmc backgroud gc的导火索， CMS 的 background collector 每隔 2s 检查一次 GC 触发条件，其中一个条件就是 to space 不为空，这里不再赘述。<img src="/2021/01/20/gcresearch/gc4.png" width="60%/">那什么时候结束上述 cms background collector 呢，必须要等到 eden 去空间达到100%之后，然后触发一次 younggc，将to区可用空间重新置为0才能恢复。<h3 id="1-3、优化方案"><a href="#1-3、优化方案" class="headerlink" title="1.3、优化方案"></a>1.3、优化方案</h3><ul><li>降低 promotion failed 出现概率<ul><li>去掉 -XX:+CMSScavengeBeforeRemark remark之前，不再进行youngcc，不太可取</li><li>-XX:CMSInitiatingOccupancyFraction=80，降低参数阈值，old区保留足够的空间以便能放下young区晋升来的对象。</li></ul></li><li>提高 Young GC 的频率，这样即使 to space不为空，由于能快速进行一次youngc也能把 to space清理掉。该方案缺点也很明显，young区过小，会导致很多对象快速进入到 old区，导致fullgc 次数可能会过多</li></ul><h2 id="二、大对象导致Fullgc过快问题排查优化"><a href="#二、大对象导致Fullgc过快问题排查优化" class="headerlink" title="二、大对象导致Fullgc过快问题排查优化"></a>二、大对象导致Fullgc过快问题排查优化</h2><h3 id="2-1、现象"><a href="#2-1、现象" class="headerlink" title="2.1、现象"></a>2.1、现象</h3><img src="/2021/01/20/gcresearch/gc5.png" width="60%/">线上外卖2执行服务一共有接近100台机器，最近频繁收到机器FullGC相关的告警：短时间发生FullGC次数频繁，同时偶发性的FullGC后使用内存>=70。以 10.208.52.9 | set-hh-bcp-waimai2-executer11 这台机器为例，通过观察jvm.fullgc.count指标，该机器平均每分钟都会进行一次FullGC，同时结合观察jvm.memory.olden.used.percent指标，不难判断上述FullGC的原因是olden区使用内存达到阈值。结合上述指标我们基本可以判断FullGC根因是：系统有大对象生成，同时该大对象生成速度过快，结合偶发性的FullGC后使用内存>=70告警，可以进一步判断该对象的存活时间可能较长，一次FullGC还无法完全释放。<img src="/2021/01/20/gcresearch/gc6.png" width="60%/"><img src="/2021/01/20/gcresearch/gc7.png" width="60%/"><h3 id="2-2、排查"><a href="#2-2、排查" class="headerlink" title="2.2、排查"></a>2.2、排查</h3><ol><li>Dump 外卖2执行服务内存，发现MnsCacheManager对象占用内存较多，为了避免偶发性干扰，线上Dump了较多机器内存，基本都能稳定复现，详情见 Dump列表，基本都是OCTO相关的对象占用内存较大。<img src="/2021/01/20/gcresearch/gc8.png" width="60%/"><img src="/2021/01/20/gcresearch/gc9.png" width="60%/"></li><li>MnsCacheManager中有两个对象serviceCache，httpServiceCache，其中 defaultUpdateTime = 5，会有一个子线程每5s会全量刷新一次上面两个对象，考虑到外卖2执行服务上运行了很多业务RPC泛化调用脚本，涉及到不少下游业务服务，详情见 Raptor链接。经过和 OCTO 同学 沟通，该对象一共占用200多M内存基本符合调用的下游业务个数。那么大概原因是该对象产生的时间过于频繁导致的（每5s一次），同时由于会有RPC规则使用该对象，一旦RPC执行较慢，导致对象在一次FullGC后无法完全回收。   <img src="/2021/01/20/gcresearch/MnsCacheManager.png" width="60%/"><img src="/2021/01/20/gcresearch/scheduler.png" width="60%/"></li><li>确定上述可疑问题后，我们能想到的方案就是修改轮询时间，经过和 确认，OCTO客户端没有提供修改轮询时间的参数，同时 defaultUpdateTime = 5，同时该参数是一个final变量，也无法在启动时候通过反射修改。<img src="/2021/01/20/gcresearch/defaultUpdateTime.png" width="60%/"></li><li>于是决定创建一个同类路径同名的 MnsCacheManager，直接修改轮询时间为60s，同时添加方法耗时Transaction打点，便于来观测和验证上述猜测的方法耗时相对较长<img src="/2021/01/20/gcresearch/transaction.png" width="60%/"></li><li>然后重新编译该类 MnsCacheManager，生成 MnsCacheManager.class和两个匿名内部类，将生成后的该类添加到 mns-invoker-1.12.0.jar 包里面，然后将该 jar 包直接上传到线上一台外卖2执行机器，重新启动进行验证。<img src="/2021/01/20/gcresearch/class.png" width="60%/"><img src="/2021/01/20/gcresearch/class2.png" width="60%/"></li><li>重新启动使用经过修改后的 mns-invoker-1.12.0.jar  包的机器，13点18分服务重启后，虽然相对其他服务FullGC还是较为频繁，但和13点18分之前的几乎一分钟进行一次FullGC相比已经有了明显下降。<img src="/2021/01/20/gcresearch/fullgc.png" width="60%/">同时观察 Raptor Transaction 报表，已经可以看到 RefreshMnsCacheManager，每60s执行一次，说明我们修改轮询时间的代码生效了。<img src="/2021/01/20/gcresearch/cat.png" width="60%/"></li><li>同时，为了进一步确认是由于 OCTO 的上述对象无法在YoungGC全部回收，导致对象频繁进入老年代，进一步通过调整JVM启动参数，添加 PrintClassHistogramBeforeFullGC和PrintClassHistogramBeforeAfterGC参数，通过FullGC前后对比来发现哪些对象频繁进入到老年代（我们这个发布的版本是我们修改 MnsCacheManager 类之前的版本，更容易观察OCTO产生的大对象）。</li><li>通过观察FullGC前后对比，发现OCTO关联的 SGService和ServiceDetail对象，在FullGC前，该对象被回收了几乎一半，这个也说明确实有很多OCTO对象无法在年轻代中被回收，只能晋升到老年代，同时老年代发生了一次FullGC后，还无法完全回收该内存，因为可能存在业务的RPC调用代码会使用上述配置。另外，除OCTO相关对象外，其他占用较多内存的GC前后内存基本没有变化，应该是服务正常运行会缓存一部分配置信息的原因。<br><br>下图是FullGC前堆内存分享分布    <img src="/2021/01/20/gcresearch/dump1.png" width="60%/">下图是FullGC后堆内存分享分布<img src="/2021/01/20/gcresearch/dump2.png" width="60%/"></li></ol><h3 id="2-3、结论"><a href="#2-3、结论" class="headerlink" title="2.3、结论"></a>2.3、结论</h3><p>外卖2执行服务FullGC过快的原因确实是由于 OCTO MnsCacheManager 每5s会全量更新一次缓存导致，由于外卖2执行服务会运行大量配置的RPC泛化调用规则，涉及到较多下游服务，详情见 Raptor链接，导致每5s会产生超过 200M OCTO相关对象。另外由于部分业务规则RPC调用逻辑会使用上述缓存的OCTO配置信息，部分方法执行较慢，导致OCTO上述大对象在一次FullGC后释放不明显，进而加剧了服务FullGC告</p><h3 id="2-4、优化"><a href="#2-4、优化" class="headerlink" title="2.4、优化"></a>2.4、优化</h3><ul><li>OCTO侧：希望客户端SDK提供修改MnsCacheManager缓存的轮询频率设置，同时评估下上述对象占用内存有没有减小的可能</li><li>BCP侧：建立业务RPC泛化调用规则耗时监控机制，实时发现长耗时规则，并持续推进业务治理</li></ul><h2 id="三、MetaSpace持续增长优化"><a href="#三、MetaSpace持续增长优化" class="headerlink" title="三、MetaSpace持续增长优化"></a>三、MetaSpace持续增长优化</h2><h3 id="3-1、现象"><a href="#3-1、现象" class="headerlink" title="3.1、现象"></a>3.1、现象</h3><p>BCP规则执行服务运行一般时间就会持续出现Metaspace溢出导致服务持续FGC，但是内存很难释放，最终直至出现OOM</p><h3 id="3-2、排查"><a href="#3-2、排查" class="headerlink" title="3.2、排查"></a>3.2、排查</h3><p>主要原因如下：</p><ul><li>GroovyClassLoader动态加载脚本：BCP规则执行服务使用GroovyClassLoader动态加载业务10000多个规则校验脚本，脚本变更都会重新加载</li><li>反射调用：业务部分BCP规则脚本频繁使用反射调用，也会导致MetaSpace增加较快</li></ul><h3 id="3-3、优化"><a href="#3-3、优化" class="headerlink" title="3.3、优化"></a>3.3、优化</h3><ul><li>业务层面拆分集群，将10000多个Java规则拆分到不同集群，并增加JVM最大MetaSpace配置</li><li>配置Dsun.reflect.inflationThreshold=2147483647，用于设置反射对象的膨胀阈值。具体来说，可以控制通过反射生成字节码。（该值表示 反射调用多少次 才开始生成字节码） 。当把该参数这是int 最大值时，说明永不生成字节码。参考 <a href="https://stackoverflow.com/questions/16130292/java-lang-outofmemoryerror-permgen-space-java-reflection?from=citadel_page">MetaSpace  OOM</a><pre class="line-numbers language-text" data-language="text"><code class="language-text">If you are on a Oracle JVM then you would only need to set:-Dsun.reflect.inflationThreshold&#x3D;2147483647If you are on IBM JVM, then you would need to set:-Dsun.reflect.inflationThreshold&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>XX:SoftRefLRUPolicyMSPerMB=7000，控制Java软引用对象是否被回收，SoftReference对象到底在GC的时候要不要回收是通过如下的一个公式来判定的：<pre class="line-numbers language-text" data-language="text"><code class="language-text">clock - timestamp &lt;&#x3D; freespace * SoftRefLRUPolicyMSPerMB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个公式的意思就是说：</li><li>clock - timestamp 代表了一个软引用对象他有多久没被访问过了</li><li>freespace 代表JVM中的空闲内存空间</li><li>SoftRefLRUPolicyMSPerMB 代表每一MB空闲内存空间可以允许SoftReference对象存活多久  </li></ul><p>所以一旦这个参数设置为0之后，直接导致clock - timestamp &lt;= freespace * SoftRefLRUPolicyMSPerMB这个公式的右半边是0，就导致所有的软引用对象，比如JVM生成的那些奇怪的Class对象，刚创建出来就可能被一次Young<br>最终排查下来还是因为 SoftRefLRUPolicyMSPerMB设置成0，导致线上Dump发现有很多SoftReference类对象，可以将这个参数适当调大一点即可  </p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postman和Java Client访问K8s</title>
      <link href="2018/11/11/k8s/"/>
      <url>2018/11/11/k8s/</url>
      
        <content type="html"><![CDATA[<p>K8s的所有操作基本都是通过调用kube-apiserver这个组件进行的，它提供了restful api供外部系统访问，当然为了保证整个k8s集群的安全性，k8s提供了多种认证方式来保证集群的安全性：比如客户端证书、静态token、静态密码文件、ServiceAccountTokens等等。你可以同时使用一种或多种认证方式。只要通过任何一个都被认作是认证通过，我们一般都是使用证书方式：客户端证书认证叫作TLS双向认证(关于SSL/TLS认证的可以参考这篇文章<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS协议运行机制的概述》</a>)，也就是服务器客户端互相验证证书的正确性，在都正确的情况下协调通信加密方案。下面来看下如何配置客户端证书验证，我们通过配置一个kubeconfig文件来讲解下</p><span id="more"></span><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/kubeconfig.jpeg" width="600" hegiht="300"><p>红框标出的3个参数分别如下：<br>certificate-authority CA 证书的路径。<br>client-certificate TLS 证书文件<br>client-key TLS Key 文件<br>注意以上3个文件是由k8s集群服务端授权生成的，需要服务端提供给客户端。<br>下面我们分别介绍下如何通过Postman和java client来调用kube-apiserver提供的api</p><h2 id="Postman访问kube-apiserver"><a href="#Postman访问kube-apiserver" class="headerlink" title="Postman访问kube-apiserver"></a>Postman访问kube-apiserver</h2><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/postman1.jpeg" width="600" hegiht="300">这里我们以获取集群某个namespaces下面所有的pod列表api来演示，我们直接通过Postman发起一个get请求，可以看到报403 Forbidden错误。这是因为k8s集群开启了客户端证书认证，我们可以通过下面的办法来解决这个问题。<ul><li>首先确保Postman是最新版本，最新版本可以支持添加证书</li><li>打开设置，把SSL certificate verification关闭，然后点击证书 tab添加证书，分别输入kube-apiserver地址，证书文件和秘钥，然后添加<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/postman2.jpeg" width="400" hegiht="200"> &nbsp;&nbsp;<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/postman3.jpeg" width="400" hegiht="200"></li><li>最后重新访问，可以看到此时http请求返回200，可以正常访问(<font color="red">注意postman请求地址不要添加端口号</font>)<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/postman4.jpeg" width="600" hegiht="300"><br>另外我们通过command+option+c可以打开postman的console，可以看到发送的请求会自动附带Client Certificate信息<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201811/console.jpeg" width="600" hegiht="300"></li></ul><h2 id="Java-client访问kube-apiserver"><a href="#Java-client访问kube-apiserver" class="headerlink" title="Java client访问kube-apiserver"></a>Java client访问kube-apiserver</h2><p>pom.xml文件添加以下依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;io.kubernetes&lt;&#x2F;groupId&gt;&lt;artifactId&gt;client-java&lt;&#x2F;artifactId&gt;&lt;version&gt;3.0.0&lt;&#x2F;version&gt;&lt;scope&gt;compile&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class K8s &#123;    public static void main(String[] args) throws IOException, ApiException &#123;        ApiClient client &#x3D; Config.fromConfig(&quot;&#x2F;Users&#x2F;xiaoming&#x2F;me&#x2F;study&#x2F;kubernetes&#x2F;kubeconfig&quot;);        Configuration.setDefaultApiClient(client);        CoreV1Api api &#x3D; new CoreV1Api();        V1PodList list &#x3D; api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null);        for (V1Pod item : list.getItems()) &#123;            System.out.println(item.getMetadata().getName());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">以上强调一下，上述配置的kubeconfig中需要显示指定访问的k8s cluster的server地址</font></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.51cto.com/lookingdream/2108034">k8s认证授权详解</a><br><a href="https://www.kubernetes.org.cn/2540.html">Kubernetes 的证书认证</a><br><a href="https://www.jianshu.com/p/6a6abeefbcbf">k8s证书配置，dns，dashboard</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis热点Key解决方案</title>
      <link href="2018/10/01/redishotkey/"/>
      <url>2018/10/01/redishotkey/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>Squirrel是基于redis cluster开发的K-V存储系统，对某个key进行读写时，会根据该key的hash计算出对应的slot，根据这个slot就能找到与之对应的分片(一个master和多个slave组成的一组redis集群)来存取该K-V，如果集群不发生服务器数量变化，那么这一映射关系就不会变化。但是在实际应用过程中，对于某些特定业务或者一些特定的时段，可能会发生大量的请求访问同一个key。所有的请求（且这类请求读写比例非常高）都会落到同一个redis server上，该redis的负载就会严重加剧，此时整个系统增加新redis实例也没有任何用处，因为根据hash算法，同一个key的请求还是会落到同一台新机器上，该机器依然会成为系统瓶颈。若此热点 key 的 value 也比较大，也会造成网卡达到瓶颈。这个问题称为 “热点key” 问题。</p><ul><li>对于读命令，如果客户端开启了master-slave配置，所有的请求会平均落到这组分片里面满足路由策略的所有节点，此时我们还可以通过水平增加从节点来解决。</li><li>对于写命令，所有的请求都会落所属分片master节点。此时通过水平增加从节点已经解决不了问题了。</li></ul><img src="/2018/10/01/redishotkey/redisCluster.jpg" width="50%/"><h2 id="二、现状"><a href="#二、现状" class="headerlink" title="二、现状"></a>二、现状</h2><p>随着公司业务规模越来越大，基本上所有的业务都接入了Squirrel，目前我们线上redis集群支撑了每天服务端万亿+、端到端3000亿+的调用量。用户因为一些业务的特性触发热点问题是业务需要，是不可避免，理所当然的，难免会触发“热点key问题”。在发现有热点的情况下，如果继续放任该热点无限激增，就会带来整个系统雪崩似宕机。之前的做法会根据QPS或带宽，如果发现了热点key，我们就会对用户进行流控，限流会对热点key所属的category整体进行限流。这样确实能暂时解决热点key问题，但是由于少数几个热点key就造成整Category不可用，显然对于用户来说是不可接受的。用户触发热点问题是业务需要，是理所当然；Squirrel对热点key进行流控是保障系统稳定性，也在情理之中。但有没有一种既能提供用户热点key访问的需求，又能保护redis server服务器的方法，正是本文所要阐述的。</p><h2 id="三、思考"><a href="#三、思考" class="headerlink" title="三、思考"></a>三、思考</h2><p>对于redis热点key问题，目前我们主要面临两个问题：</p><ul><li>如何高效的发现热点key</li><li>发现热点key后如何处理 </li></ul><p>目前如何准确实时发现热点key其实对我们来说相对更难一点，如果能准确发现热点key，后续我们可以有很好的方案来解决热点问题。</p><h3 id="3-1、热点key的发现"><a href="#3-1、热点key的发现" class="headerlink" title="3.1、热点key的发现"></a>3.1、热点key的发现</h3><p>目前业要有以下五种方案来寻找热点key，第五种是我们squirrel团队正在开发的，分别简要介绍。</p><ol><li>客户端：客户端是距离key”最近”的地方，redis的命令每次都是从客户端触发的，基于此我们可以在squirrel-client的一些代码处进行统计计数。但是这种方案也存在一些问题。无法预知key的个数，存在内存泄漏的风险；只能解决当前客户端的热点key，无法实现规模化的运维统计。</li><li>代理端：像Twemproxy，codis这些基于代理的redis分布式架构，所有的客户端请求都是通过代理端完成的。此架构就很适合做热点key的统计，因为代理是所有redis客户端和服务端的桥梁。但是我们squirrel是基于redis cluster直连无中间层的设计，显然这种方案无法满足。</li><li>服务端：redis monitor命令可以统计出一段时间内的某redis节点上的所有命令。因为monitor命令会监控该节点的所有的命令，为了减少网络开销以及加快输出缓冲区的速度，monitor尽可能在本机执行。此种方法也有以下问题：在高并发条件下，会存在内存暴涨和redis性能的隐患，所以此种方法适合在短时间内使用；同样只能统计一个redis节点的热点key，对于集群需要汇总统计。</li><li>机器层面：Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。如果站在机器的角度，可以通过对机器上所有Redis端口的TCP数据包进行抓取完成热点key的统计。此种方法对于redis客户端和服务<br>端来说毫无侵入，但是依然存在问题：需要一定开发成本，由于是以机器为单位进行统计，想要了解集群维度热点key，后期还是需要汇总统计。</li><li>修改 redis server 源码：redis4.0为我们带来了许多新特性，其中便包括基于LFU的热点key发现机制，可以在此基础上实现热点key的发现。这个是我们Squirrel团队最终的解决方案，目前正在开发</li></ol><p>目前我们 Squirrel-web 管理平台发现热点Key的方案是分析集群各节点QPS倾斜情况，找出QPS异常高的节点，然后采用上述第三种方案针对该节点调用 redis monitor 命令1-2s 获取节点操作日志，进而通过正则表达式抓取热点Key，分析其中每个Key的操作占比，选取大于设定阈值的Key作为热点Key返回。最终优化方案会采用方案五，目前正在开发。<br>Squirrel-schedule 作为自动化运维服务，考虑到 1-2s 的时间还是存在阻塞风险，因此换用 Jedis Client 提供的 JedisMonitor API 获取指定条数的日志来代替直接使用时间。</p><h3 id="3-2、热点key的处理"><a href="#3-2、热点key的处理" class="headerlink" title="3.2、热点key的处理"></a>3.2、热点key的处理</h3><ol><li>拆分复杂数据结构：如果当前key的类型是一个二级数据结构，例如hash。如果该hash元素个数比较多，可以考虑对当前hash进行拆分，这样热点key可以分拆为若干个新的key分布到不同的redis节点上，从而减轻单节点压力。</li><li>多副本：在查找到了热点key后，目前的一些处理手段把这个热点key增加多个副本来解决，这个策略主要针对读多写少的场景有效，如果都是写的热点key，多副本无效。这个方案我们之前的客户端已经实现了，后来测试下来觉得有有些问题:比如写的时候要写多副本，存在数据一致性问题。所以目前也不建议采用这种方案。</li><li>本地缓存：对于数据一致性不是那么高的业务，可以将热点key缓存到业务机器的本地缓存中，因为是业务端的本地内存中，省去了一次远程的IO调用。但是当数据更新时，可能会造成业务和redis数据不一致。对于这种方案我们目前最新的客户端版本已经实现了基于热点key本地缓存，不需要业务改任何代码，对业务端完全透明。业务可以设置key的过期时间，key过期后我们会从redis服务端获取并更新本地缓存。</li><li>迁移热点key：以 redis cluster 为例，我们可以将热点key所在的 slot 单独迁移到一个新的redis分片。这样这个热点key即使qps很高，也不会影响到整个集群的其他业务。这个方案目前我们也已经实现了，并能做到自动迁移热点key到一个独立的分片。下图是外卖的一个线上业务，红框的这个分片虽然只分配了2个slot，但是单节点qps仍然比其他分片高多了，因为这个热点key被我们迁出去了，它是一个单独的热点分片。<img src="/2018/10/01/redishotkey/slot.png" width="50%/"><br>由于热点Key的产生具有突发性，且不立刻干预的话危害较大，因此 Squirrel-schedule 自动化运维服务会对持续出现的热点Key进行自动化迁移，例如下图：<img src="/2018/10/01/redishotkey/daxiang.png" width="50%/"></li><li>热点key限流：对于读命令我们可以通过迁移热点key然后添加从节点来解决，对于写命令我们可以通过单独针对这个热点key来限流，目前我们管理平台也支持这个操作。上面 3.本地缓存的配图里面可以开启单key限流 </li></ol><h2 id="四、Squirrel解决方案"><a href="#四、Squirrel解决方案" class="headerlink" title="四、Squirrel解决方案"></a>四、Squirrel解决方案</h2><p>目前Squirrel已经提供了一套相对成熟的针对热点key的解决方案。覆盖了从如何快速准确的发现热点key，到发现热点key的后续处理。</p><h3 id="4-1、整体方案"><a href="#4-1、整体方案" class="headerlink" title="4.1、整体方案"></a>4.1、整体方案</h3><img src="/2018/10/01/redishotkey/fangan.png" width="50%/">以上主要分为三个阶段:实时采样，实时分析，热点key处理。目前的架构和最终架构的不同点是如何获取指定节点上的热点key，其他过程都一样。<h3 id="4-2、实时采样"><a href="#4-2、实时采样" class="headerlink" title="4.2、实时采样"></a>4.2、实时采样</h3><p>squirrel-monitor-service会实时采集所有集群的拓扑结构和QPS、网卡流量等监控数据，然后发送到kafka集群。<br>squirrel-schedule-service会实时消费这些集群监控数据topic。(Squirrel团队模块—Squirrel的架构图)</p><h3 id="4-3、实时分析"><a href="#4-3、实时分析" class="headerlink" title="4.3、实时分析"></a>4.3、实时分析</h3><img src="/2018/10/01/redishotkey/analyze.png" width="50%/">实时分析主要是基于redis监控数据的处理，实时的分析出QPS存在倾斜的集群，自动找出这些QPS倾斜集群中的热点server，并根据业务配置的白名单来调用redis monitor命令智能的发现热点key。上面说了redis monitor命令存在内存暴涨和性能问题，所以我们严格控制调用时间是1-2s。我们目前正在对redis源码进行修改，最终会支持redis server端自动发现热点key，并且对性能没有任何影响<h3 id="4-4、热点key处理"><a href="#4-4、热点key处理" class="headerlink" title="4.4、热点key处理"></a>4.4、热点key处理</h3><p>实时分析阶段发现了集群中存在热点key。业务如果对于数据一致性要求没那么高的情况下，建议接入最新的squirrel-client并在管理平台上配置热点key本地缓存。当然如果业务要求严格的数据一致性，我们也可以自动迁移热点key到单独的分片。</p><h2 id="五、热点Key相关参数配置"><a href="#五、热点Key相关参数配置" class="headerlink" title="五、热点Key相关参数配置"></a>五、热点Key相关参数配置</h2><p>热点Key配置页位于集群运维页的热点Key标签页下：</p><img src="/2018/10/01/redishotkey/config.png" width="50%/"><p>其中开启自动扫描后，可以自动发现集群中存在的热点key</p><img src="/2018/10/01/redishotkey/hotkey1.png" width="50%/"><img src="/2018/10/01/redishotkey/hotkey2.png" width="50%/">]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始学TIDB二(TIDB简介与整体架构)</title>
      <link href="2018/08/27/tidb2/"/>
      <url>2018/08/27/tidb2/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客，我们简单介绍了怎么在Mac OS系统上面使用docker compose搭建一个包含3个pd，3个tikv，1个tidb的<a href="http://yeming.me/2018/08/26/tidb1/">TIDB集群</a>。本文，我们会详细介绍TIDB的一些基本概念和整体架构。</p><h2 id="TIDB-简介"><a href="#TIDB-简介" class="headerlink" title="TIDB 简介"></a>TIDB 简介</h2><p>TIDB是pingcap公司开源的一款分布式数据库，结合了RDBMS和NOSQL两者的特性，支持对业务无感知的水平扩容，具备数据强一致性和高可用性。TIDB具备以下特性对某些业务应该有很大的吸引力。</p><ul><li><p>兼容MYSQL协议：由于TIDB兼容了MYSQL协议，业务几乎可以零成本的从MYSQL迁移到TIDB。</p></li><li><p>水平弹性扩展：mysql虽然也可以分库分表水平扩展，但是如果需要继续水平扩容，就需要dba迁移数据，客户端可能还要修改路由规则。TIDB可以按需水平扩展吞吐或存储，数据自动迁移。</p></li><li><p>分布式事物：TIDB支持分布式事物。</p></li><li><p>高可用数据强一致：TIDB基于raft的多数派选举保证了数据的强一致性，并且在不丢失大部分副本的情况下，可以自动failover。</p><span id="more"></span><h2 id="TiDB-整体架构"><a href="#TiDB-整体架构" class="headerlink" title="TiDB 整体架构"></a>TiDB 整体架构</h2><p>之前我们搭建了包含3个pd，3个tikv，1个tidb的<a href="http://yeming.me/2018/08/26/tidb1/">TIDB集群</a>，从这里可以看出TIDB其实主要包含了以下3个模块：<br>tidb server，tikv server，pd server</p><center><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/tidbArch.jpeg" width="350" hegiht="200"></center></li><li><p>tidb server：tidb server负责和客户端进行交互。tidb server接受客户端的sql语句进行解析，通过PD获取sql关联的数据对应的tikv server对应的地址，然后访问相应的tikv server，获取数据(或者修改数据)，然后返回结果给客户端。tidb server本身不存储任何数据，只提供计算能力，本身是无状态的，可以根据需要水平扩展。</p></li><li><p>pd server：pd server是整个TIDB的管理模块。主要负责以下工作：存储集群的元信息(某个key存储在哪个tikv上)；对tikv集群进行调度和负载均衡(数据迁移，raft group leader的迁移)；分配全局唯一且递增的事物id；pd本身通过raft协议选举leader保证高可用性，建议线上至少部署3个pd节点。</p></li><li><p>tikv server：tikv server负责存储数据。tikv server使用rocksdb，提供了分布式key-value的存储引擎。数据存储的基本单位是region，每个tikv负责多个region，每个region包含了一个存储range，从start到end的一个范围。tikv使用raft协议做复制，保持数据的强一致和容灾。副本以region为单位进行管理，不同tikv节点上的leader和副本region构成一个raft group，互为副本。由pd来统一负责region在tikv上的负载均衡。(这里可以类比于kafka架构，region类似于partition，副本类似于replica)</p></li></ul><p>总结下：TIDB由tidb，tikv，pd三个模块组成，tidb负责与客户端通信，提供了计算能力，tikv负责存储真正的数据，提供存储能力，pd作为管理模块，存储集群的一些元信息以及负责对整个集群进行管理调度。可以看到TIDB不同于MYSQL和其他Nosql存储，它是计算和存储分开的，各个模块都可以通过无线的水平扩展保证高可用性。</p><h2 id="TiDB-的最佳适用场景"><a href="#TiDB-的最佳适用场景" class="headerlink" title="TiDB 的最佳适用场景"></a>TiDB 的最佳适用场景</h2><p>简单来说，TiDB 适合具备下面这些特点的场景：</p><ul><li>数据量大，单机保存不下 </li><li>不希望做 Sharding 或者懒得做 Sharding </li><li>访问模式上没有明显的热点 </li><li>需要事务、需要强一致</li></ul><h2 id="SQL到KV的映射"><a href="#SQL到KV的映射" class="headerlink" title="SQL到KV的映射"></a>SQL到KV的映射</h2><p>通过上面介绍，我们知道了tikv基于rocksdb存储引擎以key-value的形式保存数据，这个和其他RDBMS基于table rows来保存数据不同。但是tidb又兼容了MYSQL协议，这是什么意思呢？就是我们完全可以像使用mysql一样使用tidb，我们可以发送一条sql命令给tidb</p><pre class="line-numbers language-none"><code class="language-none">select * from user<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正因为tidb兼容了mysql协议，所以业务可以几乎零成本的迁移到tidb。下面我们来看下tidb是怎么完成从SQL到KV的转换的。<br>假设我们有以下一张表：</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE User &#123;    ID int,    Name varchar(20),    Age int,    PRIMARY KEY (ID)，    Key idxAge (age)&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于一个table来说，需要存储的数据包括以下三个部分：</p><ul><li>表的元信息</li><li>Table中的row</li><li>索引数据</li></ul><p>对于tidb来说，必须能把以上数据通过某种算法转换成key-value形式发送给tikv。因为我们要像多数RDBMS一样支持大象OLTP业务，需要支持快速读取，保存，修改，删除数据，所以这个转换算法的设计就尤为关键了。<br>我们可以把tikv想象成一个包含很多key-value键值对的map，可以类比JAVA的TreeMap，将key按照一定的规则进行排序。这样tikv其实就是一个全局有序的分布式key-value引擎，这点很重要，能保证我们根据某个条件快速检索出需要的key。下面我们看下，tidb是怎么讲table转换为key-value的。</p><ul><li>TiDB 对每个表分配一个 TableID，每一个索引都会分配一个 IndexID，每一行分配一个 RowID（如果表有整数型的 Primary Key，那么会用 Primary Key 的值当做 RowID），其中 TableID 在整个集群内唯一，IndexID/RowID 在表内唯一，这些 ID 都是 int64 类型。 每行数据按照如下规则进行编码成 Key-Value pair：<pre class="line-numbers language-none"><code class="language-none">Key： tablePrefix_rowPrefix_tableID_rowIDValue: [col1, col2, col3, col4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>其中 Key 的 tablePrefix/rowPrefix 都是特定的字符串常量，用于在 KV 空间内区分其他数据。 对于 Index 数据，根据Index是UK和非UK分别按照以下不同规则编码成Key-Value<br>Unique Index：因为indexColumnsValue是唯一的，所以下面构造的key也是全局唯一的<pre class="line-numbers language-none"><code class="language-none">Key: tablePrefix_idxPrefix_tableID_indexID_indexColumnsValueValue: rowID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>非Unique Index：因为indexColumnsValue不是唯一的，所以不能按照上述规则来构造key，我们可以按照下面规则<pre class="line-numbers language-none"><code class="language-none">Key: tablePrefix_idxPrefix_tableID_indexID_ColumnsValue_rowIDValue：null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>说明：对于上述key中出现的tablePrefix，rowPrefix，idxPrefix都是一些常量。另外tableID式全局唯一的，rowID和indexID是表内唯一的。这样一个 Table 内部所有的 Row 都有相同的前缀，一个 Index 的数据也都有相同的前缀。这样一个表的所有 Row 数据就会按照 RowID 的顺序排列在 TiKV 的 Key 空间中，某一个 Index 的数据也会按照 Index 的 ColumnValue 顺序排列在 Key 空间内。显然，这种构造key的方式对于点查和范围查询都比较友好。</p><p><b>tablePrefix，rowPrefix，idxPrefix对应常量</b></p><pre class="line-numbers language-none"><code class="language-none">var(    tablePrefix     &#x3D; []byte&#123;&#39;t&#39;&#125;    recordPrefixSep &#x3D; []byte(&quot;_r&quot;)    indexPrefixSep  &#x3D; []byte(&quot;_i&quot;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面举个例子来说明上述构造规则，我们还是以最开始的User表来构造以下3条数据：</p><pre class="line-numbers language-none"><code class="language-none">id  name          age1   &#39;zhangsan&#39;    202   &#39;lisi&#39;        183   &#39;wangwu&#39;      22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>User表存在Primary Key(id)，假设User表tableId 为1，所以上述3条数据可以转换为以下key-value pair</p><pre class="line-numbers language-none"><code class="language-none">key         value t_r_1_1     [&#39;zhangsan&#39;, 20]t_r_1_2     [&#39;lisi&#39;, 18]t_r_1_3     [&#39;wangwu&#39;, 22]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外该表在age上还有一个Index，假设indexID为1，对应key-value pair如下</p><pre class="line-numbers language-none"><code class="language-none">key             valuet_i_1_1_20_1    nullt_i_1_1_18_2    nullt_i_1_1_22_3    null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>很多数据库都会实现多版本控制（MVCC），TiKV 也不例外。 TiKV 的 MVCC 实现是通过在 Key 后面添加 Version 来实现，简单来说，没有 MVCC 之前，可以把 TiKV 看做这样的：</p><pre class="line-numbers language-none"><code class="language-none">Key1 -&gt; ValueKey2 -&gt; Value……KeyN -&gt; Value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有了 MVCC 之后，TiKV 的 Key 排列是这样的：</p><pre class="line-numbers language-none"><code class="language-none">Key1-Version3 -&gt; ValueKey1-Version2 -&gt; ValueKey1-Version1 -&gt; Value……Key2-Version4 -&gt; ValueKey2-Version3 -&gt; ValueKey2-Version2 -&gt; ValueKey2-Version1 -&gt; Value……KeyN-Version2 -&gt; ValueKeyN-Version1 -&gt; Value……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，对于同一个 Key 的多个版本，我们把版本号较大的放在前面，版本号小的放在后面，这样当用户通过一个 Key + Version 来获取 Value 的时候，可以将 Key 和 Version 构造出 MVCC 的 Key，也就是 Key-Version。然后可以直接 Seek(Key-Version)，定位到第一个大于等于这个 Key-Version 的位置。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TIDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始学TIDB一(搭建TIDB集群)</title>
      <link href="2018/08/26/tidb1/"/>
      <url>2018/08/26/tidb1/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何在单机上(Mac OS)通过 <a href="https://docs.docker.com/compose/overview/">Docker Compose</a> 快速一键部署一套 TiDB 测试集群，我们会从零开始搭建一套由3 个 PD，3 个 TiKV，1 个 TiDB构成的集群。主要包括以下两个步骤：</p><ul><li>Mac OS系统上安装docker，docker-compose</li><li>使用 Docker Compose 快速构建集群</li></ul><span id="more"></span><h2 id="下载docker"><a href="#下载docker" class="headerlink" title="下载docker"></a>下载docker</h2><p>Mac OS上安装docker有以下两种方法：Docker for Mac，Docker Toolbox</p><ul><li>Docker Toolbox：Docker Toolbox会安装一个VirtualBox VM。这个虚拟机启动后，会作为docker运行的宿主机器，然后会通过boot2docker在虚拟机上创建一个docker环境。</li><li>Docker for Mac：Docker for Mac使用<a href="https://github.com/docker/HyperKit/">HyperKit</a>替换了VirtualBox VM，HyperKit会在Mac OS上构建一个更轻量级的虚拟环境，相比Docker Toolbox，每次都要登录到VirtualBox VM虚拟机，更有原生的感觉。</li></ul><p>关于两者的比较具体可以参考<a href="https://docs.docker.com/docker-for-mac/docker-toolbox/">Docker for Mac vs. Docker Toolbox</a><br>3年前我就在自己的Mac OS上安装过Docker Toolbox，现在使用Docker for Mac，Mac OS可以直接在Mac的terminal上执行docker ps 之类的命令，体验会更好，所以下面我会以Docker for Mac来安装docker。</p><h2 id="安装Docker-for-Mac"><a href="#安装Docker-for-Mac" class="headerlink" title="安装Docker for Mac"></a>安装Docker for Mac</h2><ul><li>下载<a href="https://download.docker.com/mac/stable/Docker.dmg">Docker for Mac</a></li><li>下载完成后，双击Docker.dmg，安装Docker for Mac。</li><li>安装完成后，Mac右上角会出现一个鲨鱼的标志<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/macBar.jpeg" width="300" hegiht="50"> </li><li>点击上述鲨鱼标志的About Docker，可以看到docker和docker compose都安装成功<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/docker.jpeg" width="300" hegiht="150"></li></ul><h2 id="使用Docker-Compose快速构建集群"><a href="#使用Docker-Compose快速构建集群" class="headerlink" title="使用Docker Compose快速构建集群"></a>使用Docker Compose快速构建集群</h2><h3 id="Docker-Compose介绍"><a href="#Docker-Compose介绍" class="headerlink" title="Docker Compose介绍"></a>Docker Compose介绍</h3><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。Compose 定位是定义和运行多个 Docker 容器的应用</p><p>我们知道通过创建一个Dockerfile模板文件，可以很方便的定义一个单独的应用容器。然而，我们在日常工作中，经常需要多个容器配合来完成某项任务。例如我们想要搭建一套TIDB集群，我们需要创建3 个 PD，3 个 TiKV，1 个 TiDB。<br>Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），下面是TIDB的YAML文件</p><pre class="line-numbers language-none"><code class="language-none">$ cat docker-compose.yml version: &#39;2.1&#39;services:  pd0:    image: pingcap&#x2F;pd:latest    ports:      - &quot;2379&quot;    volumes:      - .&#x2F;config&#x2F;pd.toml:&#x2F;pd.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --name&#x3D;pd0      - --client-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2379      - --peer-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2380      - --advertise-client-urls&#x3D;http:&#x2F;&#x2F;pd0:2379      - --advertise-peer-urls&#x3D;http:&#x2F;&#x2F;pd0:2380      - --initial-cluster&#x3D;pd0&#x3D;http:&#x2F;&#x2F;pd0:2380,pd1&#x3D;http:&#x2F;&#x2F;pd1:2380,pd2&#x3D;http:&#x2F;&#x2F;pd2:2380      - --data-dir&#x3D;&#x2F;data&#x2F;pd0      - --config&#x3D;&#x2F;pd.toml    restart: on-failure  pd1:    image: pingcap&#x2F;pd:latest    ports:      - &quot;2379&quot;    volumes:      - .&#x2F;config&#x2F;pd.toml:&#x2F;pd.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --name&#x3D;pd1      - --client-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2379      - --peer-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2380      - --advertise-client-urls&#x3D;http:&#x2F;&#x2F;pd1:2379      - --advertise-peer-urls&#x3D;http:&#x2F;&#x2F;pd1:2380      - --initial-cluster&#x3D;pd0&#x3D;http:&#x2F;&#x2F;pd0:2380,pd1&#x3D;http:&#x2F;&#x2F;pd1:2380,pd2&#x3D;http:&#x2F;&#x2F;pd2:2380      - --data-dir&#x3D;&#x2F;data&#x2F;pd1      - --config&#x3D;&#x2F;pd.toml    restart: on-failure  pd2:    image: pingcap&#x2F;pd:latest    ports:      - &quot;2379&quot;    volumes:      - .&#x2F;config&#x2F;pd.toml:&#x2F;pd.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --name&#x3D;pd2      - --client-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2379      - --peer-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2380      - --advertise-client-urls&#x3D;http:&#x2F;&#x2F;pd2:2379      - --advertise-peer-urls&#x3D;http:&#x2F;&#x2F;pd2:2380      - --initial-cluster&#x3D;pd0&#x3D;http:&#x2F;&#x2F;pd0:2380,pd1&#x3D;http:&#x2F;&#x2F;pd1:2380,pd2&#x3D;http:&#x2F;&#x2F;pd2:2380      - --data-dir&#x3D;&#x2F;data&#x2F;pd2      - --config&#x3D;&#x2F;pd.toml    restart: on-failure  tikv0:    image: pingcap&#x2F;tikv:latest    volumes:      - .&#x2F;config&#x2F;tikv.toml:&#x2F;tikv.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --addr&#x3D;0.0.0.0:20160      - --advertise-addr&#x3D;tikv0:20160      - --data-dir&#x3D;&#x2F;data&#x2F;tikv0      - --pd&#x3D;pd0:2379,pd1:2379,pd2:2379      - --config&#x3D;&#x2F;tikv.toml    depends_on:      - &quot;pd0&quot;      - &quot;pd1&quot;      - &quot;pd2&quot;    restart: on-failure  tikv1:    image: pingcap&#x2F;tikv:latest    volumes:      - .&#x2F;config&#x2F;tikv.toml:&#x2F;tikv.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --addr&#x3D;0.0.0.0:20160      - --advertise-addr&#x3D;tikv1:20160      - --data-dir&#x3D;&#x2F;data&#x2F;tikv1      - --pd&#x3D;pd0:2379,pd1:2379,pd2:2379      - --config&#x3D;&#x2F;tikv.toml    depends_on:      - &quot;pd0&quot;      - &quot;pd1&quot;      - &quot;pd2&quot;    restart: on-failure  tikv2:    image: pingcap&#x2F;tikv:latest    volumes:      - .&#x2F;config&#x2F;tikv.toml:&#x2F;tikv.toml:ro      - .&#x2F;data:&#x2F;data    command:      - --addr&#x3D;0.0.0.0:20160      - --advertise-addr&#x3D;tikv2:20160      - --data-dir&#x3D;&#x2F;data&#x2F;tikv2      - --pd&#x3D;pd0:2379,pd1:2379,pd2:2379      - --config&#x3D;&#x2F;tikv.toml    depends_on:      - &quot;pd0&quot;      - &quot;pd1&quot;      - &quot;pd2&quot;    restart: on-failure  tidb:    image: pingcap&#x2F;tidb:latest    ports:      - &quot;4000:4000&quot;      - &quot;10080:10080&quot;    volumes:      - .&#x2F;config&#x2F;tidb.toml:&#x2F;tidb.toml:ro    command:      - --store&#x3D;tikv      - --path&#x3D;pd0:2379,pd1:2379,pd2:2379      - --config&#x3D;&#x2F;tidb.toml    depends_on:      - &quot;tikv0&quot;      - &quot;tikv1&quot;      - &quot;tikv2&quot;    restart: on-failure  tispark-master:    image: pingcap&#x2F;tispark:latest    command:      - &#x2F;opt&#x2F;spark&#x2F;sbin&#x2F;start-master.sh    volumes:      - .&#x2F;config&#x2F;spark-defaults.conf:&#x2F;opt&#x2F;spark&#x2F;conf&#x2F;spark-defaults.conf:ro    environment:      SPARK_MASTER_PORT: 7077      SPARK_MASTER_WEBUI_PORT: 8080    ports:      - &quot;7077:7077&quot;      - &quot;8080:8080&quot;    depends_on:      - &quot;tikv0&quot;      - &quot;tikv1&quot;      - &quot;tikv2&quot;    restart: on-failure  tispark-slave0:    image: pingcap&#x2F;tispark:latest    command:      - &#x2F;opt&#x2F;spark&#x2F;sbin&#x2F;start-slave.sh      - spark:&#x2F;&#x2F;tispark-master:7077    volumes:      - .&#x2F;config&#x2F;spark-defaults.conf:&#x2F;opt&#x2F;spark&#x2F;conf&#x2F;spark-defaults.conf:ro    environment:      SPARK_WORKER_WEBUI_PORT: 38081    ports:      - &quot;38081:38081&quot;    depends_on:      - tispark-master    restart: on-failure  tidb-vision:    image: pingcap&#x2F;tidb-vision:latest    environment:      PD_ENDPOINT: pd0:2379    ports:      - &quot;8010:8010&quot;  # monitors  pushgateway:    image: prom&#x2F;pushgateway:v0.3.1    command:    - --log.level&#x3D;error    restart: on-failure  prometheus:    user: root    image: prom&#x2F;prometheus:v2.2.1    command:      - --log.level&#x3D;error      - --storage.tsdb.path&#x3D;&#x2F;data&#x2F;prometheus      - --config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml    ports:      - &quot;9090:9090&quot;    volumes:      - .&#x2F;config&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml:ro      - .&#x2F;config&#x2F;pd.rules.yml:&#x2F;etc&#x2F;prometheus&#x2F;pd.rules.yml:ro      - .&#x2F;config&#x2F;tikv.rules.yml:&#x2F;etc&#x2F;prometheus&#x2F;tikv.rules.yml:ro      - .&#x2F;config&#x2F;tidb.rules.yml:&#x2F;etc&#x2F;prometheus&#x2F;tidb.rules.yml:ro      - .&#x2F;data:&#x2F;data    restart: on-failure  grafana:    image: grafana&#x2F;grafana:4.6.3    environment:      GF_LOG_LEVEL: error    ports:      - &quot;3000:3000&quot;    restart: on-failure  dashboard-installer:    image: pingcap&#x2F;tidb-dashboard-installer:v2.0.0    command: [&quot;grafana:3000&quot;]    volumes:      - .&#x2F;config&#x2F;grafana-datasource.json:&#x2F;datasource.json:ro      - .&#x2F;config&#x2F;pd-dashboard.json:&#x2F;pd.json:ro      - .&#x2F;config&#x2F;tikv-dashboard.json:&#x2F;tikv.json:ro      - .&#x2F;config&#x2F;tidb-dashboard.json:&#x2F;tidb.json:ro      - .&#x2F;config&#x2F;overview-dashboard.json:&#x2F;overview.json:ro    restart: on-failure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-Compose构建集群"><a href="#Docker-Compose构建集群" class="headerlink" title="Docker Compose构建集群"></a>Docker Compose构建集群</h3><ul><li><p>下载 tidb-docker-compose</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;pingcap&#x2F;tidb-docker-compose.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>拉取镜像</p><pre class="line-numbers language-none"><code class="language-none">cd tidb-docker-compose &amp;&amp; docker-compose pull # Get the latest Docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过docker images可以看到pd，tikv，tidb的镜像已经被拉下来了。</p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/image.jpeg" width="600" hegiht="350"></li><li><p>启动容器</p><pre class="line-numbers language-none"><code class="language-none">docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过docker ps -a可以看到pd，tikv，tidb容器已经启动了，启动了3 个 PD，3 个 TiKV，1 个 TiDB。</p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/container.jpeg" width="600" hegiht="350"></li><li><p>访问集群</p><pre class="line-numbers language-none"><code class="language-none">mysql -h 127.0.0.1 -P 4000 -u root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/mysql.jpeg" width="600" hegiht="350">可以看到tidb已经启动了，我们通过mysql命令已经可以访问集群了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> TIDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Curator leader选举</title>
      <link href="2018/08/24/curatorleader/"/>
      <url>2018/08/24/curatorleader/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一周，一直在做squirrel-ha-service高可用的改进。简单介绍下squirrel-ha-service。squirrel-ha-service(后文都简写为ha)是线上持续监控redis集群，保证redis集群高可用的一个服务。会通过redis cluster nodes命令获取redis集群所有节点的状态，如果某个节点宕机了，ha一旦发现宕机节点，首先会通过修改zk通知redis客户端不再访问该节点，然后自动替换宕机节点。替换完节点后，再次通过修改zk通知redis客户端刷新本地路由，将新添加的节点加入本地路由表。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/arch.jpeg" width="400" hegiht="250">&nbsp;&nbsp;<img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/multiIdc.jpeg" width="400" hegiht="250"><br>上述左图是我们目前线上ha大致架构，基本能保证redis集群的整体可用性。但是最近我们在做机房容灾相关，这个架构就有问题了。</p><p>上述是右图我们线上一个redis集群的部署情况，基本都是3机房部署。图中是dx，yf，gh三个机房，每个机房都有一个主节点一个从节点。redis集群这样部署，能保证最高的可用性。即使线上某个机房发生故障，剩下的两个机房也能继续提供服务。<br>这里我们假设现在gh机房发生网络故障，先忽视图中红色框。gh-master节点原来有一个dx-slave节点，一旦光环机房不可用，dx-slave节点会发起提升自己为master的请求，dx和yf机房的两个主节点投票通过，这样一个新的集群dx(2个master节点)，yf(一个master，一个slave)可以继续对外提供服务。<br>从redis集群角度看，如果机房是三机房主从均匀部署，单个机房发生故障另外两个机房依然能继续提供服务。但是此时我们的squirrel-ha服务因为也处于gh机房(我们线上一个redis集群唯一对应一个ha监控服务)，由于gh机房和另外两个机房dx，yf网络不通，此时ha服务无法刷新zk，通知dx和yf的redis客户端更新路由了。之所以发生这个问题，是因为ha自身没有保证高可用，所以我们考虑引进zk选举来保证ha服务的可用性。如上图红框，当gh机房发生网络故障，之前dx-ha-watcher会替代gh-ha成为新的leader，开始监控redis集群。</p><span id="more"></span><h2 id="Curator选主"><a href="#Curator选主" class="headerlink" title="Curator选主"></a>Curator选主</h2><p>上面我们说了，在发生机房网络分区时候，ha自身不能保证高可用。所以接下来我们会将ha接入zk，通过zk的选举功能保证ha自身的高可用。我们会使用Netflix开源的curator来实现选主，这个框架解决了原生zookeeper client断线重连相关问题，并且提供了2套选主方案。</p><ul><li>LeaderLatch：随机从候选着中选出一台作为leader，选中之后除非调用close()释放leadship，否则其他的后选择无法成为leader。这种策略适合主备应用，当主节点意外宕机之后，多个从节点会自动选举其中一个为新的主节点</li><li>Leader Election：这种选举策略跟Leader Latch选举策略不同之处在于每个实例都能公平获取领导权，而且当获取领导权的实例在释放领导权之后，该实例还有机会再次获取领导权。另外，选举出来的leader不会一直占有领导权，当 takeLeadership(CuratorFramework client) 方法执行结束之后会自动释放领导权。</li></ul><p>具体选择哪种策略，还是要用户根据自己的需求选择。</p><h3 id="LeaderLatch"><a href="#LeaderLatch" class="headerlink" title="LeaderLatch"></a>LeaderLatch</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZKLeaderUtils</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> KEY_LEADER_PATH <span class="token operator">=</span> <span class="token string">"/test"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LeaderLatch</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CuratorFramework</span><span class="token punctuation">></span></span> clients <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">CuratorFramework</span> curatorClient <span class="token operator">=</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">newClient</span><span class="token punctuation">(</span><span class="token string">"localhost:2181"</span><span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">RetryNTimes</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curatorClient<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token class-name">LeaderLatch</span> leaderLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LeaderLatch</span><span class="token punctuation">(</span>curatorClient<span class="token punctuation">,</span>KEY_LEADER_PATH<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leaderLatch<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LeaderLatchListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leaderLatch<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>  <span class="token string">":I am leader. I am doing jobs!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leaderLatch<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>  <span class="token string">":I am not leader. I will do nothing!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leaderLatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaderLatch<span class="token punctuation">)</span><span class="token punctuation">;</span>            clients<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curatorClient<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">LeaderLatch</span> leaderLatch <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            leaderLatch<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            clients<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码，创建了3个LeaderLatch实例，然后sleep 2s，让3个实例进行选主。最后依次调用close方法，释放leader。</p><p>控制台会随机输出:<br>2:I am leader. I am doing jobs!<br>重复执行几次，可以看到不同的client随机获得leader。</p><h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><pre class="line-numbers language-none"><code class="language-none">private static class ExampleClient extends LeaderSelectorListenerAdapter&#123;    private volatile boolean isLeaderRelease &#x3D; false;    private LeaderSelector leaderSelector;    ExampleClient(CuratorFramework client, String path)&#123;        leaderSelector &#x3D; new LeaderSelector(client, path, this);        &#x2F;&#x2F;释放leader后，还可以重新获取leader        leaderSelector.autoRequeue();    &#125;    public void start()&#123;        &#x2F;&#x2F;leader选举会在后台线程进行，该方法会立即返回        leaderSelector.start();    &#125;    &#x2F;**     * 能进入到takeLeadership方法，表示leaderSelector已经成为leader了。只要该方法不退出或者     * 不发生其他异常，就一直持有leader     * @param client     * @throws Exception     *&#x2F;    public void takeLeadership(CuratorFramework client) throws Exception &#123;        while (!isLeaderRelease)&#123;            Thread.sleep(1000);        &#125;    &#125;    public boolean isLeader() &#123;        return leaderSelector.hasLeadership();    &#125;    &#x2F;**     * 设置isLeaderRelease 为false，让takeLeadership方法退出，这样leader就释放了。     * 注意在成功释放leader后，我们又重新设置isLeaderRelease 为true，这样再次获得     * leader后，如果不主动释放或者出现其他异常情况，又可以一直持有leader。     *&#x2F;    public void releaseLeader() &#123;        this.isLeaderRelease &#x3D; true;        while (leaderSelector.hasLeadership())&#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException ignore) &#123;&#125;        &#125;        this.isLeaderRelease &#x3D; false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码ExampleClient主要关注以下四点</p><ul><li>构造方法中leaderSelector.autoRequeue();这个确保了leaderSelector在释放leader后，还可以重新获取leader。</li><li>takeLeaderShip方法，一旦进入这个方法，就表示leaderSelector已经成为leader，从这个方法退出，就释放leader。可以看到这就同LeaderLatch不一样，LeaderLatch只能通过主动close释放leader。</li><li>releaseLeader方法我们通过设置isLeaderRelease为true，让takeLeaderShip能退出循环，达到释放leader目的。</li><li>通过继承了LeaderSelectorListenerAdapter类，一旦出现SUSPENDED或者LOST连接问题，能主动释放leader，这个下面会详细说下。</li></ul><p><b>LeaderSelectorListenerAdapter</b></p><pre class="line-numbers language-none"><code class="language-none">public abstract class LeaderSelectorListenerAdapter implements LeaderSelectorListener&#123;    @Override    public void stateChanged(CuratorFramework client, ConnectionState newState)    &#123;        if ( (newState &#x3D;&#x3D; ConnectionState.SUSPENDED) || (newState &#x3D;&#x3D; ConnectionState.LOST) )        &#123;            throw new CancelLeadershipException();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一旦LeaderSelector启动，它会向curator客户端添加监听器。 使用LeaderSelector必须时刻注意连接的变化。一旦出现连接问题如SUSPENDED，或者LOST，curator实例必须确保其不再是leader并且其takeLeadership()应该直接退出。</p><p>推荐的做法是，如果发生SUSPENDED或者LOST连接问题，最好直接抛CancelLeadershipException，此时，leaderSelector实例会尝试中断并且取消正在执行takeLeadership（）方法的线程。 建议扩展LeaderSelectorListenerAdapter, LeaderSelectorListenerAdapter中已经提供了推荐的处理方式 。</p><p><b>LeaderSelector</b></p><pre class="line-numbers language-none"><code class="language-none">private static class WrappedListener implements LeaderSelectorListener&#123;    private final LeaderSelector leaderSelector;    private final LeaderSelectorListener listener;    public WrappedListener(LeaderSelector leaderSelector, LeaderSelectorListener listener)    &#123;        this.leaderSelector &#x3D; leaderSelector;        this.listener &#x3D; listener;    &#125;    @Override    public void takeLeadership(CuratorFramework client) throws Exception    &#123;        listener.takeLeadership(client);    &#125;    @Override    public void stateChanged(CuratorFramework client, ConnectionState newState)    &#123;        try        &#123;            listener.stateChanged(client, newState);        &#125;        catch ( CancelLeadershipException dummy )        &#123;            leaderSelector.interruptLeadership();        &#125;    &#125;&#125;    &#x2F;** * Attempt to cancel and interrupt the current leadership if this instance has leadership *&#x2F;public synchronized void interruptLeadership()&#123;    Future&lt;?&gt; task &#x3D; ourTask.get();    if ( task !&#x3D; null )    &#123;        task.cancel(true);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到一旦catch到listener.stateChanged抛出的CancelLeadershipException异常，会调用leaderSelector.interruptLeadership()尝试中断，所以我们上面的ExampleClient的takeLeaderShip方法必须要是可以响应中断的</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 能进入到takeLeadership方法，表示leaderSelector已经成为leader了。只要该方法不退出或者 * 不发生其他异常，就一直持有leader * @param client * @throws Exception *&#x2F;public void takeLeadership(CuratorFramework client) throws Exception &#123;    while (!isLeaderRelease)&#123;        Thread.sleep(1000);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法Thread.sleep确实可以响应中断，所以一旦出现SUSPENDED或者LOST连接问题，就会从takeLeaderShip方法退出并释放leader。</p><p>下面我们来测试下上述的ExampleClient</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws InterruptedException &#123;    List&lt;ExampleClient&gt; clients &#x3D; new ArrayList&lt;&gt;();    for(int i&#x3D;0; i&lt;3; i++)&#123;        CuratorFramework client &#x3D; CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;, new ExponentialBackoffRetry(1000, 3));        client.start();        final ExampleClient exampleClient &#x3D; new ExampleClient(client, &quot;&#x2F;test&quot;);        exampleClient.start();        clients.add(exampleClient);        final int index &#x3D; i;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F;外层while(true)循环防止exampleClient还没有获取leader，就直接退出线程了                while (true)&#123;                    &#x2F;&#x2F;内层循环如果成为leader就打印日志                    while (exampleClient.isLeader())&#123;                        System.out.println(&quot;haLeaderService &quot; + index + &quot; is leader&quot;);                        try &#123;                            Thread.sleep(2000);                        &#125; catch (InterruptedException ignore) &#123;&#125;                    &#125;                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException ignore) &#123;&#125;                &#125;            &#125;        &#125;).start();        Thread.sleep(2000);    &#125;    while (true)&#123;        Thread.sleep(7000);        for(ExampleClient exampleClient : clients)&#123;            if(exampleClient.isLeader())&#123;                exampleClient.releaseLeader();                break;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述我们创建了3个ExampleClient，如果成为leader就会打印日志。后续每隔7s，又会主动释放leader，这样其他follower就会成为leader。</p><p>控制台输出如下：</p><pre class="line-numbers language-none"><code class="language-none">haLeaderService 0 is leaderhaLeaderService 0 is leaderhaLeaderService 0 is leaderhaLeaderService 0 is leaderhaLeaderService 1 is leaderhaLeaderService 1 is leaderhaLeaderService 1 is leaderhaLeaderService 1 is leaderhaLeaderService 2 is leaderhaLeaderService 2 is leaderhaLeaderService 2 is leaderhaLeaderService 2 is leaderhaLeaderService 0 is leaderhaLeaderService 0 is leaderhaLeaderService 0 is leader<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到每隔7s，leader确实会切换一次。</p><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201808/zk.jpeg" alt="zk terminal"><br>上图是我们通过zkCli命令连接到zk server获取的信息。我们创建3个ExampleClient，会在/test节点下面分别创建3个临时节点，观察后面的数字0019，0020，0021。<br>其实Leader Election内部通过一个分布式锁来实现选主；并且选主结果是公平的，zk会按照各节点请求的次序成为主节点，当前最小序号的节点成为主节点，其他节点会添加一个对于当前最小节点的监听watcher。一旦发现最小节点不存在，第二小的节点就会成为leader。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curator </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码学习四(Consumer，Provider通信)</title>
      <link href="2018/07/31/dubbo4/"/>
      <url>2018/07/31/dubbo4/</url>
      
        <content type="html"><![CDATA[<p>之前我们介绍了Provider启动时候向注册中心注册服务<br><a href="http://yeming.me/2018/07/28/dubbo2/">Dubbo源码学习二(服务注册)</a>，Consumer启动时候向注册中心订阅服务<a href="http://yeming.me/2018/07/29/dubbo3/">Dubbo源码学习三(服务引用)</a>，本文我们就来看下Consumer端和Provider是怎么通信的。<br><img src="/2018/07/31/dubbo4/communicate.jpeg" width="60%/"></p><span id="more"></span><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DemoService</span> demoService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DemoService</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"demoService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get remote service proxy</span>    <span class="token class-name">String</span> hello <span class="token operator">=</span> demoService<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get result</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Consumer部分主要包含以下逻辑：</p><ul><li>主线程里面寻找合适的invoker经由netty发送request生成future对象。</li><li>netty工作线程对Consumer端request进行编码然后发送</li><li>netty工作线程对Provider端 response进行解码然后提交任务到业务自定义线程池</li><li>业务自定义线程池对response进行相应处理，设置1中的future状态为done状态</li><li>主线程future返回<br>我们主要看下上述1，2，3，4几个过程</li></ul><h3 id="主线程发送request"><a href="#主线程发送request" class="headerlink" title="主线程发送request"></a>主线程发送request</h3><img src="/2018/07/31/dubbo4/consumerSend.jpeg" width="60%/">上图是主线程发送request的时序图，接下来会对从1-7的几个过程逐一分析。<font color="red">过程1</font>在上一篇文章中，我们知道demoService在Consumer端通过JDK动态代理，把Invoker转换成为客户端需要的接口。然后调用sayHello方法时，经由动态代理调用到InvokerInvocationHandler.invoke()方法<p><b>InvokerInvocationHandler</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RpcInvocation</span> invocation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcInvocation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">recreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">过程2</font>主要是调用AbstractClusterInvoker的invoke方法，该方法会根据directory获取缓存的invokers(提供服务的Provider有多少个就有多少个invoker)，然后通过调用子类<br>FailoverClusterInvoker的doInvoke方法，该方法会根据loadBalance选取合适的invoker进行调用，调用失败还会进行重试，默认最多重试3次<br><b>AbstractClusterInvoker</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">&#123;</span>    <span class="token function">checkWhetherDestroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">LoadBalance</span> loadbalance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers <span class="token operator">=</span> <span class="token function">list</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>invokers <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>invokers<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        loadbalance <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">LoadBalance</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span><span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>LOADBALANCE_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_LOADBALANCE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">attachInvocationIdIfAsync</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">,</span> invokers<span class="token punctuation">,</span> loadbalance<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Invoker</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> invokers <span class="token operator">=</span> directory<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> invokers<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">过程3</font>FailoverClusterInvoker.doInvoke<br>==&gt;InvokerWrapper.invoke==&gt;InvokerWrapper.invoke==&gt;ProtocolFilterWrapper</p><p><font color="red">过程4</font>用到了责任链设计模式，这里可以添加自定的filter对调用前后进行拦截，完成一些通用的逻辑。默认情况有ConsumerContextFilter，FutureFilter，MonitoFilter，依次调用其<br>invoke方法</p><p><b>ProtocolFilterWrapper</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">buildInvokerChain</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> invoker<span class="token punctuation">,</span> <span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> last <span class="token operator">=</span> invoker<span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">></span></span> filters <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActivateExtension</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>filters<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">final</span> <span class="token class-name">Filter</span> filter <span class="token operator">=</span> filters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> last<span class="token punctuation">;</span>            last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token class-name">URL</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">isAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RpcException</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> filter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    invoker<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">过程5</font>生成调用的RpcInvocation(其中包含方法名，参数类型，参数值以及一些附加的属性)，并根据需要支持方法异步调用或者callback调用</p><p><b>DubboInvoker</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token class-name">Result</span> <span class="token function">doInvoke</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">RpcInvocation</span> inv <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RpcInvocation</span><span class="token punctuation">)</span> invocation<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">String</span> methodName <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>    inv<span class="token punctuation">.</span><span class="token function">setAttachment</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>PATH_KEY<span class="token punctuation">,</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inv<span class="token punctuation">.</span><span class="token function">setAttachment</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>VERSION_KEY<span class="token punctuation">,</span> version<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExchangeClient</span> currentClient<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clients<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        currentClient <span class="token operator">=</span> clients<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        currentClient <span class="token operator">=</span> clients<span class="token punctuation">[</span>index<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> clients<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">boolean</span> isAsync <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isAsync</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isAsyncFuture <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isGeneratedFuture</span><span class="token punctuation">(</span>inv<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isFutureReturnType</span><span class="token punctuation">(</span>inv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isOneway <span class="token operator">=</span> <span class="token class-name">RpcUtils</span><span class="token punctuation">.</span><span class="token function">isOneway</span><span class="token punctuation">(</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>TIMEOUT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isOneway<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">boolean</span> isSent <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>SENT_KEY<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currentClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> isSent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isAsync<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ResponseFuture</span> future <span class="token operator">=</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// For compatibility</span>            <span class="token class-name">FutureAdapter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> futureAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureAdapter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span>futureAdapter<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Result</span> result<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isAsyncFuture<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// register resultCallback, sometimes we need the asyn result being processed by the filter chain.</span>                result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AsyncRpcResult</span><span class="token punctuation">(</span>futureAdapter<span class="token punctuation">,</span> futureAdapter<span class="token punctuation">.</span><span class="token function">getResultFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleAsyncRpcResult</span><span class="token punctuation">(</span>futureAdapter<span class="token punctuation">,</span> futureAdapter<span class="token punctuation">.</span><span class="token function">getResultFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">RpcContext</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setFuture</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Result</span><span class="token punctuation">)</span> currentClient<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>inv<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token class-name">RpcException</span><span class="token punctuation">.</span>TIMEOUT_EXCEPTION<span class="token punctuation">,</span> <span class="token string">"Invoke remote method timeout. method: "</span> <span class="token operator">+</span> invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", provider: "</span> <span class="token operator">+</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemotingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token class-name">RpcException</span><span class="token punctuation">.</span>NETWORK_EXCEPTION<span class="token punctuation">,</span> <span class="token string">"Failed to invoke remote method: "</span> <span class="token operator">+</span> invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", provider: "</span> <span class="token operator">+</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">过程6</font>channel.writeAndFlush(message)这个channel是NioSocketChannel(<a href="http://yeming.me/2016/04/02/netty2/">netty源码研究二(请求处理)</a>是客户端用来发送消息的)</p><p><b>NettyChannel</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Object</span> message<span class="token punctuation">,</span> <span class="token keyword">boolean</span> sent<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> sent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> timeout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ChannelFuture</span> future <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            timeout <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPositiveParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>TIMEOUT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>            success <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Throwable</span> cause <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> cause<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RemotingException</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"Failed to send message "</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> <span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RemotingException</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"Failed to send message "</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> <span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">+</span> <span class="token string">"in timeout("</span> <span class="token operator">+</span> timeout <span class="token operator">+</span> <span class="token string">"ms) limit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>AbstractChannelHandlerContext</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flush<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AbstractChannelHandlerContext</span> next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">Object</span> m <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            next<span class="token punctuation">.</span><span class="token function">invokeWriteAndFlush</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            next<span class="token punctuation">.</span><span class="token function">invokeWrite</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">AbstractWriteTask</span> task<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            task <span class="token operator">=</span> <span class="token class-name">WriteAndFlushTask</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            task <span class="token operator">=</span> <span class="token class-name">WriteTask</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> task<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述channel.writeAndFlush(message)最终会对调用到AbstractChannelHandlerContext的execute方法，该方法会判断当前线程是否在一个eventLoop里面，如果不在就新开启一个eventLoop线程或者eventLoop线程已经开启就放到队列里面。显然该线程是Consumer调用线程，显然不是eventLoop线程，此时会生成WriteAndFlushTask任务丢到队列里面。</p><p><font color="red">过程7</font>调用DefaultFuture构造函数创建一个future并返回，然后主线程调用阻塞在future.get()方法。</p><p><b>HeaderExchangeChannel</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">ResponseFuture</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token class-name">Object</span> request<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RemotingException</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLocalAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"Failed to send request "</span> <span class="token operator">+</span> request <span class="token operator">+</span> <span class="token string">", cause: The channel "</span> <span class="token operator">+</span> <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" is closed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// create request.</span>    <span class="token class-name">Request</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    req<span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span><span class="token class-name">Version</span><span class="token punctuation">.</span><span class="token function">getProtocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    req<span class="token punctuation">.</span><span class="token function">setTwoWay</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">DefaultFuture</span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFuture</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemotingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> future<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到DefaultFuture类缓存了连个全局的Map，构造函数里面，将请求的id和和对应的future，channel关联起来保存到Map里面，后续接受Provider端的response会用到。</p><p><b>DefaultFuture</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Channel</span><span class="token punctuation">></span></span> CHANNELS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Channel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">DefaultFuture</span><span class="token punctuation">></span></span> FUTURES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">DefaultFuture</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">DefaultFuture</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Request</span> request<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>channel <span class="token operator">=</span> channel<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> timeout <span class="token operator">:</span> channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPositiveParameter</span><span class="token punctuation">(</span><span class="token class-name">Constants</span><span class="token punctuation">.</span>TIMEOUT_KEY<span class="token punctuation">,</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// put into waiting map.</span>    FUTURES<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CHANNELS<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Netty工作线程处理request并发送"><a href="#Netty工作线程处理request并发送" class="headerlink" title="Netty工作线程处理request并发送"></a>Netty工作线程处理request并发送</h3><p>上面一个流程会将request提交给netty EventLoop线程，下面看下eventLoop线程怎么处理的。</p><p><b>NettyClient</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">bootstrap<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NettyCodecAdapter</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyCodecAdapter</span><span class="token punctuation">(</span><span class="token function">getCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">NettyClient</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span>                <span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"decoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"encoder"</span><span class="token punctuation">,</span> adapter<span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler"</span><span class="token punctuation">,</span> nettyClientHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Consumer端Netty启动时候添加了以上3个ChannelHandler，注意以上<br>adapter.getEncoder()是ChannelOutboundHandler，adapter.getDecoder()是ChannelInboundHandler，nettyClientHandler两者都是。这里我们只需要知道接受主线程传过来的req会用到ChannelOutboundHandler，并且依次调用nettyClientHandler，adapter.getEncoder()；接受服务端发过来的response会用到ChannelInboundHandler，并且依次调用<br>adapter.getDecoder()，nettyClientHandler，两者顺序正好相反</p><p>接下来我们就看下netty编码encode过程<br><b>NettyCodecAdapter.InternalEncoder</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">InternalEncoder</span> <span class="token keyword">extends</span> <span class="token class-name">MessageToByteEncoder</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ByteBuf</span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span></span>ChannelBuffer</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyBackedChannelBuffer</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Channel</span> ch <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">NettyChannel</span> channel <span class="token operator">=</span> <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">getOrAddChannel</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> url<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            codec<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">removeChannelIfDisconnected</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>InternalEncoder继承netty自带的MessageToByteEncoder，netty工作线程在对request进行编码过程中，会调用到上述encode方法。上述方法先通过Netty原生Channel拿到dubbo自身封装的NettyChannel，然后调用<br>DubboCountCodec.encode==&gt;ExchangeCodec.encode==&gt;ExchangeCodec.<br>encodeRequest</p><p><b>ExchangeCodec</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encodeRequest</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">ChannelBuffer</span> buffer<span class="token punctuation">,</span> <span class="token class-name">Request</span> req<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Serialization</span> serialization <span class="token operator">=</span> <span class="token function">getSerialization</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// header.</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>HEADER_LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// set magic number.</span>    <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">short2bytes</span><span class="token punctuation">(</span>MAGIC<span class="token punctuation">,</span> header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// set request and serialization flag.</span>    header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>FLAG_REQUEST <span class="token operator">|</span> serialization<span class="token punctuation">.</span><span class="token function">getContentTypeId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isTwoWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|=</span> FLAG_TWOWAY<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|=</span> FLAG_EVENT<span class="token punctuation">;</span>    <span class="token comment">// set request id.</span>    <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">long2bytes</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> header<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// encode request data.</span>    <span class="token keyword">int</span> savedWriteIndex <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span>savedWriteIndex <span class="token operator">+</span> HEADER_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ChannelBufferOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChannelBufferOutputStream</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ObjectOutput</span> out <span class="token operator">=</span> serialization<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">encodeEventData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> out<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">encodeRequestData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> out<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    out<span class="token punctuation">.</span><span class="token function">flushBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token keyword">instanceof</span> <span class="token class-name">Cleanable</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Cleanable</span><span class="token punctuation">)</span> out<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> bos<span class="token punctuation">.</span><span class="token function">writtenBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkPayload</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">int2bytes</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> header<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// write</span>    buffer<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span>savedWriteIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// write header.</span>    buffer<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span>savedWriteIndex <span class="token operator">+</span> HEADER_LENGTH <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//header固定16个字节，每个字节内容如下    </span><span class="token number">2</span>byte magic<span class="token operator">:</span>类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包。魔数是常量<span class="token number">0xdabb</span><span class="token number">1</span>byte 的消息标志位<span class="token operator">:</span><span class="token number">16</span><span class="token operator">-</span><span class="token number">20</span>序列id<span class="token punctuation">,</span><span class="token number">21</span> event<span class="token punctuation">,</span><span class="token number">22</span> two way<span class="token punctuation">,</span><span class="token number">23</span>请求或响应标识<span class="token number">1</span>byte 状态，当消息类型为响应时，设置响应状态。<span class="token number">24</span><span class="token operator">-</span><span class="token number">31</span>位。状态位<span class="token punctuation">,</span> 设置请求响应状态，dubbo定义了一些响应的类型。具体类型见<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>exchange<span class="token punctuation">.</span></span>Response</span><span class="token number">8</span>byte 消息ID<span class="token punctuation">,</span><span class="token keyword">long</span>类型，<span class="token number">32</span><span class="token operator">-</span><span class="token number">95</span>位。每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）<span class="token number">4</span>byte 消息长度，<span class="token number">96</span><span class="token operator">-</span><span class="token number">127</span>位。消息体 body 长度<span class="token punctuation">,</span> <span class="token keyword">int</span> 类型，即记录<span class="token class-name">Body</span> <span class="token class-name">Content</span>有多少个字节。<span class="token punctuation">&#125;</span><span class="token comment">//消息体的内容如下：</span><span class="token number">1</span>、dubbo版本号<span class="token number">2</span>、invoke的路径<span class="token number">3</span>、invoke的provider端暴露的服务的版本号<span class="token number">4</span>、调用的方法名称<span class="token number">5</span>、参数类型描述符<span class="token number">6</span>、遍历请求参数值并编码<span class="token number">7</span>、dubbo请求的attachments<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2018/07/31/dubbo4/dubbo2.jpeg" width="60%/">上述代码是dubbo的编码过程，dubbo通过上述代码自定义通信协议，每条dubbo消息包含header和body(包含方法参数值等信息)，header固定16个字节。buffer先将writeIndex设置为header长度，然后将body req.getData()序列化写进buffer。最后重新设置writeIndex=0，将header写入buffer。<p>最后WriteAndFlushTask类，ctx.invokeFlush() flush刷新buffer就会提交消息到Provider端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">AbstractChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">invokeFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用Netty作为传输框架时，图中的Client和Server分别对应NettyClient和NettyServer，在创建的时候会指定encoder和decoder完成对象的编码和解码。Dubbo协议默认DubboCountCodec为编解码器，该类的成员DubboCodec封装了Dubbo协议的编解码逻辑，同时完成对象的序列化或反序列化。</p><img src="/2018/07/31/dubbo4/transporter.jpeg" width="60%/"><h3 id="Netty工作线程接收response"><a href="#Netty工作线程接收response" class="headerlink" title="Netty工作线程接收response"></a>Netty工作线程接收response</h3><p>上述发送request对应的客户端ChannelOutboundHandler，接收response对应ChannelInboundHandler，Consumer端接收到Provider端的response会依次经由adapter.getDecoder()，nettyClientHandler进行处理。这里有一点比较麻烦，Consumer收到Provider response时通过InternalDecoder进行解码(对应的Provider接收Consumer的request)，InternalDecoder每次收到的数据包不一定是完整的dubbo协议包，也有可能是多个dubbo协议包。这里就是tcp传输所谓的<font color="red">黏包和拆包问题</font>。黏包/拆包问题是由于底层的TCP无法理解上层的业务数据，所以底层是无法保证数据包不被拆分和分组的，只能通过上层的应用协议栈来设计解决。一般有以下几种方案来解决</p><ul><li>消息定长，如果不够，用空格来补</li><li>在包尾增加回车换行符来分割</li><li>将消息分为消息头和消息体，消息头中包含消息体的长度。</li></ul><p>Dubbo采用了第三种方案，我们上面讲过dubbo协议的header是定长的16字节，最后4字节表示消息体长度。</p><p><b>InternalDecoder</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">decode</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">ByteBuf</span> input<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> out<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ChannelBuffer</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyBackedChannelBuffer</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">NettyChannel</span> channel <span class="token operator">=</span> <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">getOrAddChannel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Object</span> msg<span class="token punctuation">;</span>    <span class="token keyword">int</span> saveReaderIndex<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// decode object.</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            saveReaderIndex <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                msg <span class="token operator">=</span> codec<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> <span class="token class-name">Codec2<span class="token punctuation">.</span>DecodeResult</span><span class="token punctuation">.</span>NEED_MORE_INPUT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                message<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span>saveReaderIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//is it possible to go here ?</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>saveReaderIndex <span class="token operator">==</span> message<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Decode without read data."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    out<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">removeChannelIfDisconnected</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>ExchangeCodec</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">decode</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">ChannelBuffer</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> readable<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// check magic number.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readable <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> header<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> MAGIC_HIGH            <span class="token operator">||</span> readable <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> header<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> MAGIC_LOW<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> header<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>header<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> readable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            header <span class="token operator">=</span> <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> readable<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">readBytes</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> length<span class="token punctuation">,</span> readable <span class="token operator">-</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> header<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>header<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> MAGIC_HIGH <span class="token operator">&amp;&amp;</span> header<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> MAGIC_LOW<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                buffer<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> header<span class="token punctuation">.</span>length <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                header <span class="token operator">=</span> <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> readable<span class="token punctuation">,</span> header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// check length.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readable <span class="token operator">&lt;</span> HEADER_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">DecodeResult</span><span class="token punctuation">.</span>NEED_MORE_INPUT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// get data length.</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token class-name">Bytes</span><span class="token punctuation">.</span><span class="token function">bytes2int</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkPayload</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tt <span class="token operator">=</span> len <span class="token operator">+</span> HEADER_LENGTH<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readable <span class="token operator">&lt;</span> tt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">DecodeResult</span><span class="token punctuation">.</span>NEED_MORE_INPUT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// limit input stream.</span>    <span class="token class-name">ChannelBufferInputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChannelBufferInputStream</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">decodeBody</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> is<span class="token punctuation">,</span> header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Skip input stream "</span> <span class="token operator">+</span> is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">StreamUtils</span><span class="token punctuation">.</span><span class="token function">skipUnusedStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法以及后续DubboCountCodec.decode和ExchangeCodec.decode方法大致逻辑如下：</p><ul><li>发送过来的buffer的可读字节数小于header长度或者小于header+消息体body的长度，直接返回NEED_MORE_INPUT，并设置<font color="red">message.readerIndex(saveReaderIndex);</font></li><li>满足上述规则，直接经过反序列化解析出消息体，添加到List<Object> out列表</Object></li></ul><p><b>ByteToMessageDecoder</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CodecOutputList</span> out <span class="token operator">=</span> <span class="token class-name">CodecOutputList</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">ByteBuf</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>            first <span class="token operator">=</span> cumulation <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cumulation <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                cumulation <span class="token operator">=</span> cumulator<span class="token punctuation">.</span><span class="token function">cumulate</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cumulation<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">callDecode</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cumulation<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DecoderException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">DecoderException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cumulation <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>cumulation<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                numReads <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                cumulation<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cumulation <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span> numReads <span class="token operator">>=</span> discardAfterReads<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span>                <span class="token comment">// See https://github.com/netty/netty/issues/4275</span>                numReads <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">discardSomeReadBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            decodeWasNull <span class="token operator">=</span> <span class="token operator">!</span>out<span class="token punctuation">.</span><span class="token function">insertSinceRecycled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fireChannelRead</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> out<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果发生tcp半包问题，回到父类channelRead方法，因为我们之前设置把readIndex复位，cumulation还是可以读的，所以cumulation数据会缓存不会清空，等待下一个dubbo协议包。并且此时int size = out.size()=0，也不会触发后续的fireChannelRead方法。可以看到后续的dubbo包传输过来后，因为first为false，会合并之前缓存的buffer，这样就解决了tcp半包问题。</p><p>对于tcp黏包问题，InternalDecoder本身会while(message.readable())来判断消息是否可读，会持续读取buffer，解析出一个msg就添加到list，如果发生半包问题，就进行上面半包处理逻辑。</p><p>上述消息解码后，会交由NettyClientHandler的channelRead方法来处理<br><b>NettyClientHandler</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">NettyChannel</span> channel <span class="token operator">=</span> <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">getOrAddChannel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        handler<span class="token punctuation">.</span><span class="token function">received</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">NettyChannel</span><span class="token punctuation">.</span><span class="token function">removeChannelIfDisconnected</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终调用到AllChannelHandler.received方法，该方法会创建一个<br>ChannelEventRunnable，然后交由自定义的业务线程池来处理。</p><p><b>AllChannelHandler</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">received</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Object</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ExecutorService</span> cexecutor <span class="token operator">=</span> <span class="token function">getExecutorService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        cexecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelEventRunnable</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token class-name">ChannelState</span><span class="token punctuation">.</span>RECEIVED<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//TODO A temporary solution to the problem that the exception information can not be sent to the opposite end after the thread pool is full. Need a refactoring</span>        <span class="token comment">//fix The thread pool is full, refuses to call, does not return, and causes the consumer to wait for time out</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>message <span class="token keyword">instanceof</span> <span class="token class-name">Request</span> <span class="token operator">&amp;&amp;</span> t <span class="token keyword">instanceof</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Request</span> request <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Request</span><span class="token punctuation">)</span>message<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">isTwoWay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token string">"Server side("</span> <span class="token operator">+</span> url<span class="token punctuation">.</span><span class="token function">getIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> url<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">") threadpool is exhausted ,detail msg:"</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Response</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token class-name">Response</span><span class="token punctuation">.</span>SERVER_THREADPOOL_EXHAUSTED_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setErrorMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> channel<span class="token punctuation">,</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" error when process received event ."</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="业务自定义线程池对response进行相应处理"><a href="#业务自定义线程池对response进行相应处理" class="headerlink" title="业务自定义线程池对response进行相应处理"></a>业务自定义线程池对response进行相应处理</h3><p>经过ChannelEventRunnable.run==&gt;DecodeHandler.received==&gt;HeaderExchangeHandler.received==&gt;HeaderExchangeHandler.handleResponse==&gt;DefaultFuture.received</p><p><b>DefaultFuture</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">received</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Response</span> response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">DefaultFuture</span> future <span class="token operator">=</span> FUTURES<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>future <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            future<span class="token punctuation">.</span><span class="token function">doReceived</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The timeout response finally returned at "</span>                    <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss.SSS"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token operator">+</span> <span class="token string">", response "</span> <span class="token operator">+</span> response                    <span class="token operator">+</span> <span class="token punctuation">(</span>channel <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> <span class="token string">", channel: "</span> <span class="token operator">+</span> channel<span class="token punctuation">.</span><span class="token function">getLocalAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> channel<span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        CHANNELS<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReceived</span><span class="token punctuation">(</span><span class="token class-name">Response</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        response <span class="token operator">=</span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>done <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            done<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">invokeCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们之前在主线程里面缓存了request.getId()对应的future和channel，这里response.getId()获取的是和request对应一样的id，所以能获取到之前缓存的future，并设置response，然后通过done.signal()来通知被阻塞的主线程。(这里针对同步调用过程)最后删除id关联的之前缓存的future和channel。</p><h3 id="调用service主线程返回"><a href="#调用service主线程返回" class="headerlink" title="调用service主线程返回"></a>调用service主线程返回</h3><p>之前调用demoService.sayHello(“world”)的主线程阻塞在DefaultFuture.get方法，之前通过done.signal()会唤醒阻塞在done.await的主线程，并返回服务端结果。</p><p><b>DefaultFuture</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        timeout <span class="token operator">=</span> <span class="token class-name">Constants</span><span class="token punctuation">.</span>DEFAULT_TIMEOUT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">></span> timeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span>sent <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> channel<span class="token punctuation">,</span> <span class="token function">getTimeoutMessage</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">returnFromResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Provider端Netty bossGroup线程接受Consumer端发过来的参数，然后交由netty工作线程来处理，这个过程主要是解码request，同上面Consumer端解码response的过程基本一致。解码完成后，交由工作线程进行后续处理。以下分别对上述两个过程进行分析</p><h3 id="netty工作线程解码"><a href="#netty工作线程解码" class="headerlink" title="netty工作线程解码"></a>netty工作线程解码</h3><p>netty工作线程经由InternalDecoder.decode解码request，然后经由NettyServerHandler.channelRead==&gt;HeartbeatHandler.received==&gt;AllChannelHandler.received，创建一个ChannelEventRunnable到工作线程池，这个过程和上面Consumer解码Provider返回的response几乎一样，这里不过多赘述</p><h3 id="dubbo自定义线程池后续处理"><a href="#dubbo自定义线程池后续处理" class="headerlink" title="dubbo自定义线程池后续处理"></a>dubbo自定义线程池后续处理</h3><p>经由ChannelEventRunnable.run==&gt;DecodeHandler.received==&gt;HeaderExchangeHandler.handleRequest</p><p><b>HeaderExchangeHandler</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ExchangeChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Request</span> req<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">reply</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token class-name">Response</span><span class="token punctuation">.</span>OK<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述handler.reply会调用DubboProtocol.requestHandler.reply方法，该方法根据传过来的Invocation获取到对应的serviceKey，然后从一开始启动过程缓存的Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap exporterMap中获取对应的invoker，这个invoker又会经过ProtocolFilterWrapper中的一系列filter最终调用到DelegateProviderMetaDataInvoker.invoke方法，最终通过反射调用到真正的实现类对应的方法并返回结果。如果是同步调用方法，上面future.isDone返回true，channel.send(res)，最终会对调用到AbstractChannelHandlerContext的write方法，之前说过该方法会判断当前线程是不是在nioEventLoop里面，显然当前线程是dubbo自定义的线程，不在nioEvenloop里面，就会创建一个WriteAndFlushTask任务丢到Evenloop所在的netty工作线程里面</p><h3 id="netty-server工作线程"><a href="#netty-server工作线程" class="headerlink" title="netty server工作线程"></a>netty server工作线程</h3><p>上一个过程把任务提交到netty server工作线程，然后经过NettyServerHandler.write，InternalEncoder.encode编码后，最后flush就将response发送给Consumer。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，dubbo整个通信过程中，涉及到很多不同的线程，大致有以下几种线程，按照调用时序如下</p><ul><li>Consumer端调用service线程</li><li>Netty client worker线程</li><li>Netty server boss线程</li><li>Netty server worker线程</li><li>Provider自定义线程池</li><li>Consumer端自定义线城池</li></ul><p>本身对于异步编程，都没有同步调用看起来那么舒服，dubbo中又有这么多不同的线程进行交互，所以就更容易摸不着头脑了。我们下面再来以上述线程的发生时间先后梳理下整个过程。<br><img src="/2018/07/31/dubbo4/communicate.jpeg" width="60%/"></p><ol><li>Consumer端启动过程中请求与Provider端建立连接，Netty server boss线程接受OP_ACCEPT事件，并生成对应的NioSocketChannel，这个channel后续读写请求交由某个Netty server worker线程处理</li><li>首先Consumer端有个线程调用service某个方法(web应用一般是tomcat线程)，然后提交一个WriteAndFlushTask到Netty client worker线程</li><li>Netty client worker线程对方法传过来的参数进行编码等其他操作然后flush就发送给Provider端</li><li>Netty server worker线程接受Consumer的request，然后进行解码，解码完成后，交由Provider端自定义的业务线程池处理</li><li>Provider端自定义业务线程池接受解码后的参数，然后调用指定服务的真实实现方法，并将结果封装到WriteAndFlushTask到Netty server worker线程。</li><li>Netty server worker线程将provider端服务处理的结果进行编码，然后writeAndFlush发送到Consumer端。</li><li>Consumer端Netty client worker线程对response进行解码，然后提交一个任务到Consumer端自定义的业务线程池。</li><li>Consumer端业务线程池处理相关逻辑，然后通知Consumer端调用service方法的线程(如果是同步方法则唤醒被阻塞的线程)。</li><li>Consumer端调用service的线程获取最终的结果。</li></ol><p>注意上述Consumer端和Provider都有一个业务线程池，这个是不能少的，有些同学可能会觉得把任务直接交给worker线程来做不就行了吗，然而并不能这样。因为worker线程主要是用来做编解码的一些与业务无关的耗时很短的逻辑，对于Provider端来说，服务的真正实现的方法可能会耗时比较长；对于Consumer端来说，可能还要支持某些callBack方法，耗时也可能比较长，所以上述步骤5和8是不能少的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码学习三(服务引用)</title>
      <link href="2018/07/29/dubbo3/"/>
      <url>2018/07/29/dubbo3/</url>
      
        <content type="html"><![CDATA[<p>我们知道Dubbo逻辑上由以下几个模块组成(不考虑Monitor和Container)</p><center><img src="/2018/07/29/dubbo3/dubboArch.jpeg" width="400" hegiht="200"></center><ul><li>Provider：服务提供方</li><li>Consumer：服务消费方</li><li>Registry：服务注册与发现的注册中心</li></ul><p>上一篇文章<a href="/2018/07/28/dubbo2/">Dubbo源码学习二(服务注册)</a>我们分析了服务提供方启动时候怎么向注册中心注册服务，本文我们就来看下Consumer启动时候怎么引用服务的</p><span id="more"></span><h2 id="consumer-demo"><a href="#consumer-demo" class="headerlink" title="consumer demo"></a>consumer demo</h2><pre class="line-numbers language-none"><code class="language-none">&lt;beans xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;       xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.3.xsd       http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;    &lt;!-- consumer&#39;s application name, used for tracing dependency relationship (not a matching criterion),    don&#39;t set it same as provider --&gt;    &lt;dubbo:application name&#x3D;&quot;demo-consumer&quot;&#x2F;&gt;    &lt;!-- use multicast registry center to discover service --&gt;    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;localhost:2181?client&#x3D;curator&quot;&#x2F;&gt;    &lt;!-- generate proxy for the remote service, then demoService can be used in the same way as the    local regular interface --&gt;    &lt;dubbo:reference proxy&#x3D;&quot;jdk&quot; id&#x3D;&quot;demoService&quot; check&#x3D;&quot;false&quot; interface&#x3D;&quot;org.apache.dubbo.demo.DemoService&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class Consumer &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;Prevent to get IPV6 address,this way only work in debug mode        &#x2F;&#x2F;But you can pass use -Djava.net.preferIPv4Stack&#x3D;true,then it work well whether in debug mode or not        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);        ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(new String[]&#123;&quot;META-INF&#x2F;spring&#x2F;dubbo-demo-consumer.xml&quot;&#125;);        context.start();        DemoService demoService &#x3D; (DemoService) context.getBean(&quot;demoService&quot;); &#x2F;&#x2F; get remote service proxy        String hello &#x3D; demoService.sayHello(&quot;world&quot;);         System.out.println(hello); &#x2F;&#x2F; get result    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述xml<a href="dubbo:reference">dubbo:reference</a>同上一篇中的<a href="dubbo:service">dubbo:service</a>一样都是自定义scheme标签。<a href="dubbo:service">dubbo:service</a>声明一个服务并注册到注册中心，<a href="dubbo:reference">dubbo:reference</a>会生成对上述服务的代理。同理，<a href="dubbo:service">dubbo:service</a>会对应到ReferenceBean。</p><h2 id="ReferenceBean"><a href="#ReferenceBean" class="headerlink" title="ReferenceBean"></a>ReferenceBean</h2><p>ReferenceBean</p><pre class="line-numbers language-none"><code class="language-none">public class ReferenceBean&lt;T&gt; extends ReferenceConfig&lt;T&gt; implements FactoryBean, ApplicationContextAware, InitializingBean, DisposableBean &#123;    @Override    public Object getObject() throws Exception &#123;        return get();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReferenceBean实现了FactoryBean接口</p><pre class="line-numbers language-none"><code class="language-none">DemoService demoService &#x3D; (DemoService) context.getBean(&quot;demoService&quot;); &#x2F;&#x2F; get remote service proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在调用上述方法获取DemoService会通过调用getObject方法来获取实例。进而会调用到父类ReferenceConfig的init()方法，init方法又会调用createProxy()方法，这个方法主要完成了以下逻辑</p><ul><li>判断是否本地引用，如果只是本地引用，则通过InjvmExporter生成invoker</li><li>invoker = refprotocol.refer(interfaceClass, urls.get(0));<br>这里urls.get(0).getProtocol()=registry，则会调用到RegistryProtocol的refer方法</li><li>最后通过return (T) proxyFactory.getProxy(invoker);返回invoker的一个代理对象</li></ul><h2 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h2><p>refer方法会调用doRefer()方法</p><p>RegistryProtocol</p><pre class="line-numbers language-none"><code class="language-none">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;    RegistryDirectory&lt;T&gt; directory &#x3D; new RegistryDirectory&lt;T&gt;(type, url);    directory.setRegistry(registry);    directory.setProtocol(protocol);    &#x2F;&#x2F; all attributes of REFER_KEY    Map&lt;String, String&gt; parameters &#x3D; new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());    URL subscribeUrl &#x3D; new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);    if (!Constants.ANY_VALUE.equals(url.getServiceInterface())            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123;        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,                Constants.CHECK_KEY, String.valueOf(false)));    &#125;    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,            Constants.PROVIDERS_CATEGORY                    + &quot;,&quot; + Constants.CONFIGURATORS_CATEGORY                    + &quot;,&quot; + Constants.ROUTERS_CATEGORY));    Invoker invoker &#x3D; cluster.join(directory);    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);    return invoker;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法大体逻辑如下：</p><ul><li>registry.register会向注册中心注册Consumer信息，会向zk<br>/dubbo/org.apache.dubbo.demo.DemoService/consumers目录写入的URL地址</li><li>通过directory.subscribe订阅服务地址列表</li><li>通过cluster.join(directory)生成invoker，其中缓存了RegistryDirectory(包括服务的所有地址，路由协议之类的)</li></ul><h2 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h2><p>RegistryDirectory提供了一个目录服务，缓存了注册中心提供指定服务的URL地址并封装成若干invoker，并缓存了路由协议。同时RegistryDirectory实现了NotifyListener接口，当一个服务的相关信息发生改变后，会通过回调notify方法来修改服务的信息。</p><p>RegistryDirectory</p><pre class="line-numbers language-none"><code class="language-none">public void subscribe(URL url) &#123;    setConsumerUrl(url);    registry.subscribe(url, this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法会调用到父类FailbackRegistry将RegistryDirectory自身添加到listeners，zk service相关信息改变时会回调该listener。进而调用到ZookeeperRegistry的doSubscribe方法，该方法会获取<br>/dubbo/org.apache.dubbo.demo.DemoService/目录下providers，configurators，routers目录的children信息。然后经过一系列调用到RegistryDirectory的refreshInvoker方法</p><pre class="line-numbers language-none"><code class="language-none">private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123;    if (invokerUrls !&#x3D; null &amp;&amp; invokerUrls.size() &#x3D;&#x3D; 1 &amp;&amp; invokerUrls.get(0) !&#x3D; null            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;        this.forbidden &#x3D; true; &#x2F;&#x2F; Forbid to access        this.methodInvokerMap &#x3D; null; &#x2F;&#x2F; Set the method invoker map to null        destroyAllInvokers(); &#x2F;&#x2F; Close all invokers    &#125; else &#123;        this.forbidden &#x3D; false; &#x2F;&#x2F; Allow to access        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference        if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls !&#x3D; null) &#123;            invokerUrls.addAll(this.cachedInvokerUrls);        &#125; else &#123;            this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();            this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;Cached invoker urls, convenient for comparison        &#125;        if (invokerUrls.isEmpty()) &#123;            return;        &#125;        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; toInvokers(invokerUrls);&#x2F;&#x2F; Translate url list to Invoker map        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap &#x3D; toMethodInvokers(newUrlInvokerMap); &#x2F;&#x2F; Change method name to map Invoker Map        &#x2F;&#x2F; state change        &#x2F;&#x2F; If the calculation is wrong, it is not processed.        if (newUrlInvokerMap &#x3D;&#x3D; null || newUrlInvokerMap.size() &#x3D;&#x3D; 0) &#123;            logger.error(new IllegalStateException(&quot;urls to invokers error .invokerUrls.size :&quot; + invokerUrls.size() + &quot;, invoker.size :0. urls :&quot; + invokerUrls.toString()));            return;        &#125;        this.methodInvokerMap &#x3D; multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;        this.urlInvokerMap &#x3D; newUrlInvokerMap;        try &#123;            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); &#x2F;&#x2F; Close the unused Invoker        &#125; catch (Exception e) &#123;            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法大体逻辑如下：</p><ul><li>缓存invokerUrls，invokerUrls是提供某服务的所有机器URL集合</li><li>将该服务对应的所有URL转换成Invoker并缓存到urlInvokerMap里面</li><li>每次都会将新生成的urlInvokerMap和之前的对比，destroy掉没有使用的invoker<br>下面主要分析下上述第二个步骤。</li></ul><p>RegistryDirectory.toInvokers()</p><pre class="line-numbers language-none"><code class="language-none">invoker &#x3D; new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据url.getProtocol=”dubbo”，上述方法又会调用到DubboProtocol的<br>refer方法，注意同之前一样中间还有两个包装类ProtocolListenerWrapper和<font color="red">ProtocolFilterWrapper，这个类我们先看下</font><br>ProtocolFilterWrapper</p><pre class="line-numbers language-none"><code class="language-none">private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;    Invoker&lt;T&gt; last &#x3D; invoker;    List&lt;Filter&gt; filters &#x3D; ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);    if (!filters.isEmpty()) &#123;        for (int i &#x3D; filters.size() - 1; i &gt;&#x3D; 0; i--) &#123;            final Filter filter &#x3D; filters.get(i);            final Invoker&lt;T&gt; next &#x3D; last;            last &#x3D; new Invoker&lt;T&gt;() &#123;                @Override                public Class&lt;T&gt; getInterface() &#123;                    return invoker.getInterface();                &#125;                @Override                public URL getUrl() &#123;                    return invoker.getUrl();                &#125;                @Override                public boolean isAvailable() &#123;                    return invoker.isAvailable();                &#125;                @Override                public Result invoke(Invocation invocation) throws RpcException &#123;                    return filter.invoke(next, invocation);                &#125;                @Override                public void destroy() &#123;                    invoker.destroy();                &#125;                @Override                public String toString() &#123;                    return invoker.toString();                &#125;            &#125;;        &#125;    &#125;    return last;&#125;@Overridepublic &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;        return protocol.refer(type, url);    &#125;    return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述refer方法，因为此时url.getProtocol()=”dubbo”，所以会走到buildInvokerChain()方法，该方法通过ExtensionLoader获取所有对consumer自动激活的扩展Filters(默认情况包括ConsumerContextFilter，FutureFilter和MonitorFilter)，然后通过责任链设计模式包装invoker。下面就来看下该类包装前的invoker是怎么生成的。继续到DubboProtocol的refer方法</p><p>DubboProtocol</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;    optimizeSerialization(url);    &#x2F;&#x2F; create rpc invoker.    DubboInvoker&lt;T&gt; invoker &#x3D; new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);    invokers.add(invoker);    return invoker;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法getClients(url)==&gt;ExchangeClient connect==&gt;<br>HeaderExchanger.connect==&gt;Transporters.connect==&gt;<br>NettyTransporter.connect==&gt;NettyClient.doOpen()</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doOpen() throws Throwable &#123;    final NettyClientHandler nettyClientHandler &#x3D; new NettyClientHandler(getUrl(), this);    bootstrap &#x3D; new Bootstrap();    bootstrap.group(nioEventLoopGroup)            .option(ChannelOption.SO_KEEPALIVE, true)            .option(ChannelOption.TCP_NODELAY, true)            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)            &#x2F;&#x2F;.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())            .channel(NioSocketChannel.class);    if (getTimeout() &lt; 3000) &#123;        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000);    &#125; else &#123;        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout());    &#125;    bootstrap.handler(new ChannelInitializer() &#123;        @Override        protected void initChannel(Channel ch) throws Exception &#123;            NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);            ch.pipeline()&#x2F;&#x2F;.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))&#x2F;&#x2F;for debug                    .addLast(&quot;decoder&quot;, adapter.getDecoder())                    .addLast(&quot;encoder&quot;, adapter.getEncoder())                    .addLast(&quot;handler&quot;, nettyClientHandler);        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到经过上述一系列调用，最终又是通过Netty与提供服务的Provider建立一个长连接(之前Provider也是通过netty监听20880端口从而监听客户端请求)。这里如果同一个服务有多个不同的Provider，就和所有的Provider通过netty建立了连接。这样就完成了从URL到Invoker的转化，并缓存到Map&lt;String, Invoker<T>&gt; urlInvokerMap(key是URL，value是转换成的invoker)。</T></p><h2 id="ReferenceConfig"><a href="#ReferenceConfig" class="headerlink" title="ReferenceConfig"></a>ReferenceConfig</h2><p>回到ReferenceConfig的createProxy()方法</p><pre class="line-numbers language-none"><code class="language-none">private static final ProxyFactory proxyFactory &#x3D; ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();return (T) proxyFactory.getProxy(invoker);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;dubbo:reference proxy&#x3D;&quot;jdk&quot; id&#x3D;&quot;demoService&quot; check&#x3D;&quot;false&quot; interface&#x3D;&quot;org.apache.dubbo.demo.DemoService&quot;&#x2F;&gt;@SPI(&quot;javassist&quot;)public interface ProxyFactory &#123;    &#x2F;**     * create proxy.     *     * @param invoker     * @return proxy     *&#x2F;    @Adaptive(&#123;Constants.PROXY_KEY&#125;)    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;    &#x2F;**     * create proxy.     *     * @param invoker     * @return proxy     *&#x2F;    @Adaptive(&#123;Constants.PROXY_KEY&#125;)    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, boolean generic) throws RpcException;    &#x2F;**     * create invoker.     *     * @param &lt;T&gt;     * @param proxy     * @param type     * @param url     * @return invoker     *&#x2F;    @Adaptive(&#123;Constants.PROXY_KEY&#125;)    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最开始我们在<a href="dubbo:reference">dubbo:reference</a>指定了proxy=”jdk”，中间也会经过若干包装类StubProxyFactoryWrapper(这个类用来实现本地存根的，远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑。此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub [1]，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy，具体可以参考<a href="http://dubbo.apache.org/#!/docs/user/demos/local-stub.md?lang=zh-cn">本地存根</a>)，最终就会调用到JdkProxyFactory.getProxy()方法。</p><p>JdkProxyFactory</p><pre class="line-numbers language-none"><code class="language-none">public class JdkProxyFactory extends AbstractProxyFactory &#123;    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));    &#125;    @Override    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;            @Override            protected Object doInvoke(T proxy, String methodName,                                      Class&lt;?&gt;[] parameterTypes,                                      Object[] arguments) throws Throwable &#123;                Method method &#x3D; proxy.getClass().getMethod(methodName, parameterTypes);                return method.invoke(proxy, arguments);            &#125;        &#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述JdkProxyFactory的getProxy方法显示是通过JDK自带的动态代理来封装引用的服务，本例是org.apache.dubbo.demo.DemoService，方法传入了之前生成的invoker，用来生成InvokerInvocationHandler。</p><p>InvokerInvocationHandler</p><pre class="line-numbers language-none"><code class="language-none">public class InvokerInvocationHandler implements InvocationHandler &#123;    private final Invoker&lt;?&gt; invoker;    public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123;        this.invoker &#x3D; handler;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        String methodName &#x3D; method.getName();        Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();        if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;            return method.invoke(invoker, args);        &#125;        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;            return invoker.toString();        &#125;        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;            return invoker.hashCode();        &#125;        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 1) &#123;            return invoker.equals(args[0]);        &#125;        RpcInvocation invocation;        if (RpcUtils.hasGeneratedFuture(method)) &#123;            Class&lt;?&gt; clazz &#x3D; method.getDeclaringClass();            String syncMethodName &#x3D; methodName.substring(0, methodName.length() - Constants.ASYNC_SUFFIX.length());            Method syncMethod &#x3D; clazz.getMethod(syncMethodName, method.getParameterTypes());            invocation &#x3D; new RpcInvocation(syncMethod, args);            invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, &quot;true&quot;);            invocation.setAttachment(Constants.ASYNC_KEY, &quot;true&quot;);        &#125; else &#123;            invocation &#x3D; new RpcInvocation(method, args);            if (RpcUtils.hasFutureReturnType(method)) &#123;                invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, &quot;true&quot;);                invocation.setAttachment(Constants.ASYNC_KEY, &quot;true&quot;);            &#125;        &#125;        return invoker.invoke(invocation).recreate();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码就可以看到，在客户端真正调用某方法时候<br>demoService.sayHello(“world”);就会通过jdk动态代理调用到上述<br>InvokerInvocationHandler的invoke方法。invoke方法会通过invoker方法来完成后续操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码学习二(服务注册)</title>
      <link href="2018/07/28/dubbo2/"/>
      <url>2018/07/28/dubbo2/</url>
      
        <content type="html"><![CDATA[<p>我们知道Dubbo逻辑上由以下几个模块组成(不考虑Monitor和Container)</p><center><img src="/2018/07/28/dubbo2/dubboArch.jpeg" width="400" hegiht="200"></center><ul><li>Provider：服务提供方</li><li>Consumer：服务消费方</li><li>Registry：服务注册与发现的注册中心</li></ul><p>稍微解释下Provider和Consumer只是Dubbo逻辑上的概念，对于一个业务应用，很有可能作为Provider提供服务，又作为Consumer消费服务。<br>Registry是服务注册中心，业内一般都用zk作为注册中心。服务提供方在启动时候把本机的ip和提供服务的名称注册到注册中心。节点名称是服务名称，节点内容是机器ip。这样如果有多个服务提供者，节点内容就会是机器ip列表。服务消费者在启动时候向注册中心订阅自己需要的服务名称，注册中心返回提供该服务的一些机器ip列表。消费者拿到ip列表根据一定的路由策略选择一台机器进行远程调用。当然服务消费者和提供者都必须与注册中心保持一个长连接，如果服务提供方宕机，注册中心会把该机器从ip列表中摘掉，并通知消费者更新服务ip列表。</p><p>本文我们主要来看下服务提供方是如何将服务注册到注册中心的。</p><span id="more"></span><h2 id="provider-demo"><a href="#provider-demo" class="headerlink" title="provider demo"></a>provider demo</h2><pre class="line-numbers language-none"><code class="language-none">public interface DemoService &#123;    String sayHello(String name);&#125;public class DemoServiceImpl implements DemoService &#123;    @Override    public String sayHello(String name) &#123;        System.out.println(&quot;[&quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()) + &quot;] Hello &quot; + name + &quot;, request from consumer: &quot; + RpcContext.getContext().getRemoteAddress());        return &quot;Hello &quot; + name + &quot;, response from provider: &quot; + RpcContext.getContext().getLocalAddress();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;beans xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;       xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.3.xsd       http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;    &lt;dubbo:application name&#x3D;&quot;demo-provider&quot;&#x2F;&gt;    &lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;localhost:2181?client&#x3D;curator&quot;&#x2F;&gt;    &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;demoService&quot; class&#x3D;&quot;org.apache.dubbo.demo.provider.DemoServiceImpl&quot;&#x2F;&gt;    &lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.demo.DemoService&quot; ref&#x3D;&quot;demoService&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述DemoService是一个我们声明的服务，DemoServiceImpl是其实现，这里我们通过xml配置文件来注册这个服务，当然Dubbo也支持通过注解过着api方法本文不讨论。这个配置使用了spring自定义的schema，声明了applicationName，注册中心是zk，通信协议是dubbo，最重要的是<a href="dubbo:service">dubbo:service</a>这个标签。这里我们必须知道实现自定义schema需要以下几个文件</p><pre class="line-numbers language-none"><code class="language-none">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;    static &#123;        Version.checkDuplicate(DubboNamespaceHandler.class);    &#125;    @Override    public void init() &#123;        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spring.handlers</p><pre class="line-numbers language-none"><code class="language-none">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x3D;org.apache.dubbo.config.spring.schema.DubboNamespaceHandlerhttp\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x3D;org.apache.dubbo.config.spring.schema.DubboNamespaceHandler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>spring.schemas</p><pre class="line-numbers language-none"><code class="language-none">http\:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;dubbo.xsdhttp\:&#x2F;&#x2F;code.alibabatech.com&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&#x3D;META-INF&#x2F;compat&#x2F;dubbo.xsd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>dubbo.xsd(有省略)</p><pre class="line-numbers language-none"><code class="language-none">&lt;xsd:element name&#x3D;&quot;service&quot; type&#x3D;&quot;serviceType&quot;&gt;    &lt;xsd:annotation&gt;        &lt;xsd:documentation&gt;&lt;![CDATA[ Export service config ]]&gt;&lt;&#x2F;xsd:documentation&gt;        &lt;xsd:appinfo&gt;            &lt;tool:annotation&gt;                &lt;tool:exports type&#x3D;&quot;org.apache.dubbo.config.ServiceConfig&quot;&#x2F;&gt;            &lt;&#x2F;tool:annotation&gt;        &lt;&#x2F;xsd:appinfo&gt;    &lt;&#x2F;xsd:annotation&gt;&lt;&#x2F;xsd:element&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里大家有兴趣可以自己去找资料学习自定义schema。注意</p><pre class="line-numbers language-none"><code class="language-none">registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));&lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.demo.DemoService&quot; ref&#x3D;&quot;demoService&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述这个你可以认为把xml的dubbo:service标签定义的bean解析为一个<br>spring ServiceBean，这里多说一句，显然作为provider你可以通过xml配置多个<a href="dubbo:service">dubbo:service</a>服务，这样就会对应生成多个ServiceBean</p><h2 id="ServiceBean"><a href="#ServiceBean" class="headerlink" title="ServiceBean"></a>ServiceBean</h2><pre class="line-numbers language-none"><code class="language-none">public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;    @Override    public void onApplicationEvent(ContextRefreshedEvent event) &#123;        if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;            if (logger.isInfoEnabled()) &#123;                logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());            &#125;            export();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spring容器加载完成后，会回调onApplicationEvent方法，会调用到父类ServiceConfig的export()方法，export方法会调用自身的doExport()方法，这个方法会去判断ref是否泛化调用GenericService，是否定义了本地存根stub方法等。接着doExportUrls()</p><pre class="line-numbers language-none"><code class="language-none">private void doExportUrls() &#123;    List&lt;URL&gt; registryURLs &#x3D; loadRegistries(true);    for (ProtocolConfig protocolConfig : protocols) &#123;        doExportUrlsFor1Protocol(protocolConfig, registryURLs);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个ServiceBean本身可以支持多种通信协议，会分别进行处理。这里我们xml只配置了dubbo协议，就只会处理dubbo协议。接着调用<br>doExportUrlsFor1Protocol方法。这个方法主要做了以下几件事</p><ul><li>判断dubbo:service标签有没有设置子标签dubbo:method，意思是可以针对单个服务的不同方法配置不同的参数，比如超时时间之类的。下面这个ServiceBean的uml类图也可说明dubbo:servcie的配置的控制粒度，从粗粒度的service级别到细粒度的method级别。</li><li>判断该服务是本地服务还是远程服务，dubbo:service标签有个scope属性，可以配置该服务只提供本地服务InjvmProtocol(类似一个普通的spring service)，也可以配置提供远程调用服务，这样就需要注册到注册中心。默认情况下，服务本地和远程都会注册。</li></ul><p>本文只考虑远程服务，本地服务是怎么注册的可以看下InjvmProtocol。</p><pre class="line-numbers language-none"><code class="language-none">Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);registry&#x3D;org.apache.dubbo.registry.integration.RegistryProtocol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的protocol是Protocol$Adaptive类，前一篇讲<a href="/2018/07/25/dubbo1/">ExtensionLoader</a>的时候讲到过，这个可以根据<br>wrapperInvoker.getUrl().getProtocol来真正决定调用哪个Protocol，这里返回的是registry，那么调用的就是RegistryProtocol的export方法。(严格上来说上述过程省略了两个包装类ProtocolListenerWrapper，ProtocolFilterWrapper)</p><h2 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h2><p>RegistryProtocol</p><pre class="line-numbers language-none"><code class="language-none">@Override    public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;    &#x2F;&#x2F;export invoker    final ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; doLocalExport(originInvoker);    URL registryUrl &#x3D; getRegistryUrl(originInvoker);    &#x2F;&#x2F;registry provider    final Registry registry &#x3D; getRegistry(originInvoker);    final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);    &#x2F;&#x2F;to judge to delay publish whether or not    boolean register &#x3D; registedProviderUrl.getParameter(&quot;register&quot;, true);    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);    if (register) &#123;        register(registryUrl, registedProviderUrl);        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);    &#125;    &#x2F;&#x2F; Subscribe the override data    &#x2F;&#x2F; FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.    final URL overrideSubscribeUrl &#x3D; getSubscribedOverrideUrl(registedProviderUrl);    final OverrideListener overrideSubscribeListener &#x3D; new OverrideListener(overrideSubscribeUrl, originInvoker);    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);    &#x2F;&#x2F;Ensure that a new exporter instance is returned every time export    return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法主要包含3个流程</p><ul><li>公开本地服务，配置文件配置的是Dubbo通信协议，实际上会使用Netty4作为通信协议，暴露20880端口并监听，接受客户端传来的各种请求</li><li>向注册中心注册该服务，最终向zk<br>/dubbo/org.apache.dubbo.demo.DemoService/providers 目录下写入URL地址(其中包括机器等信息)</li><li>Subscribe the override data，这个过程貌似会向路径<br>/dubbo/org.apache.dubbo.demo.DemoService/configurators路径写入URL地址</li></ul><p>上述我们主要关注前两个过程。</p><h3 id="doLocalExport-开启本地服务"><a href="#doLocalExport-开启本地服务" class="headerlink" title="doLocalExport(开启本地服务)"></a>doLocalExport(开启本地服务)</h3><pre class="line-numbers language-none"><code class="language-none">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker) &#123;    String key &#x3D; getCacheKey(originInvoker);    ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);    if (exporter &#x3D;&#x3D; null) &#123;        synchronized (bounds) &#123;            exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);            if (exporter &#x3D;&#x3D; null) &#123;                final Invoker&lt;?&gt; invokerDelegete &#x3D; new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));                exporter &#x3D; new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);                bounds.put(key, exporter);            &#125;        &#125;    &#125;    return exporter;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里又是根据invokerDelegete.getUrl.getProtocol获得了dubbo，最终会调用DubboProtocol的export方法。</p><p>DubboProtocol</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;    URL url &#x3D; invoker.getUrl();    &#x2F;&#x2F; export service.    String key &#x3D; serviceKey(url);    DubboExporter&lt;T&gt; exporter &#x3D; new DubboExporter&lt;T&gt;(invoker, key, exporterMap);    exporterMap.put(key, exporter);    &#x2F;&#x2F;export an stub service for dispatching event    Boolean isStubSupportEvent &#x3D; url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);    Boolean isCallbackservice &#x3D; url.getParameter(Constants.IS_CALLBACK_SERVICE, false);    if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;        String stubServiceMethods &#x3D; url.getParameter(Constants.STUB_EVENT_METHODS_KEY);        if (stubServiceMethods &#x3D;&#x3D; null || stubServiceMethods.length() &#x3D;&#x3D; 0) &#123;            if (logger.isWarnEnabled()) &#123;                logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +                        &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));            &#125;        &#125; else &#123;            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);        &#125;    &#125;    openServer(url);    optimizeSerialization(url);    return exporter;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述openServer(url)方法会调用到createServer方法()</p><pre class="line-numbers language-none"><code class="language-none">private ExchangeServer createServer(URL url) &#123;    &#x2F;&#x2F; send readonly event when server closes, it&#39;s enabled by default    url &#x3D; url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());    &#x2F;&#x2F; enable heartbeat by default    url &#x3D; url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));    String str &#x3D; url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))        throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);    url &#x3D; url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);    ExchangeServer server;    try &#123;        server &#x3D; Exchangers.bind(url, requestHandler);    &#125; catch (RemotingException e) &#123;        throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);    &#125;    str &#x3D; url.getParameter(Constants.CLIENT_KEY);    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;        Set&lt;String&gt; supportedTypes &#x3D; ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();        if (!supportedTypes.contains(str)) &#123;            throw new RpcException(&quot;Unsupported client type: &quot; + str);        &#125;    &#125;    return server;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述Exchangers.bind(url, requestHandler);方法经过<br>HeaderExchanger.bind()==&gt;Transporters.bind==&gt;<br>NettyTransporter.bind()等最终到NettyServer.doOpen方法</p><pre class="line-numbers language-none"><code class="language-none">protected void doOpen() throws Throwable &#123;    bootstrap &#x3D; new ServerBootstrap();    bossGroup &#x3D; new NioEventLoopGroup(1, new DefaultThreadFactory(&quot;NettyServerBoss&quot;, true));    workerGroup &#x3D; new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),            new DefaultThreadFactory(&quot;NettyServerWorker&quot;, true));    final NettyServerHandler nettyServerHandler &#x3D; new NettyServerHandler(getUrl(), this);    channels &#x3D; nettyServerHandler.getChannels();    bootstrap.group(bossGroup, workerGroup)            .channel(NioServerSocketChannel.class)            .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)            .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)            .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)            .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;                @Override                protected void initChannel(NioSocketChannel ch) throws Exception &#123;                    NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);                    ch.pipeline()&#x2F;&#x2F;.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))&#x2F;&#x2F;for debug                            .addLast(&quot;decoder&quot;, adapter.getDecoder())                            .addLast(&quot;encoder&quot;, adapter.getEncoder())                            .addLast(&quot;handler&quot;, nettyServerHandler);                &#125;            &#125;);    &#x2F;&#x2F; bind    ChannelFuture channelFuture &#x3D; bootstrap.bind(getBindAddress());    channelFuture.syncUninterruptibly();    channel &#x3D; channelFuture.channel();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述过程我们在<a href="/2016/03/12/netty1/">netty源码研究一(服务端启动)</a>已经讲过，有兴趣可以看下。主要是服务端通过netty暴露20880端口并持续监听，也就是接受客户端发来的各种请求。这样就完成了Provider本地服务的注册。</p><h3 id="registry-provider-向注册中心注册服务"><a href="#registry-provider-向注册中心注册服务" class="headerlink" title="registry provider(向注册中心注册服务)"></a>registry provider(向注册中心注册服务)</h3><p>上面确认服务已经开启后，下面就要向注册中心注册服务了。</p><p>RegistryProtocol</p><pre class="line-numbers language-none"><code class="language-none">public void register(URL registryUrl, URL registedProviderUrl) &#123;    Registry registry &#x3D; registryFactory.getRegistry(registryUrl);    registry.register(registedProviderUrl);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法经过FailbackRegistry.register，最终会调用到ZookeeperRegistry的doRegister(url)方法</p><pre class="line-numbers language-none"><code class="language-none">@Overrideprotected void doRegister(URL url) &#123;    try &#123;        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));    &#125; catch (Throwable e) &#123;        throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法就是向zk /dubbo/org.apache.dubbo.demo.DemoService/providers 路径下写入本机的ip地址，这样就完成了服务注册。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dubbo实现服务注册的代码，各种Protocol$Adaptive，一眼看上去感觉绕来绕去，当然设计成这样也是为了以后更好的去通过插件式的扩展。我们可以先跳出上述代码，其实服务注册大体也就两个过程：</p><ul><li>本地首先要启动服务，这里一般都是通过Netty开启一个端口并监听，这样就可以持续监听客户端发来的请求。</li><li>本地服务启动后，就向注册中心注册该服务，目前业内多用zk作为注册中心。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码学习一(扩展点ExtensionLoader)</title>
      <link href="2018/07/25/dubbo1/"/>
      <url>2018/07/25/dubbo1/</url>
      
        <content type="html"><![CDATA[<p>之前其实已经粗略看过Dubbo的源码，最近一个月在公司连续写了nodejs和go语言的redis cluster客户端之后，稍微有点空余时间就准备找个开源的java项目学习下。正好阿里准备对Dubbo重启开发3.0，就决定重新学习下Dubbo。</p><p>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p>个人认为Dubbo之所以能让这么多人和公司关注，它的一些设计模式确实很值得学习。我们都知道java有七大设计原则，说下开闭原则OCP，对扩展开放，对修改关闭。Dubbo被那么多人和公司使用，可能每个公司都会根据自身的需求对Dubbo做些修改。Dubbo一开始就留了一些扩展点，对于一些常用的模块像注册中心，通信协议，路由等模块都提供了多种不同的实现。如果还不能满足需求的话，用户还可以自行定制。让参与者尽量黑盒扩展，而不是白盒去修改代码。</p><p>Dubbo即然要扩展，扩展点的加载方式，首先要统一，微核心+插件式，是比较能达到 OCP 原则的思路。由一个插件生命周期管理容器，构成微核心，核心不包括任何功能，这样可以确保所有功能都能被替换，并且，框架作者能做到的功能，扩展者也一定要能做到，以保证平等对待第三方，所以，框架自身的功能也要用插件的方式实现，不能有任何硬编码。</p><p>Dubbo参考了JDK标准的SPI机制，参见：java.util.ServiceLoader，开发了一套ExtensionLoader加载机制，所有需要扩展的模块都由ExtensionLoader来动态加载。</p><span id="more"></span><h2 id="SPI-Service-Provider-Interface"><a href="#SPI-Service-Provider-Interface" class="headerlink" title="SPI(Service Provider Interface)"></a>SPI(Service Provider Interface)</h2><h3 id="SPI简介"><a href="#SPI简介" class="headerlink" title="SPI简介"></a>SPI简介</h3><p>SPI的全名为Service Provider Interface。大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。例如标准的jdk JDBC，jdk本身没有实现通信协议，只是定义了一套操作数据库的接口。由不同的数据库生产厂商自己实现JDBC一套标准的接口。在面向对象的设计中，我们一般都是面对接口编程，一个接口可能有多种不同的实现，我们一般不在代码里面硬编码指定具体使用的接口实现。比如我一开始使用mysql，后来使用oracle，那么我就需要修改代码加载oracle的jdbc实现，这就违反了OCP原则。所以我们必须实现一种机制，让程序能自己寻找服务实现的机制，有点类似IOC，将对象的装配的控制权转移到程序之外。</p><h3 id="SPI约定"><a href="#SPI约定" class="headerlink" title="SPI约定"></a>SPI约定</h3><p>当服务的提供者实现了某个接口之后，必须在META-INF/services路径下面创建一个文件名是接口全类名，文件内容是具体实现的全类名。ServiceLoader就会去扫描这个路径下面所有的文件，会加载这个实现类。</p><h3 id="SPI-demo"><a href="#SPI-demo" class="headerlink" title="SPI demo"></a>SPI demo</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//java5以上版本，不需要Class.forName("com.mysql.jdbc.Driver");</span>    <span class="token comment">//Class.forName("com.mysql.jdbc.Driver");</span>    <span class="token class-name">String</span> connectionURL <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/test"</span><span class="token punctuation">;</span>    <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>connectionURL<span class="token punctuation">,</span> <span class="token string">"userName"</span><span class="token punctuation">,</span> <span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述是使用jdbc连接mysql的一个demo，其实从java5版本以后，已经不需要使用Class.forName(“com.mysql.jdbc.Driver”)加载mysql驱动了。我们只要确保classpath引入了mysql-connector-java包，后面的DriverManager.getConnection会根据mysql-connector-java包里面的META-INF/services文件自动加载com.mysql.jdbc.Driver。<br><img src="/2018/07/25/dubbo1/jdkspi.jpeg" alt="jdkspi"></p><h2 id="Dubbo-ExtensionLoader"><a href="#Dubbo-ExtensionLoader" class="headerlink" title="Dubbo ExtensionLoader"></a>Dubbo ExtensionLoader</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。<br>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p><ul><li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li><li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li><li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li></ul><p>上图可以看到dubbo默认约定文件放在META-INF/dubbo/internal下面，文件名还是接口全类名，文件内容稍有不同，不同于SPI，文件内容是key=value的形式。这个key就可以保证只加载指定的实现。</p><h3 id="扩展点自适应AdaptiveExtension-Protocol"><a href="#扩展点自适应AdaptiveExtension-Protocol" class="headerlink" title="扩展点自适应AdaptiveExtension(Protocol)"></a>扩展点自适应AdaptiveExtension(Protocol)</h3><p>我们下面就通过一个例子来学习下ExtensionLoader的内部实现。Dubbo里面对于一些重要的模块包括注册中心，通信协议，路由以及其他很多模块都是通过ExtensionLoader来加载的，这样用户可以根据自身需要选择不同的实现或者扩展某个模块。Dubbo这种设计也符合<font color="green">JAVA设计原则-依赖倒转原则</font>。下面我们以通信协议模块入手</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Protocol</span> protocol <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Dubbo里面的扩展点都是上面那样加载的，获取一个可以自适应的(根据指定配置加载需要的依赖，直到扩展点方法执行时才决定调用是一个扩展点实现)实例，先看下getExtensionLoader(Protocol.class)方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">ExtensionLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Extension type == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>type<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Extension type("</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">") is not interface!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">withExtensionAnnotation</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Extension type("</span> <span class="token operator">+</span> type <span class="token operator">+</span>                <span class="token string">") is not extension, because WITHOUT @"</span> <span class="token operator">+</span> SPI<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" Annotation!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">ExtensionLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> loader <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExtensionLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loader <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ExtensionLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        loader <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ExtensionLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> loader<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法比较简单，先进行一些基本的校验：必须是接口类型，接口里面必须出现SPI注解。然后从<br>EXTENSION_LOADERS(全局缓存一个ConcurrentMap&lt;Class<?>, ExtensionLoader<?>&gt;)，<br>所有已经加载的ExtensionLoader都会缓存到这个map里面)里面获取ExtensionLoader实例，如果没有就new一个然后缓存到EXTENSION_LOADERS。下面看下是怎么new的ExtensionLoader</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>    objectFactory <span class="token operator">=</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token class-name">ExtensionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">ExtensionFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先判断type是不是ExtensionFactory类型，如果本身就是ExtensionFactory则objectFactory设置为null，如果不是ExtensionFactory类型，则通过ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension())实例化objectFactory类型。可以看到又和上面的Protocol一样是通过<font color="green">ExtensionLoader.getExtensionLoader(class).getAdaptiveExtension()</font>来加载的。这里我们主要是分析Protocol的加载，ExtensionFactory和Protocol类似，所以我们直接跳过objectFactory的初始化。接着来看下上面得到了ExtensionLoader<Protocol>实例后，调用getAdaptiveExtension方法。</Protocol></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> instance <span class="token operator">=</span> cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>createAdaptiveInstanceError <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>cachedAdaptiveInstance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                instance <span class="token operator">=</span> cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        instance <span class="token operator">=</span> <span class="token function">createAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        createAdaptiveInstanceError <span class="token operator">=</span> t<span class="token punctuation">;</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"fail to create adaptive instance: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"fail to create adaptive instance: "</span> <span class="token operator">+</span> createAdaptiveInstanceError<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> createAdaptiveInstanceError<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法是获取一个自适应的扩展实例(关于扩展点的一些介绍可以参考这篇文档<a href="http://dubbo.apache.org/#!/docs/dev/SPI.md?lang=zh-cn">扩展点加载</a>)<br>上述代码同样是先从缓存cachedAdaptiveInstance里面获取实例，如果没有就调用createAdaptiveExtension方法创建一个，然后缓存到cachedAdaptiveInstance。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">createAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">injectExtension</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token function">getAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Can not create adaptive extension "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">getExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedAdaptiveClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> cachedAdaptiveClass<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> cachedAdaptiveClass <span class="token operator">=</span> <span class="token function">createAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">getExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> classes <span class="token operator">=</span> cachedClasses<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>classes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>cachedClasses<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            classes <span class="token operator">=</span> cachedClasses<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>classes <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                classes <span class="token operator">=</span> <span class="token function">loadExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cachedClasses<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>classes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> classes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法先getExtensionClasses()，看看有没有已经存在的扩展实现类，有的话取到这些类，把标记了@Adaptive的缓存到cachedAdaptiveClass(比如AdaptiveExtensionFactory就标记了@Adaptive)，把没有标记@Adaptive的扩展实现类缓存到cachedClasses。我们先顺着getExtensionClasses==&gt;loadExtensionClasses方法看下去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">loadExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">SPI</span> defaultAnnotation <span class="token operator">=</span> type<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>SPI<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defaultAnnotation <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> value <span class="token operator">=</span> defaultAnnotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> NAME_SEPARATOR<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>names<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"more than 1 default extension name on extension "</span> <span class="token operator">+</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>names<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> cachedDefaultName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> extensionClasses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_INTERNAL_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_INTERNAL_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> SERVICES_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> SERVICES_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> extensionClasses<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到与JDK SPI不同，Dubbo的SPI机制从META-INF/dubbo/internal/，META-INF/dubbo/，META-INF/services/三个路径读取扩展实现类，由于捐赠给apache基金会的原因一些报的路径修改了，所以代码通过org.apache repalace com.alibaba作了兼容。接着从loadDirectory==&gt;loadResource==&gt;loadClass方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> extensionClasses<span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URL</span> resourceURL<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>type<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Error when load extension class(interface: "</span> <span class="token operator">+</span>                type <span class="token operator">+</span> <span class="token string">", class line: "</span> <span class="token operator">+</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"), class "</span>                <span class="token operator">+</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"is not subtype of interface."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Adaptive</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedAdaptiveClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cachedAdaptiveClass <span class="token operator">=</span> clazz<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cachedAdaptiveClass<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"More than 1 adaptive class found: "</span>                    <span class="token operator">+</span> cachedAdaptiveClass<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> clazz<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isWrapperClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> wrappers <span class="token operator">=</span> cachedWrapperClasses<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wrappers <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cachedWrapperClasses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wrappers <span class="token operator">=</span> cachedWrapperClasses<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        wrappers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        clazz<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            name <span class="token operator">=</span> <span class="token function">findAnnotationName</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No such extension name for the class "</span> <span class="token operator">+</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" in the config "</span> <span class="token operator">+</span> resourceURL<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span> NAME_SEPARATOR<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>names <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> names<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Activate</span> activate <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Activate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>activate <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cachedActivates<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> activate<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> n <span class="token operator">:</span> names<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cachedNames<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    cachedNames<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> extensionClasses<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    extensionClasses<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> clazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Duplicate extension "</span> <span class="token operator">+</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" name "</span> <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token string">" on "</span> <span class="token operator">+</span> c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" and "</span> <span class="token operator">+</span> clazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法逻辑是，判断type是不是扩展class的父类或者父接口，不是则抛出异常；判断扩展class里面是否出现过Adaptive注解，出现则缓存到cachedAdaptiveClass，并且只允许一个扩展class包含Adaptive注解，否则抛出异常；判断是否是WrapperClass，如果有拷贝构造函数，则判定为Wrapper扩展点  类并缓存到cachedWrapperClasses，Protocol有两个包装类。</p><ul><li>filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</li><li>listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</li></ul><p>其他的既没有Adative注解，有没有拷贝构造方法，就是默认的Protocol扩展</p><ul><li>org.apache.dubbo.registry.integration.RegistryProtocol</li><li>org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</li><li>org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</li><li>org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</li><li>org.apache.dubbo.rpc.support.MockProtocol</li></ul><p>可以看到上述5个实现都没有出现过Adaptive注解，也没有拷贝构造函数，这5个会缓存到cachedClasses。所以回到getAdaptiveExtensionClass方法，如果扩展的实现没有@Adaptive标记的，则通过createAdaptiveExtensionClass方法来创建一个AdaptiveClass</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">createAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> code <span class="token operator">=</span> <span class="token function">createAdaptiveExtensionClassCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token function">findClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span></span>Compiler</span> compiler <span class="token operator">=</span> <span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span></span>Compiler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> compiler<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码逻辑是通过拼接代码生成一个AdaptiveClass的code，并默认通过javassist字节码技术动态编译一个AdaptiveClass。下图是上面的动态拼接的code字符串，可以看到生成了一个实现Protocol的Adaptive类，然后根据url里面传进来的参数决定调用对应的实现<br><img src="/2018/07/25/dubbo1/code.jpeg" alt="code"></p><p>AdaptiveClass创建之后，通过injectExtension注入扩展class依赖的相关类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">injectExtension</span><span class="token punctuation">(</span><span class="token class-name">T</span> instance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>objectFactory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> instance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"set"</span><span class="token punctuation">)</span>                        <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span>                        <span class="token operator">&amp;&amp;</span> <span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> pt <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">String</span> property <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span> <span class="token operator">?</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span>                        <span class="token class-name">Object</span> object <span class="token operator">=</span> objectFactory<span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>pt<span class="token punctuation">,</span> property<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"fail to inject via method "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                <span class="token operator">+</span> <span class="token string">" of interface "</span> <span class="token operator">+</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的逻辑是遍历AdaptiveClass的所有方法，看下有没有set方法注入，如果存在setter方法，则通过反射注入依赖的对象。因为通过字节码技术动态生成的Protocol AdaptiveClass没有通过set方法注入的依赖，所以该方法直接返回。</p><p>现在通过Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()就获取了一个可以自适应的Protocol。</p><h3 id="获取扩展点getExtension-Protocol"><a href="#获取扩展点getExtension-Protocol" class="headerlink" title="获取扩展点getExtension(Protocol)"></a>获取扩展点getExtension(Protocol)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Extension name == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getDefaultExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Holder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> holder <span class="token operator">=</span> cachedInstances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>holder <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cachedInstances<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Holder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        holder <span class="token operator">=</span> cachedInstances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Object</span> instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>holder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                instance <span class="token operator">=</span> <span class="token function">createExtension</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法逻辑也是先从缓存中获取指定name的实例，如果不存在就创建一个实例，然后缓存起来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">createExtension</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> clazz <span class="token operator">=</span> <span class="token function">getExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token function">findException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">T</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            instance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">injectExtension</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> wrapperClasses <span class="token operator">=</span> cachedWrapperClasses<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wrapperClasses <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wrapperClasses<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> wrapperClass <span class="token operator">:</span> wrapperClasses<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                instance <span class="token operator">=</span> <span class="token function">injectExtension</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> wrapperClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Extension instance(name: "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", class: "</span> <span class="token operator">+</span>                type <span class="token operator">+</span> <span class="token string">")  could not be instantiated: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码会先从之前缓存的cachedClasses获取指定name(“dubbo”)的Protocol实现org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol，接着调用之前分析过的injectExtension方法注入DubboProtocol的依赖(没有setter方法，不需要注入)。然后获取缓存中的cachedWrapperClasses，通过包装类包装DubboProtocol，最终返回一个new ProtocolListenerWrapper(new ProtocolFilterWrapper(DubboProtocol))的包装类。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> OCP </tag>
            
            <tag> JAVA设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库访问层中间件Zebra</title>
      <link href="2017/11/29/zebra/"/>
      <url>2017/11/29/zebra/</url>
      
        <content type="html"><![CDATA[<p>zebra是一个基于JDBC API协议上开发出的高可用、高性能的数据库访问层解决方案。类似阿里的tddl，zebra是一个smart客户端，提供了诸如动态配置、监控、读写分离、分库分表等功能。下图是zebra的整体架构图</p><h2 id="zebra整体架构"><a href="#zebra整体架构" class="headerlink" title="zebra整体架构"></a>zebra整体架构</h2><img src="/2017/11/29/zebra/zebra.jpeg" width="60%/"><span id="more"></span><ul><li>zookeeper中存储着每一个数据库的路由信息、用户名密码等信息</li><li>zebra客户端启动时会从zookeeper拉取数据库的信息，然后直连数据库。进行读写分离和分库分表。</li><li>MHA组件是一个开源组件，主要负责数据库集群的主库的高可用。一旦发生主库故障，MHA会保证切换到某个从库上并把数据库保证一致性。</li><li>从库监控服务是一个自研的服务，主要负责数据库集群的从库的高可用。一旦发生从库故障，该服务会把该从库自动摘除。</li><li>RDS是一个DBA一站式管理平台，负责数据库的创建、维护、扩容，以及最重要的zebra的配置信息的维护。</li></ul><h2 id="zebra客户端"><a href="#zebra客户端" class="headerlink" title="zebra客户端"></a>zebra客户端</h2><p>zebra中主要包括三个实现了JDBC协议的数据源，分别是：</p><ul><li>ShardDataSource：负责分库分表的连接池，它主要判断SQL的落到哪个分片上，然后把相应的SQL经过处理后发送给GroupDataSource。它负责连接多个数据库集群，因此它会包含若干个GroupDataSource。</li><li>GroupDataSource：负责读写分离的连接池，它主要负责判断SQL的读写操作，然后把相应的SQL发送给SingleDataSource。它负责连接一个数据库集群，因此它会包含若干个SingleDataSource。</li><li>SingleDataSource：负责抽象底层使用的连接池类型（c3p0,druid,tomcat-jdbc等），然后直连每一个数据库实例。在上图中，每一个Master或者Slave，都对应一个SingleDataSource。</li></ul><img src="/2017/11/29/zebra/dataSource.jpeg" width="60%/"><h3 id="客户端源码分析"><a href="#客户端源码分析" class="headerlink" title="客户端源码分析"></a>客户端源码分析</h3><p>客户端源码主要包括两个部分启动阶段的初始化和sql请求的处理</p><ul><li>初始化：主要是应用启动阶段，对上述3个dataSource实例化，初始化相关配置，主要包括初始化上述3个dataSource的关系，建立与物理数据库之间的连接，添加一些配置变更的listener(通过zk监听配置，failover时候重建本地数据源，限流，流量路由)</li><li>sql处理：主要包括sql解析，路由，改写，执行，结果合并几个步骤</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="SingleDataSource初始化"><a href="#SingleDataSource初始化" class="headerlink" title="SingleDataSource初始化"></a>SingleDataSource初始化</h4><img src="/2017/11/29/zebra/singleDataSource.jpeg" width="60%/">上图是一个SingDataSource的xml配置，最开始的jdbcUrl，password，user，driver这个是连接mysql服务端需要的，后面的一些参数就是配置数据库连接池(c3p0,tomcat-jdbc,dbcp,druid)的一些通用的参数配置<pre class="line-numbers language-none"><code class="language-none">public synchronized void init() &#123;    if (!init) &#123;        mergeDataSourceConfig();            this.withDefalutValue &#x3D; false;        if (this.getClass().isAssignableFrom(SingleDataSource.class)) &#123;            if (!this.poolType.equals(Constants.CONNECTION_POOL_TYPE_C3P0)) &#123;                this.withDefalutValue &#x3D; true;            &#125;        &#125;            this.dataSourcePool &#x3D; DataSourcePoolFactory.buildDataSourcePool(this.config);        this.filters &#x3D; FilterManagerFactory.getFilterManager().loadFilters(&quot;cat,mtrace,tablerewrite,sqlrewrite&quot;,                configManagerType);            initDataSourceWithFilters(this.config);            init &#x3D; true;    &#125;&#125;private DataSource initDataSourceWithFilters(final DataSourceConfig value) &#123;    if (filters !&#x3D; null &amp;&amp; filters.size() &gt; 0) &#123;        JdbcFilter chain &#x3D; new DefaultJdbcFilterChain(filters) &#123;            @Override            public DataSource initSingleDataSource(SingleDataSource source, JdbcFilter chain) &#123;                if (index &lt; filters.size()) &#123;                    return filters.get(index++).initSingleDataSource(source, chain);                &#125; else &#123;                    return source.initDataSourceOrigin(value);                &#125;            &#125;        &#125;;        return chain.initSingleDataSource(this, chain);    &#125; else &#123;        return initDataSourceOrigin(value);    &#125;&#125;private DataSource initDataSourceOrigin(DataSourceConfig value) &#123;    DataSource result &#x3D; this.dataSourcePool.build(value, withDefalutValue);        if (!this.lazyInit) &#123;        Connection conn &#x3D; null;        try &#123;            conn &#x3D; result.getConnection();            logger.info(String.format(&quot;dataSource [%s] init pool finish&quot;, value.getId()));        &#125; catch (SQLException e) &#123;            logger.error(String.format(&quot;dataSource [%s] init pool fail&quot;, value.getId()), e);        &#125; finally &#123;            try &#123;                if (conn !&#x3D; null) &#123;                    conn.close();                &#125;            &#125; catch (SQLException e) &#123;                logger.error(String.format(&quot;dataSource [%s] init pool fail&quot;, value.getId()));            &#125;        &#125;    &#125;        return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码init方法中的this.dataSourcePool = DataSourcePoolFactory.buildDataSourcePool(this.config);这里是通过xml中的参数创建一个对应的数据库连接池(c3p0,tomcat-jdbc,dbcp,druid)，然后最后一个initDataSourceOrigin方法，判断是否是lazyInit；如果不是，直接建立一个与mysql服务端的一个长连接。<font color="red">所以SingleDataSource初始化主要是创建一个真实的数据库连接池dataSourcePool，后续从SingleDataSource获取连接其实都是从dataSourcePool获取一个Connection</font></p><h4 id="GroupDataSource初始化"><a href="#GroupDataSource初始化" class="headerlink" title="GroupDataSource初始化"></a>GroupDataSource初始化</h4><p>负责读写分离的连接池，它主要负责判断SQL的读写操作，然后把相应的SQL发送给SingleDataSource。它负责连接一个数据库集群，因此它会包含若干个SingleDataSource</p><img src="/2017/11/29/zebra/groupDataSource.jpeg" width="60%/">上图里面我们要说明下jdbcRef，如果要使用读写分离功能，需要在我们管理平台RDS上申请一组读写数据库，比如DB-1-WRITE,DB-1-REDAD,DB-2-READ，这里DB-1负责所有写请求，DB-1和DB-2共同负责读请求(流量可以配置)。以上2个数据库会关联一个jdbcRef保存在zk上面，所以上述xml里面直接配置了jdbcRef，启动时候从zk获取对应的主从结构。<img src="/2017/11/29/zebra/groupDataSourceInit.jpeg" width="60%/"><font color="red">GroupDataSource初始化从先从zk获取group相关的配置，主要是读写分离，路由负载均衡策略，限流熔断策略，并注册对这些配置的实时监听，然后从zk获取jdbc对应的若干个SingleDataSource并分别初始化</font><h4 id="ShardDataSource初始化"><a href="#ShardDataSource初始化" class="headerlink" title="ShardDataSource初始化"></a>ShardDataSource初始化</h4><p>负责分库分表的连接池，它主要判断SQL的落到哪个分片上，然后把相应的SQL经过处理后发送给GroupDataSource。它负责连接多个数据库集群，因此它会包含若干个GroupDataSource(或者直接多个SingDataSource)</p><img src="/2017/11/29/zebra/shardDataSource.jpeg" width="60%/">上面的配置稍微解释下<ul><li>ruleName：分表分表规则，集中式配置在zk上面</li><li>dataSourcePool：配置若干个GroupDataSource或者SingleDataSource</li><li>routerFactory：本地分表规则，先获取本地分库分表规则，如果没有配置，则从zk上获取ruleName分库分表规则</li></ul><pre class="line-numbers language-none"><code class="language-none">router-local-rule.xml&lt;router-rule&gt;    &lt;table-shard-rule table&#x3D;&quot;Feed&quot; generatedPK&#x3D;&quot;id&quot;&gt;        &lt;shard-dimension dbRule&#x3D;&quot;(#id#.intValue() % 8).intdiv(2)&quot;             dbIndexes&#x3D;&quot;id[0-3]&quot;            tbRule&#x3D;&quot;#id#.intValue() % 2&quot;             tbSuffix&#x3D;&quot;alldb:[0,7]&quot;            isMaster&#x3D;&quot;true&quot;&gt;        &lt;&#x2F;shard-dimension&gt;    &lt;&#x2F;table-shard-rule&gt;&lt;&#x2F;router-rule&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public void init() &#123;    if (StringUtils.isNotBlank(ruleName)) &#123;        if (configService &#x3D;&#x3D; null) &#123;            configService &#x3D; ConfigServiceFactory.getConfigService(configManagerType, ruleName);        &#125;            if (routerFactory &#x3D;&#x3D; null) &#123;            routerFactory &#x3D; new LionRouterBuilder(ruleName, defaultDatasource);        &#125;    &#125; else &#123;        if (dataSourcePool &#x3D;&#x3D; null || dataSourcePool.isEmpty()) &#123;            throw new IllegalArgumentException(&quot;dataSourcePool is required.&quot;);        &#125;            if (routerFactory &#x3D;&#x3D; null) &#123;            throw new IllegalArgumentException(&quot;routerRuleFile must be set.&quot;);        &#125;    &#125;        this.initFilters();    initInternal();&#125;private void initInternal() &#123;    this.router &#x3D; routerFactory.build();        if (dataSourceRepository &#x3D;&#x3D; null) &#123;        dataSourceRepository &#x3D; DataSourceRepository.getInstance();    &#125;        if (dataSourcePool !&#x3D; null) &#123;        dataSourceRepository.init(dataSourcePool);    &#125; else &#123;        this.shardDataSourceCustomConfig.setDsConfigProperties(this.dsConfigProperties);        dataSourceRepository.init(this.router.getRouterRule(), this.shardDataSourceCustomConfig);    &#125;        &#x2F;&#x2F; init thread pool    SQLThreadPoolExecutor.getInstance();        &#x2F;&#x2F; init SQL Parser    SQLParser.init();        if (ruleName !&#x3D; null) &#123;        logger.info(String.format(&quot;ShardDataSource(%s) successfully initialized.&quot;, ruleName));    &#125; else &#123;        logger.info(&quot;ShardDataSource successfully initialized.&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dataSourcePool包含若干个GroupDataSource或者SingleDataSource，先依赖这些DataSource的初始化。<br>routerFactory是本息xml配置的分库分表规则，如果没有配置，则从zk上获取分库分表配置，规则引擎是基于groovy的脚本，可以动态变更。</p><h3 id="sql处理"><a href="#sql处理" class="headerlink" title="sql处理"></a>sql处理</h3><p>sql处理主要包括，从连接池获取连接，创建preparedStatement，然后sql解析，路由，改写，执行，结果合并(路由，改写，结果合并是读写分离和分库分表才有的)</p><h4 id="mybatis-jdbc知识储备"><a href="#mybatis-jdbc知识储备" class="headerlink" title="mybatis,jdbc知识储备"></a>mybatis,jdbc知识储备</h4><pre class="line-numbers language-none"><code class="language-none">@Testpublic void test() throws IOException &#123;    Connection conn &#x3D; null;    Statement stmt &#x3D; null;    ResultSet rs &#x3D; null;    conn &#x3D; ds.getConnection();    stmt &#x3D; conn.createStatement();    rs &#x3D; stmt.executeQuery(&quot;SELECT * From Cluster&quot;);    while (rs.next()) &#123;        System.out.println(rs.getString(2));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是jdbc处理一条sql的，主要包括获取连接，创建preparedStatement，执行</p><pre class="line-numbers language-none"><code class="language-none">SimpleExecutorpublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123;    Statement stmt &#x3D; null;    try &#123;      Configuration configuration &#x3D; ms.getConfiguration();      StatementHandler handler &#x3D; configuration.newStatementHandler(this, ms, parameter, rowBounds, resultHandler, boundSql);      stmt &#x3D; prepareStatement(handler, ms.getStatementLog());      return handler.&lt;E&gt;query(stmt, resultHandler);    &#125; finally &#123;      closeStatement(stmt);    &#125;  &#125;  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123;    Statement stmt;    Connection connection &#x3D; getConnection(statementLog);    stmt &#x3D; handler.prepare(connection);    handler.parameterize(stmt);    return stmt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述是mybatis中的SimpleExecutor类封装好了jdbc的操作。上述的Connection connection = getConnection(statementLog);最终会调用上述初始化的DataSource的getConnection方法。</p><h4 id="sql解析，路由，改写，执行，结果合并"><a href="#sql解析，路由，改写，执行，结果合并" class="headerlink" title="sql解析，路由，改写，执行，结果合并"></a>sql解析，路由，改写，执行，结果合并</h4><img src="/2017/11/29/zebra/sql.jpeg" width="60%/">最终调用ShardPreparedStatement的execute方法<pre class="line-numbers language-none"><code class="language-none">public boolean execute() throws SQLException &#123;    SqlType sqlType &#x3D; getSqlType(sql);        if (sqlType &#x3D;&#x3D; SqlType.SELECT || sqlType &#x3D;&#x3D; SqlType.SELECT_FOR_UPDATE) &#123;        executeQuery();            return true;    &#125; else if (sqlType &#x3D;&#x3D; SqlType.INSERT || sqlType &#x3D;&#x3D; SqlType.UPDATE || sqlType &#x3D;&#x3D; SqlType.DELETE            || sqlType &#x3D;&#x3D; SqlType.REPLACE) &#123;&#x2F;&#x2F; add for replace        executeUpdate();            return false;    &#125; else &#123;        throw new SQLException(&quot;only select, insert, update, delete, replace sql is supported&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到对于查询和更新的流程是不一样的，查询流程要比更新流程复杂，因为查询操作不需要传分表字段值，而更新操作必须要传分表字段值，下面我们来看下查询操作。</p><pre class="line-numbers language-none"><code class="language-none">private ResultSet executeQueryWithFilter() throws SQLException &#123;    ResultSet specRS &#x3D; beforeQuery(sql);    if (specRS !&#x3D; null) &#123;        this.results &#x3D; specRS;        this.updateCount &#x3D; -1;        attachedResultSets.add(specRS);            return this.results;    &#125;        RouterResult routerTarget &#x3D; routingAndCheck(sql, getParams());    rewriteAndMergeParms(routerTarget.getParams());    ShardResultSet rs &#x3D; new ShardResultSet();    rs.setStatement(this);    rs.setRouterTarget(routerTarget);    attachedResultSets.add(rs);    this.results &#x3D; rs;    this.updateCount &#x3D; -1;        MergeContext context &#x3D; routerTarget.getMergeContext();        &#x2F;&#x2F; 有orderby和limit的单个查询用切分成多个的方式进行数据获取    if (context.isOrderBySplitSql()) &#123;        executeOrderyByLimitQuery(rs, sql, routerTarget);    &#125; else &#123;        normalSelectExecute(rs, sql, routerTarget);    &#125;        return this.results;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>sql解析：用的是druid的sql解析</li><li>sql改写：RouterResult routerTarget = routingAndCheck(sql, getParams())这里对客户端的sql(一般是mybatis mapper中的sql)改写，将表名改写为物理上真实的表名，并关联对应表名的数据库</li><li>sql执行：如果改写后的sql对应多条物理db的sql，那么后台创建多个任务提交到线程池并行的去执行，若只有一条sql则直接执行</li><li>结果合并：将上述sql执行的结果根据指定条件合并返回</li></ul><h2 id="zebra高可用"><a href="#zebra高可用" class="headerlink" title="zebra高可用"></a>zebra高可用</h2><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><img src="/2017/11/29/zebra/ha.jpeg" width="60%/">其中MHA负责主库切换，从库监控服务负责从库切换。主库和从库均使用实体IP。<h3 id="主库的高可用"><a href="#主库的高可用" class="headerlink" title="主库的高可用"></a>主库的高可用</h3><p>利用MHA进行master节点的可用性监控，在发生故障，master节点不可用时，MHA进行mysql层的主从切换，切换成功后通知zebra新master节点的IP，由zebra负责应用访问层的切换。切换流程如下：</p><img src="/2017/11/29/zebra/mha.jpeg" width="60%/"> - MHA对MySQL集群进行监控管理 - 当主库发生故障时，MHA通知zebra对主库的写进行关闭，并进行MySQL集群的主从切换（切换期间应用无法写数据） - zebra禁止掉对故障集群的写操作 - MHA切换成功，通知zebra新的写数据IP - zebra用新的写IP替换老IP，开放应用访问。<h3 id="从库的高可用"><a href="#从库的高可用" class="headerlink" title="从库的高可用"></a>从库的高可用</h3><p>由zebra-monitor的监控服务负责，时时监控线上MySQL从库的健康状况，如果出现从库“故障”，将会通知zebra将读流量转移到其他可读节点，实现从库的“故障”转移。</p><h4 id="分配粒度"><a href="#分配粒度" class="headerlink" title="分配粒度"></a>分配粒度</h4><p>根据集群进行分配 同一个集群上的所有实例在一台机器上监控</p><h4 id="负载方式"><a href="#负载方式" class="headerlink" title="负载方式"></a>负载方式</h4><p>根据机房位置进行分配： 北京侧集群由北京侧机器监控，上海侧集群由上海侧机器监控。<br>(同侧集群id%监控机器数)结果为当前机器所需监控的集群，保存在数据库中，如果有新机器上线则对数据库中的数据进行刷新并通知所有活跃机器重新加载监控集群。加载集群的同时加载对应集群上的所有实例，实例信息由单独线程动态更新，刷新频率为10min。</p><h4 id="监控逻辑"><a href="#监控逻辑" class="headerlink" title="监控逻辑"></a>监控逻辑</h4><img src="/2017/11/29/zebra/slaveha.jpeg" width="60%/">监控首先使用'select 1' 测试是否可以连通数据库， 连接没有问题则使用 'show slave status' 获取到'second_behind_master'字段来得到该从库上的延迟，从而做出判断。<p>markdown的场景<br>(1)30s内从库连续ping不通。 (从库宕机)<br>(2)30s内 second_behind_master取到的延迟为null。 (主从同步中断)<br>(3)延迟超过阈值。（可根据每个库的敏感程度进行个性化配置，需要进行另外配置）<br>markup的场景<br>30s内能够连续ping通并且主从延迟为0.</p><h4 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h4><p>从库被markdown之后，zebra客户端会收到zk的通知进行动态刷新，重建本地数据源配置，新的流量会导入到正常的从库上。老的数据源会在全部sql执行完成后被close。<br>目前以实例为单位进行配置，即如果一个实例延迟到达阈值，则该实例上所有从库都会被markdown。<br>但是考虑到每个库对延迟的敏感程度不同，我们支持库级的配置，一个实例上的不同库可以有不同的延迟阈值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库访问层DAL </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置中心Lion</title>
      <link href="2017/11/27/lion/"/>
      <url>2017/11/27/lion/</url>
      
        <content type="html"><![CDATA[<p>先说下我自己理解的什么是配置中心。究其本质是我们人类无法掌控和预知一切，映射到软件领域上，我们总是需要对系统的某些功能特性预留出一些控制的线头，以便我们在未来需要的时候，可以人为的拨弄这些线头从而控制系统的行为特征，我把它叫做 “系统运行时(runtime)飞行姿态的动态调整“。具体可以参考阿里中间件团队的这篇文章<a href="http://jm.taobao.org/2016/09/28/an-article-about-config-center/">一篇好TM长的关于配置中心的文章</a>。简明扼要，一个配置中心必须要做到能动态的获取配置参数，并且当配置发生变更了，能及时准确无误的获取最新的配置。阿里用的配置中心叫diamon，我们点评用的是自研的Lion，本篇文章我们来阅读下Lion的源码。</p><h2 id="Lion架构"><a href="#Lion架构" class="headerlink" title="Lion架构"></a>Lion架构</h2><img src="/2017/11/27/lion/lion.jpeg" width="60%/"><img src="/2017/11/27/lion/flow.jpeg" width="60%/"><span id="more"></span><h2 id="获取配置流程"><a href="#获取配置流程" class="headerlink" title="获取配置流程"></a>获取配置流程</h2><p>上面流程图右边部分就是获取配置的流程，流程图上基本说的很清楚了，这里总结下。</p><ul><li>本地缓存:先判断是否允许从本地缓存获取，如果可以，从缓存获取，缓存没有的话就从本地配置文件获取</li><li>本地配置文件:默认文件名applicationContext.properties，没有的话，就从zk获取</li><li>zk:从zk获取，然后更新本地缓存和/data/appdatas/lion/lastWorkingConfig，并注册一个对该zk node的监听watcher。当然如果zk也失败，<br>就从机器/data/appdatas/lion/lastWorkingConfig获取，另外Lion后台会启动一些线程池来异步的同步或者上传数据。</li></ul><h2 id="变更配置流程"><a href="#变更配置流程" class="headerlink" title="变更配置流程"></a>变更配置流程</h2><p>上面流程图左边部分是变更配置的流程。<br>开始在Lion.get(“xxx”)的时候，如果最终是通过获取zk node value，则会注册一个对该node监听的watcher。当该节点的value发生变化时候，会更新该key对应的本地缓存和/data/appdatas/lion/lastWorkingConfig，最终会调用客户端Lion.addConfigListener添加的listener的configChanged方法。</p><h2 id="Lion的高可用相关"><a href="#Lion的高可用相关" class="headerlink" title="Lion的高可用相关"></a>Lion的高可用相关</h2><h3 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h3><p>配置信息显然是很重要的，作为一个分布式配置中心，保存了那么多应用的配置信息，所以数据必须要持久化。我们配置信息不光存在zk上，上面也提到了，每个应用会在自己的/data/appdatas/lion/lastWorkingConfig下面保存应用用到的所有的配置，有多少个key，就有多少个对应的文件名，文件的内容就是key的value。另外后台会开启一个线程池lion-upload-stat-thread:定期把应用使用到的所有配置同步到lion-server端，估计可以作为zk挂了，本地应用磁盘挂了的另外一种备份吧</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>为了提高性能，减少不必要的访问zk，应用会缓存所有使用的key值，当然也不必担心数据不一致的情况。每次zk节点变化通知到客户端，客户端都会更新本地缓存</p><h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><p>配置在发生变更时候，我们需要能及时的获取变更后的配置。目前是依赖zk的push，我们知道zk对网络比较敏感，有可能会发生zk的值变了，但是客户端没有收到通知。Lion客户端也会开启一个线程来定时主动去从zk pull最新的值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix源码分析</title>
      <link href="2017/10/01/hystrix3/"/>
      <url>2017/10/01/hystrix3/</url>
      
        <content type="html"><![CDATA[<p>前两篇文章我们已经讲解了Hystrix的一些基本概念，并举了一些demo说明如何使用Hystrix，这篇文章我们更深一步，通过阅读一些源码来看下Hystrix是怎么工作的。我们主要根据官方文档上的一个流程图，对其中几个主要的过程从源码层面来研究下。</p><span id="more"></span><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/hystrixFlowChart.jpeg" alt="Hystrix full flow chart"></p><h2 id="创建HystrixCommand-HystrixObservableCommand"><a href="#创建HystrixCommand-HystrixObservableCommand" class="headerlink" title="创建HystrixCommand(HystrixObservableCommand)"></a>创建HystrixCommand(HystrixObservableCommand)</h2><pre class="line-numbers language-none"><code class="language-none">public class GetUserAccountCommand extends HystrixCommand&lt;UserAccount&gt; &#123;    private final HttpCookie httpCookie;    private final UserCookie userCookie;    public GetUserAccountCommand(HttpCookie cookie) &#123;        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;User&quot;)));        this.httpCookie &#x3D; cookie;        &#x2F;* parse or throw an IllegalArgumentException *&#x2F;        this.userCookie &#x3D; UserCookie.parseCookie(httpCookie);    &#125;    @Override    protected UserAccount run() &#123;                return new UserAccount(86975, &quot;John James&quot;, 2, true, false, true);    &#125;    @Override    protected String getCacheKey() &#123;        return httpCookie.getValue();    &#125;    @Override    protected UserAccount getFallback() &#123;        return new UserAccount(userCookie.userId, userCookie.name, userCookie.accountType, true, true, true);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们通过继承HystrixCommand实现run，getFallback，getCacheKey等方法实现了一个自己的Command</p><h2 id="Execute-the-Command"><a href="#Execute-the-Command" class="headerlink" title="Execute the Command"></a>Execute the Command</h2><p>执行一个command可以有以下四种方式(前两种是HystrixCommand独有的)：</p><ul><li>execute():阻塞方法，返回一个单个的response(或者异常)</li><li>queue():非阻塞方法，返回一个与单个response关联的future</li><li>observe():返回一个Observable，非延时方法，不管有没有订阅者，都会立即执行命令(不用担心后订阅的订阅者接收不到事件，因为会把事件放到一个RelaySubject里面)</li><li>toObservable():同样是返回一个Observable，延时方法。只有订阅了这个Observable，才会执行命令。</li></ul><pre class="line-numbers language-none"><code class="language-none">UserAccount user &#x3D; new GetUserAccountCommand(new HttpCookie(&quot;mockKey&quot;, &quot;mockValueFromHttpRequest&quot;)).execute();public R execute() &#123;        try &#123;            return queue().get();        &#125; catch (Exception e) &#123;            throw Exceptions.sneakyThrow(decomposeException(e));        &#125;    &#125;    public Future&lt;R&gt; queue() &#123;        &#x2F;*         * The Future returned by Observable.toBlocking().toFuture() does not implement the         * interruption of the execution thread when the &quot;mayInterrupt&quot; flag of Future.cancel(boolean) is set to true;         * thus, to comply with the contract of Future, we must wrap around it.         *&#x2F;        final Future&lt;R&gt; delegate &#x3D; toObservable().toBlocking().toFuture();            final Future&lt;R&gt; f &#x3D; new Future&lt;R&gt;() &#123;                       @Override            public R get() throws InterruptedException, ExecutionException &#123;                return delegate.get();            &#125;            @Override            public R get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123;                return delegate.get(timeout, unit);            &#125;                &#125;;        return f;    &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码，我们通过GetUserAccountCommand.execute来执行命令，debug源码可以看到，execute命令其实也是调用了上面的queue方法返回一个future，然后通过future.get阻塞获取response。继续深入future方法，我们可以先不用管那个代理的future(主要用来实现中断的)，final Future<R> delegate = toObservable().toBlocking().toFuture();可以看到这里其实也是调用了上面提到的toObservable()方法返回一个Observable，然后通过toBlocking().toFuture()返回一个future。</R></p><p><font color="red">事实上，不管是execute，queue最终都会调用toObservable。也就是说同步的HystrixCommand最终都会依赖Observable，尽管HystrixCommand是用来发射单个事件的</font></p><h2 id="Is-the-Response-Cached"><a href="#Is-the-Response-Cached" class="headerlink" title="Is the Response Cached"></a>Is the Response Cached</h2><p><b>AbstractCommand</b></p><pre class="line-numbers language-none"><code class="language-none">return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() &#123;            @Override            public Observable&lt;R&gt; call() &#123;                 &#x2F;* this is a stateful object so can only be used once *&#x2F;                if (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;                    IllegalStateException ex &#x3D; new IllegalStateException(&quot;This instance can only be executed once. Please instantiate a new instance.&quot;);                    &#x2F;&#x2F;TODO make a new error type for this                    throw new HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + &quot; command executed multiple times - this is not permitted.&quot;, ex, null);                &#125;                commandStartTimestamp &#x3D; System.currentTimeMillis();                if (properties.requestLogEnabled().get()) &#123;                    &#x2F;&#x2F; log this command execution regardless of what happened                    if (currentRequestLog !&#x3D; null) &#123;                        currentRequestLog.addExecutedCommand(_cmd);                    &#125;                &#125;                final boolean requestCacheEnabled &#x3D; isRequestCachingEnabled();                final String cacheKey &#x3D; getCacheKey();                &#x2F;* try from cache first *&#x2F;                if (requestCacheEnabled) &#123;                    HystrixCommandResponseFromCache&lt;R&gt; fromCache &#x3D; (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);                    if (fromCache !&#x3D; null) &#123;                        isResponseFromCache &#x3D; true;                        return handleRequestCacheHitAndEmitValues(fromCache, _cmd);                    &#125;                &#125;                Observable&lt;R&gt; hystrixObservable &#x3D;                        Observable.defer(applyHystrixSemantics)                                .map(wrapWithAllOnNextHooks);                Observable&lt;R&gt; afterCache;                &#x2F;&#x2F; put in cache                if (requestCacheEnabled &amp;&amp; cacheKey !&#x3D; null) &#123;                    &#x2F;&#x2F; wrap it for caching                    HystrixCachedObservable&lt;R&gt; toCache &#x3D; HystrixCachedObservable.from(hystrixObservable, _cmd);                    HystrixCommandResponseFromCache&lt;R&gt; fromCache &#x3D; (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);                    if (fromCache !&#x3D; null) &#123;                        &#x2F;&#x2F; another thread beat us so we&#39;ll use the cached value instead                        toCache.unsubscribe();                        isResponseFromCache &#x3D; true;                        return handleRequestCacheHitAndEmitValues(fromCache, _cmd);                    &#125; else &#123;                        &#x2F;&#x2F; we just created an ObservableCommand so we cast and return it                        afterCache &#x3D; toCache.toObservable();                    &#125;                &#125; else &#123;                    afterCache &#x3D; hystrixObservable;                &#125;                return afterCache                        .doOnTerminate(terminateCommandCleanup)     &#x2F;&#x2F; perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))                        .doOnUnsubscribe(unsubscribeCommandCleanup) &#x2F;&#x2F; perform cleanup once                        .doOnCompleted(fireOnCompletedHook);            &#125;        &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中有个判断final boolean requestCacheEnabled = isRequestCachingEnabled();可以看到如果我们的Command实现了getCacheKey方法，并且requestCacheEnabled(这个属性默认是true，可以通过调用HystrixCommand的构造方法传入一个setter对象修改默认属性)这样就不会执行后续的run方法，就会直接返回一个缓存的Observable。(<font color="red">上一篇文章我们已经提到，必须是同一个request context里面的两个command才能用到缓存</font>)</p><pre class="line-numbers language-none"><code class="language-none">protected boolean isRequestCachingEnabled() &#123;        return properties.requestCacheEnabled().get() &amp;&amp; getCacheKey() !&#x3D; null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Is-the-Circuit-Open"><a href="#Is-the-Circuit-Open" class="headerlink" title="Is the Circuit Open?"></a>Is the Circuit Open?</h2><p>可以看到在缓存逻辑过了之后，就会判断断路器(Circuit)的状态是否是open，如果是open状态，就会直接调用fallback方法；如果不是就继续后面的流程，这里断路器要重点说一下，我们在第一篇文章中就说了Hystrix可以解决在我们依赖的外部服务异常造成瀑布式报错，就是通过这个断路器来控制的，所以我们很有必要了解它的工作过程。</p><h3 id="Circuit-Breaker"><a href="#Circuit-Breaker" class="headerlink" title="Circuit Breaker"></a>Circuit Breaker</h3><p>从上面的图我们可以看到在HystrixCommand(HystrixObservableCommand)在执行过程中会与HystrixCircuitBreaker交互，执行之前会根据断路器的状态来决定后续流程，命令执行成功/失败/超时又会向断路器上报数据，断路器根据这些数据来改变状态。下面是断路器的一个流程图</p><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/circuitBreaker.jpeg" alt="断路器"></p><ul><li>如果通过当前断路器请求达到了阈值HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</li><li>如果当前的错误率达到了阈值HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</li><li>那么就会把断路器的状态从CLOSED变成OPEN</li><li>OPEN状态时候，就会断路次断路器上所有的请求(直接返回fallback方法)</li><li>经过一段时间(HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()默认5s)允许一个请求进来，此时断路器状态变为HALF-OPEN，如果这个请求还是失败，那么状态就还是OPEN ，继续等待一个时间；如果此次请求成功，就把状态变更为CLOSED，然后继续循环1的过程。</li></ul><p>下面通过源码，来看一下上述断路器的执行过程。</p><p><b>AbstractCommand</b></p><pre class="line-numbers language-none"><code class="language-none">private Observable&lt;R&gt; applyHystrixSemantics(final AbstractCommand&lt;R&gt; _cmd) &#123;       &#x2F;&#x2F; mark that we&#39;re starting execution on the ExecutionHook       &#x2F;&#x2F; if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent       executionHook.onStart(_cmd);       &#x2F;* determine if we&#39;re allowed to execute *&#x2F;       if (circuitBreaker.attemptExecution()) &#123;           final TryableSemaphore executionSemaphore &#x3D; getExecutionSemaphore();           final AtomicBoolean semaphoreHasBeenReleased &#x3D; new AtomicBoolean(false);           final Action0 singleSemaphoreRelease &#x3D; new Action0() &#123;               @Override               public void call() &#123;                   if (semaphoreHasBeenReleased.compareAndSet(false, true)) &#123;                       executionSemaphore.release();                   &#125;               &#125;           &#125;;           final Action1&lt;Throwable&gt; markExceptionThrown &#x3D; new Action1&lt;Throwable&gt;() &#123;               @Override               public void call(Throwable t) &#123;                   eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);               &#125;           &#125;;           if (executionSemaphore.tryAcquire()) &#123;               try &#123;                   &#x2F;* used to track userThreadExecutionTime *&#x2F;                   executionResult &#x3D; executionResult.setInvocationStartTime(System.currentTimeMillis());                   return executeCommandAndObserve(_cmd)                           .doOnError(markExceptionThrown)                           .doOnTerminate(singleSemaphoreRelease)                           .doOnUnsubscribe(singleSemaphoreRelease);               &#125; catch (RuntimeException e) &#123;                   return Observable.error(e);               &#125;           &#125; else &#123;               return handleSemaphoreRejectionViaFallback();           &#125;       &#125; else &#123;           return handleShortCircuitViaFallback();       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>commad在request cache逻辑之后，run方法之前都会运行circuitBreaker.attemptExecution()，官方注释说明这个方法不是一个幂等方法，会改变内部的状态。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**    * Invoked at start of command execution to attempt an execution.  This is non-idempotent - it may modify internal    * state.    *&#x2F;   boolean attemptExecution();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>HystrixCircuitBreaker</b></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic boolean attemptExecution() &#123;    if (properties.circuitBreakerForceOpen().get()) &#123;        return false;    &#125;    if (properties.circuitBreakerForceClosed().get()) &#123;        return true;    &#125;    if (circuitOpened.get() &#x3D;&#x3D; -1) &#123;        return true;    &#125; else &#123;        if (isAfterSleepWindow()) &#123;            &#x2F;&#x2F;only the first request after sleep window should execute            &#x2F;&#x2F;if the executing command succeeds, the status will transition to CLOSED            &#x2F;&#x2F;if the executing command fails, the status will transition to OPEN            &#x2F;&#x2F;if the executing command gets unsubscribed, the status will transition to OPEN            if (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) &#123;                return true;            &#125; else &#123;                return false;            &#125;        &#125; else &#123;            return false;        &#125;    &#125;&#125;private boolean isAfterSleepWindow() &#123;    final long circuitOpenTime &#x3D; circuitOpened.get();    final long currentTime &#x3D; System.currentTimeMillis();    final long sleepWindowTime &#x3D; properties.circuitBreakerSleepWindowInMilliseconds().get();    return currentTime &gt; circuitOpenTime + sleepWindowTime;&#125; @Overridepublic void markSuccess() &#123;    if (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) &#123;        &#x2F;&#x2F;This thread wins the race to close the circuit - it resets the stream to start it over from 0        metrics.resetStream();        Subscription previousSubscription &#x3D; activeSubscription.get();        if (previousSubscription !&#x3D; null) &#123;            previousSubscription.unsubscribe();        &#125;        Subscription newSubscription &#x3D; subscribeToStream();        activeSubscription.set(newSubscription);        circuitOpened.set(-1L);    &#125;&#125;@Overridepublic void markNonSuccess() &#123;    if (status.compareAndSet(Status.HALF_OPEN, Status.OPEN)) &#123;        &#x2F;&#x2F;This thread wins the race to re-open the circuit - it resets the start time for the sleep window        circuitOpened.set(System.currentTimeMillis());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码，就可以说明一开始我们解释的断路器状态变迁过程。如果状态为OPEN，返回false；CLOSED返回true；经过了sleepWindow时间后，允许一个请求进来，此时断路器状态从OPEN变为HALF_OPEN，这个status是一个原子性的操作。最终这个放进来的请求完成根据成功失败会调用对应的markSuccess或者markNonSuccess，通过一个CAS操作，将HALF_OPEN状态变为CLOSED或者OPEN，如果没有成功，会circuitOpened.set(System.currentTimeMillis())更新此次失败的时间；成功更新circuitOpened.set(-1L)，这样后续请求就都可以进来了。</p><h2 id="Is-the-Thread-Pool-Queue-Semaphore-Full"><a href="#Is-the-Thread-Pool-Queue-Semaphore-Full" class="headerlink" title="Is the Thread Pool/Queue/Semaphore Full?"></a>Is the Thread Pool/Queue/Semaphore Full?</h2><p>之前说过Hystrix通过为每个单独的外部服务创建一个线程池来达到隔离外部服务的目的，这个很明显的一个好处是外部服务挂了，不会影响我们。但是如果依赖过多的服务，会不会造成创建的线程池过多，这是一个问题。Hystix官方有个压测的结果，可以参考下。如果依赖的服务是一些内存级别的很快的操作，那么创建线程池带来的上下文切换的消耗可能会过大，这个时候Hystrix也提供了Semaphore，可以控制同时并发的请求数，直接在当前线程运行。上述不管是线程池还是Semaphore如果满了，就会执行fallback方法。并且我们可以通过设置execution.isolation.strategy动态调整策略</p><p><b>AbstractCommand</b></p><pre class="line-numbers language-none"><code class="language-none">protected TryableSemaphore getExecutionSemaphore() &#123;    if (properties.executionIsolationStrategy().get() &#x3D;&#x3D; ExecutionIsolationStrategy.SEMAPHORE) &#123;        if (executionSemaphoreOverride &#x3D;&#x3D; null) &#123;            TryableSemaphore _s &#x3D; executionSemaphorePerCircuit.get(commandKey.name());            if (_s &#x3D;&#x3D; null) &#123;                &#x2F;&#x2F; we didn&#39;t find one cache so setup                executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), new TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));                &#x2F;&#x2F; assign whatever got set (this or another thread)                return executionSemaphorePerCircuit.get(commandKey.name());            &#125; else &#123;                return _s;            &#125;        &#125; else &#123;            return executionSemaphoreOverride;        &#125;    &#125; else &#123;        &#x2F;&#x2F; return NoOp implementation since we&#39;re not using SEMAPHORE isolation        return TryableSemaphoreNoOp.DEFAULT;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，如果配置的策略是SEMAPHORE，会创建一个许可是properties.executionIsolationSemaphoreMaxConcurrentRequests()的SEMAPHORE，可以看到tryAcquire方法会根据设置的许可直接返回true或者false，不会阻塞。</p><pre class="line-numbers language-none"><code class="language-none">static class TryableSemaphoreActual implements TryableSemaphore &#123;    protected final HystrixProperty&lt;Integer&gt; numberOfPermits;    private final AtomicInteger count &#x3D; new AtomicInteger(0);    public TryableSemaphoreActual(HystrixProperty&lt;Integer&gt; numberOfPermits) &#123;        this.numberOfPermits &#x3D; numberOfPermits;    &#125;    @Override    public boolean tryAcquire() &#123;        int currentCount &#x3D; count.incrementAndGet();        if (currentCount &gt; numberOfPermits.get()) &#123;            count.decrementAndGet();            return false;        &#125; else &#123;            return true;        &#125;    &#125;    @Override    public void release() &#123;        count.decrementAndGet();    &#125;    @Override    public int getNumberOfPermitsUsed() &#123;        return count.get();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果配置的不是SEMAPHORE，则返回TryableSemaphoreNoOp.DEFAULT，这个其实不是Semaphore，因为下面源码可以看到都是返回true。</p><pre class="line-numbers language-none"><code class="language-none">static class TryableSemaphoreNoOp implements TryableSemaphore &#123;    public static final TryableSemaphore DEFAULT &#x3D; new TryableSemaphoreNoOp();    @Override    public boolean tryAcquire() &#123;        return true;    &#125;    @Override    public void release() &#123;    &#125;    @Override    public int getNumberOfPermitsUsed() &#123;        return 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HystrixObservableCommand-construct-or-HystrixCommand-run"><a href="#HystrixObservableCommand-construct-or-HystrixCommand-run" class="headerlink" title="HystrixObservableCommand.construct() or HystrixCommand.run()"></a>HystrixObservableCommand.construct() or HystrixCommand.run()</h2><p><b>AbstractCommand</b></p><pre class="line-numbers language-none"><code class="language-none">private Observable&lt;R&gt; executeCommandWithSpecifiedIsolation(final AbstractCommand&lt;R&gt; _cmd) &#123;    if (properties.executionIsolationStrategy().get() &#x3D;&#x3D; ExecutionIsolationStrategy.THREAD) &#123;        &#x2F;&#x2F; mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)        return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() &#123;            @Override            public Observable&lt;R&gt; call() &#123;                executionResult &#x3D; executionResult.setExecutionOccurred();                if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;                    return Observable.error(new IllegalStateException(&quot;execution attempted while in state : &quot; + commandState.get().name()));                &#125;                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);                if (isCommandTimedOut.get() &#x3D;&#x3D; TimedOutStatus.TIMED_OUT) &#123;                    &#x2F;&#x2F; the command timed out in the wrapping thread so we will return immediately                    &#x2F;&#x2F; and not increment any of the counters below or other such logic                    return Observable.error(new RuntimeException(&quot;timed out before executing run()&quot;));                &#125;                if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;                    &#x2F;&#x2F;we have not been unsubscribed, so should proceed                    HystrixCounters.incrementGlobalConcurrentThreads();                    threadPool.markThreadExecution();                    &#x2F;&#x2F; store the command that is being run                    endCurrentThreadExecutingCommand &#x3D; Hystrix.startCurrentThreadExecutingCommand(getCommandKey());                    executionResult &#x3D; executionResult.setExecutedInThread();                    &#x2F;**                     * If any of these hooks throw an exception, then it appears as if the actual execution threw an error                     *&#x2F;                    try &#123;                        executionHook.onThreadStart(_cmd);                        executionHook.onRunStart(_cmd);                        executionHook.onExecutionStart(_cmd);                        return getUserExecutionObservable(_cmd);                    &#125; catch (Throwable ex) &#123;                        return Observable.error(ex);                    &#125;                &#125; else &#123;                    &#x2F;&#x2F;command has already been unsubscribed, so return immediately                    return Observable.empty();                &#125;            &#125;        &#125;).doOnTerminate(new Action0() &#123;            @Override            public void call() &#123;                if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;                    handleThreadEnd(_cmd);                &#125;                if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;                    &#x2F;&#x2F;if it was never started and received terminal, then no need to clean up (I don&#39;t think this is possible)                &#125;                &#x2F;&#x2F;if it was unsubscribed, then other cleanup handled it            &#125;        &#125;).doOnUnsubscribe(new Action0() &#123;            @Override            public void call() &#123;                if (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;                    handleThreadEnd(_cmd);                &#125;                if (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;                    &#x2F;&#x2F;if it was never started and was cancelled, then no need to clean up                &#125;                &#x2F;&#x2F;if it was terminal, then other cleanup handled it            &#125;        &#125;).subscribeOn(threadPool.getScheduler(new Func0&lt;Boolean&gt;() &#123;            @Override            public Boolean call() &#123;                return properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() &#x3D;&#x3D; TimedOutStatus.TIMED_OUT;            &#125;        &#125;));    &#125; else &#123;        return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() &#123;            @Override            public Observable&lt;R&gt; call() &#123;                executionResult &#x3D; executionResult.setExecutionOccurred();                if (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;                    return Observable.error(new IllegalStateException(&quot;execution attempted while in state : &quot; + commandState.get().name()));                &#125;                metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);                &#x2F;&#x2F; semaphore isolated                &#x2F;&#x2F; store the command that is being run                endCurrentThreadExecutingCommand &#x3D; Hystrix.startCurrentThreadExecutingCommand(getCommandKey());                try &#123;                    executionHook.onRunStart(_cmd);                    executionHook.onExecutionStart(_cmd);                    return getUserExecutionObservable(_cmd);  &#x2F;&#x2F;the getUserExecutionObservable method already wraps sync exceptions, so this shouldn&#39;t throw                &#125; catch (Throwable ex) &#123;                    &#x2F;&#x2F;If the above hooks throw, then use that as the result of the run method                    return Observable.error(ex);                &#125;            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码可以看到首先判断是不是ExecutionIsolationStrategy.THREAD模式，如果不是，说明是Semaphore模式，就走到最后面的逻辑，直接调用getUserExecutionObservable；如果是THREAD模式，可以看到最终会对返回的Observable.subscribeOn(Func0<Boolean> shouldInterruptThread)，这也就是对于外部服务的隔离，让最终产生事件的方法(run或者construct方法)发生在一个单独的线程池里面。</Boolean></p><p>继续来看getUserExecutionObservable方法</p><pre class="line-numbers language-none"><code class="language-none">private Observable&lt;R&gt; getUserExecutionObservable(final AbstractCommand&lt;R&gt; _cmd) &#123;    Observable&lt;R&gt; userObservable;    try &#123;        userObservable &#x3D; getExecutionObservable();    &#125; catch (Throwable ex) &#123;        &#x2F;&#x2F; the run() method is a user provided implementation so can throw instead of using Observable.onError        &#x2F;&#x2F; so we catch it here and turn it into Observable.error        userObservable &#x3D; Observable.error(ex);    &#125;    return userObservable            .lift(new ExecutionHookApplication(_cmd))            .lift(new DeprecatedOnRunHookApplication(_cmd));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法会调用到getExecutionObservable()方法，这里会根据你是实现的HystrixCommand还是HystrixObservableCommand调用对应的方法。</p><p><b>HystrixCommand</b></p><pre class="line-numbers language-none"><code class="language-none"> @Overridefinal protected Observable&lt;R&gt; getExecutionObservable() &#123;    return Observable.defer(new Func0&lt;Observable&lt;R&gt;&gt;() &#123;        @Override        public Observable&lt;R&gt; call() &#123;            try &#123;                return Observable.just(run());            &#125; catch (Throwable ex) &#123;                return Observable.error(ex);            &#125;        &#125;    &#125;).doOnSubscribe(new Action0() &#123;        @Override        public void call() &#123;            &#x2F;&#x2F; Save thread on which we get subscribed so that we can interrupt it later if needed            executionThread.set(Thread.currentThread());        &#125;    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且这里通过doOnSubscribe方法设置了回调保存了当前执行订阅的线程以便后续需要的时候可以interrupt。</p><p><b>HystrixObservableCommand</b></p><pre class="line-numbers language-none"><code class="language-none">@Overridefinal protected Observable&lt;R&gt; getExecutionObservable() &#123;    return construct();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到通过调用getExecutionObservable最终都会调用到你实现的run方法或者construct方法</p><h2 id="Calculate-Circuit-Health"><a href="#Calculate-Circuit-Health" class="headerlink" title="Calculate Circuit Health"></a>Calculate Circuit Health</h2><p>从整个Hystrix flow chart看到步骤5和6的执行结果不管成功与否都会上报Metrics，然后断路器通过这些上报的数据来计算当前的状态，上面Is the Circuit Open?里面已经说过。</p><h2 id="Get-the-Fallback"><a href="#Get-the-Fallback" class="headerlink" title="Get the Fallback"></a>Get the Fallback</h2><p>从整个Hystrix flow chart看到步骤4断路器状态OPEN，步骤5Semphore或者Threadpool reject，步骤6执行失败或者超时都会执行fallback方法，这里就不详细看源码了。</p><h2 id="Return-the-Successful-Response"><a href="#Return-the-Successful-Response" class="headerlink" title="Return the Successful Response"></a>Return the Successful Response</h2><p>如果整个流程执行成功，那么就会返回调用者一个Observable，你可以通过同步方式获取结果也可以subscribe这个Observable通过异步方式获取最终结果，整个获取Observable的流程如下:</p><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/response.jpeg" alt="获取Observable"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix使用</title>
      <link href="2017/09/30/hystrix2/"/>
      <url>2017/09/30/hystrix2/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章主要讲了Hystrix是什么，用来做什么，解决了什么问题，以及设计模式等，这篇文章主要来讲下Hystrix如何使用。下面我们从最简单的Hello World入手，来讲解下Hystrix的用法。</p><span id="more"></span><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>我们可以继承HystrixCommand(HystrixObservableCommand)来完成一个最简单的Hello World，分别说明。</p><h3 id="HystrixCommand"><a href="#HystrixCommand" class="headerlink" title="HystrixCommand"></a>HystrixCommand</h3><p>HystrixCommand提供了同步和异步两种执行模式。</p><p><b>同步模式</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandHelloWorld</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// a real example would do work like a network call here</span>        <span class="token keyword">return</span> <span class="token string">"Hello "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Bob!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>异步模式</b></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAsynchronous1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Bob!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAsynchronous2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> fWorld <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> fBob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">,</span> fWorld<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Bob!"</span><span class="token punctuation">,</span> fBob<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述通过执行HystrixCommand.execute()实现了Synchronous Execution，通过HystrixCommand.queue()返回一个future实现Asynchronous Execution，下面两种写法是等价的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="HystrixObservableCommand"><a href="#HystrixObservableCommand" class="headerlink" title="HystrixObservableCommand"></a>HystrixObservableCommand</h3><pre class="line-numbers language-none"><code class="language-none">This command should be used for a purely non-blocking call pattern. The caller of this command will be subscribed to the Observable&lt;R&gt; returned by the run() method.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照官方注释，这个命令应该只用在非阻塞模式下面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandHelloWorld</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixObservableCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Observable<span class="token punctuation">.</span>OnSubscribe</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">Subscriber</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> observer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>observer<span class="token punctuation">.</span><span class="token function">isUnsubscribed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// a real example would do work like a network call here</span>                        observer<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        observer<span class="token punctuation">.</span><span class="token function">onNext</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        observer<span class="token punctuation">.</span><span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    observer<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span><span class="token class-name">Schedulers</span><span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同于HystrixCommand我们要实现run方法，继承HystrixObservableCommand需要实现construct方法，这个方法返回一个Observable，当我们调用observe()或者toObservable()方法，上述construct方法会被执行。(<font color="red">注意toObservable()是一个延迟命令，真正只有在上述Observable被subscribe时候，construct才会被执行</font>)另外上述代码其实用到了rxjava，一种函数响应式编程模型，大量用在android客户端开发，事实上，Hystrix的源码大量用到了rxjava，有兴趣的可以看一下。这里我们要关注这个construct方法里面运行了两次onNext方法，相当于给订阅者发射了两次事件，如果上述只调用一次observer.onNext(“Hello”)方法，那么下面的操作是等价的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">HystrixObservableCommand</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBlocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token class-name">HystrixCommand</span><span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token class-name">HystrixObservableCommand</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBlocking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果有两次observer.onNext方法，则会抛出Sequence contains too many elements异常</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul><li>前者的命令逻辑写在run()；后者的命令逻辑写在construct()</li><li>前者的run()是由新创建的线程执行；后者的construct()是由调用程序线程执行</li><li>前者一个实例只能向调用程序发送（emit）单条数据，比如上面例子中run()只能返回一个String结果；后者一个实例可以顺序发送多条数据，比如demo中顺序调用多个onNext()，便实现了向调用程序发送多条数据，甚至还能发送一个范围的数据集。</li></ul><h2 id="响应式-Reactive"><a href="#响应式-Reactive" class="headerlink" title="响应式(Reactive)"></a>响应式(Reactive)</h2><p>你可以通过observe()和toObservable()返回一个可以观察的Observable然后，一旦你subscribe订阅了这个Observable后，就会收到Observable的事件。</p><ul><li>observe()：返回一个 “hot” Observable，会立即执行HystrixCommand的run方法(或者HystrixObservableCommand的construct方法)</li><li>toObservable()：返回一个“code” Observable，直到你subscribe订阅了这个Observable才会执行run()或者construct()</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> fWorld <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> fBob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// blocking</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">,</span> fWorld<span class="token punctuation">.</span><span class="token function">toBlockingObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Bob!"</span><span class="token punctuation">,</span> fBob<span class="token punctuation">.</span><span class="token function">toBlockingObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// non-blocking </span>    <span class="token comment">// - this is a verbose anonymous inner-class approach and doesn't do assertions</span>    fWorld<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompleted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// nothing needed here</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onError</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onNext</span><span class="token punctuation">(</span><span class="token class-name">String</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"onNext: "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// non-blocking</span>    <span class="token comment">// - also verbose anonymous inner-class</span>    <span class="token comment">// - ignore errors and onCompleted signal</span>    fBob<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Action1</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">String</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"onNext: "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是java8使用lambda表达式，会更简洁(<font color="red">作为一个写代码能少就少的码农，这里吐槽下国内的项目一般都用的是java6和java7，感觉lambda写起来很爽很屌</font>)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">fWorld<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"onNext: "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token comment">// - or while also including error handling</span>        fWorld<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"onNext: "</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>exception<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Command-Name-Group-Thread-pool"><a href="#Command-Name-Group-Thread-pool" class="headerlink" title="Command Name/Group/Thread-pool"></a>Command Name/Group/Thread-pool</h2><h3 id="Command-Name"><a href="#Command-Name" class="headerlink" title="Command Name"></a>Command Name</h3><p>默认情况CommandName=getClass().getSimpleName()，当然你可以通过HystrixCommand或者HystrixObservableCommand的构造方法显示的指定CommandName</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在创建自己的HystrixCommand(HystrixObservableCommand)，需要在构造方法中调用父类的构造方法，其中可以传入一个Setter对象，这其实就是Hystrix给我提供的一个builder模式构造对象，里面可以设置很多需要的属性(HystrixCommandProperties也可以在这里面设置，当然你不设置Hystrix对与这些属性也会有默认设置)。这里我们通过HystrixCommandKey.Factory.asKey(“HelloWorld”))方法设置commandName=’HelloWorld’</p><h3 id="Command-Group"><a href="#Command-Group" class="headerlink" title="Command Group"></a>Command Group</h3><p>和上面的Command Name一样，我们可以通过下面方法设置Goup Name<br>HystrixCommandGroupKey.Factory.asKey(“ExampleGroup”)</p><p>Hystrix使用了group key把一些命令放在同一个组里面(比如我们系统依赖了外部的Service A和Service B，我们可以创建两个Command Group A、Command Group B，其中A服务又有m1，m2方法，那么Command Group A又包括了Command Name m1 和Command Name m2)，然后以组为维度上传监控数据，提供监控大盘，报警。<br>另外，默认情况下，同一个Command Group下的Command使用相同的Thread-pool，除非某些Command单独指定了线程池。</p><h3 id="Command-Thread-pool"><a href="#Command-Thread-pool" class="headerlink" title="Command Thread-pool"></a>Command Thread-pool</h3><p>Thread-pool key代表了用来执行用户业务逻辑的一个线程池HystrixThreadPool(注意，hystrix为了failfast，实现的线程池没有用队列缓存，如果没有可用线程，直接抛出异常)。如果你创建的HystrixCommand没有显示的指定thread-pool key，那么默认情况下就会使用HystrixCommandGroupKey。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CommandHelloWorld</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">Setter</span><span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">andThreadPoolKey</span><span class="token punctuation">(</span><span class="token class-name">HystrixThreadPoolKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"HelloWorldPool"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以下使用HystrixThreadPoolKey.Factory.asKey(“HelloWorldPool”)来指定某个command特有的线程池，我们之所以不用一个新的Command Group而使用<br>HystrixThreadPoolKey是有原因的：我们有若干个Commands属于一个group，但是某些情况下，有部分command发生异常需要被隔离例如:</p><pre class="line-numbers language-none"><code class="language-none">two commands used to access User metadatagroup name is “userGroup”command A fetch userNamecommand B fetch userAgecommand A依赖的服务挂了不应该影响commadn B的服务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑上Command A和B都依赖于外部的user service所以让他们属于同一个组userGroup，但是为了避免Command A挂了影响Command B，我们可以给A指定一个单独的HystrixThreadPoolKey。</p><h2 id="Fallback降级"><a href="#Fallback降级" class="headerlink" title="Fallback降级"></a>Fallback降级</h2><p>如果你的系统依赖的外部服务出现故障，Hystrix给我们提供了优雅的降级方案，你只需要实现getFallBack方法，这样当调用失败，超时，reject或者short-circuits时候会回调你的fallback方法可以返回一个默认值给调用方。当然以下情况可能fallback方法可能没啥作用，可以注意下:</p><ul><li>如果你是调用一个写命令，这种情况多数都是返回void，这种情况一般是希望报错尽快能通知到调用者(比如抛异常，默认不实现抛出UnsupportedOperationException)，这个时候实现这个fallback方法可能意义不大。</li><li>批量作业或者离线计算，这个时候也一般希望错误能尽快传给调用者</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandHelloFailure</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">CommandHelloFailure</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HystrixCommandGroupKey<span class="token punctuation">.</span>Factory</span><span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span><span class="token string">"ExampleGroup"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"this command always fails"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Hello Failure "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>         <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Failure World!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloFailure</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Hello Failure Bob!"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CommandHelloFailure</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外不是所有的异常都会回调fallback方法，下面有个表格</p><table><thead><tr><th>Failure Type</th><th align="right">Exception class</th><th align="center">Exception.cause</th><th align="center">subject to fallback</th></tr></thead><tbody><tr><td>FAILURE</td><td align="right">HystrixRuntimeException</td><td align="center">underlying exception (user-controlled)</td><td align="center">YES</td></tr><tr><td>TIMEOUT</td><td align="right">HystrixRuntimeException</td><td align="center">j.u.c.TimeoutException</td><td align="center">YES</td></tr><tr><td>SHORT_CIRCUITED</td><td align="right">HystrixRuntimeException</td><td align="center">j.l.RuntimeException</td><td align="center">YES</td></tr><tr><td>THREAD_POOL_REJECTED</td><td align="right">HystrixRuntimeException</td><td align="center">j.u.c.RejectedExecutionException</td><td align="center">YES</td></tr><tr><td>SEMAPHORE_REJECTED</td><td align="right">HystrixRuntimeException</td><td align="center">j.l.RuntimeException</td><td align="center">YES</td></tr><tr><td>BAD_REQUEST</td><td align="right">HystrixRuntimeException</td><td align="center">underlying exception (user-controlled)</td><td align="center">NO</td></tr></tbody></table><p><font color="red">HystrixBadRequestException主要用来处理非法参数和一些非系统错误问题，所以不会触发fallback方法</font></p><p>HystrixObservableCommand就需要实现resumeWithFallback方法，如果你用HystrixObservableCommand emit发射了多个事件，那么你可能更希望知道是哪个事件发生了错误，下面有个demo可以参考一下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">concatWith</span><span class="token punctuation">(</span><span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"forced error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">doOnNext</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Action1</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    lastSeen <span class="token operator">=</span> t1<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span><span class="token class-name">Schedulers</span><span class="token punctuation">.</span><span class="token function">computation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token class-name">Observable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">resumeWithFallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastSeen <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>lastSeen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-</span> lastSeen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Observable</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述也是用到了rxjava，这里简单提一下，不然可能很多人看不懂。</p><ul><li>Observable.just(1, 2, 3):这个Observable会依次发送1，2，3三个事件</li><li>Observable.concatWith(Exception):这个相当于在(1,2,3)后面又发送了一个Exception事件</li><li>Observable.doOnNext:每次在调用订阅者Observer的消费(onNext)方法之前都会调用这个doOnNext方法</li><li>Observable.subscribeOn:指定产生订阅事件发生在Schedulers.computation()线程池里面</li><li>Observable.range(start,count):发射从start开始依次递增加一 count个事件</li></ul><p>知道了上述意思后，我们就不难搞懂上述代码是每次都把执行的事件通过一个中间变量记录下来，这样就知道Observable发射的多个事件到底是哪个报错。</p><h2 id="Request-Cache"><a href="#Request-Cache" class="headerlink" title="Request Cache"></a>Request Cache</h2><p>可以实现getCacheKey()方法来达到缓存请求的目的，这样在同一个上下文档中，如果有相同的请求，就可以使用缓存中的值。<font color="red">注意这里我强调了同一个上下文，只有同一个上下文当中缓存才有效</font></p><pre class="line-numbers language-none"><code class="language-none">public class CommandUsingRequestCache extends HystrixCommand&lt;Boolean&gt; &#123;    private final int value;    protected CommandUsingRequestCache(int value) &#123;        super(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;));        this.value &#x3D; value;    &#125;    @Override    protected Boolean run() &#123;        return value &#x3D;&#x3D; 0 || value % 2 &#x3D;&#x3D; 0;    &#125;    @Override    protected String getCacheKey() &#123;        return String.valueOf(value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWithCacheHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">HystrixRequestContext</span> context <span class="token operator">=</span> <span class="token class-name">HystrixRequestContext</span><span class="token punctuation">.</span><span class="token function">initializeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CommandUsingRequestCache</span> command2a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandUsingRequestCache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CommandUsingRequestCache</span> command2b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandUsingRequestCache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>command2a<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第一次执行cacheKey=2，缓存还没有，所以false</span>        <span class="token function">assertFalse</span><span class="token punctuation">(</span>command2a<span class="token punctuation">.</span><span class="token function">isResponseFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>command2b<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 第二次执行cacheKey=2，缓存已经有了，所以true</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>command2b<span class="token punctuation">.</span><span class="token function">isResponseFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        context<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// start a new request context</span>    context <span class="token operator">=</span> <span class="token class-name">HystrixRequestContext</span><span class="token punctuation">.</span><span class="token function">initializeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CommandUsingRequestCache</span> command3b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandUsingRequestCache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span>command3b<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 因为是开启了一个新的context，所以尽管cacheKey=2，但是还是没有用到缓存</span>        <span class="token function">assertFalse</span><span class="token punctuation">(</span>command3b<span class="token punctuation">.</span><span class="token function">isResponseFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        context<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Request-Context-Setup"><a href="#Request-Context-Setup" class="headerlink" title="Request Context Setup"></a>Request Context Setup</h2><p>如果你想用到上述的reqeust cache(还有Hystrix其他的request collapsing, request log)功能，我们可以看到你需要创建一个context，如果每次都在代码里面new 一个太繁琐了。现在我们一般应用都是部署在一个web环境下，我们可以使用Servlet Filter来实现这个上下文</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixRequestContextServletFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HystrixRequestContext</span> context <span class="token operator">=</span> <span class="token class-name">HystrixRequestContext</span><span class="token punctuation">.</span><span class="token function">initializeContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            context<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>HystrixRequestContextServletFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>HystrixRequestContextServletFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>com.netflix.hystrix.contrib.requestservlet.HystrixRequestContextServletFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>HystrixRequestContextServletFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix初探</title>
      <link href="2017/09/27/hystrix1/"/>
      <url>2017/09/27/hystrix1/</url>
      
        <content type="html"><![CDATA[<p>去年在看spring cloud系列的时候，当时就已经了解到了hystrix，这个组件和eureka，zuul等组件一样都是netflix公司开源的。当时由于没有太多的精力，只简单了解了下hystrix的一些简单功能。这半年因为工作关系一直接触redis相关的东西，redis相关也看过不少书了，有时候一直搞一件事可能觉得有点枯燥。就偶然又产生了想法，就决定重新看一下hystrix，决定搞一个hystrix系列。在阅读hystrix的代码过程中，刚开始看起来很吃力，里面用到了rxjava(采用函数响应式编程模式写的，感觉看起来很费劲)，发现要学习的东西越来越多。就想从最简单的hystrix介绍到使用最后到源码分析，写一个系列的博客，正好也长时间没有研究一些新的框架了。上面废话了很多，下面进入正题，本文主要从以下几方面简要介绍下hystrix，基本都是一些概念性的(基本都是翻译自github上Hystrix主页)。</p><span id="more"></span><blockquote><ul><li>Hystrix是什么</li><li>Hystrix用来做什么</li><li>Hystrix解决了什么问题</li><li>Hystrix设计模式</li><li>Hystrix如何实现它的设计目标</li></ul></blockquote><h2 id="Hystrix是什么"><a href="#Hystrix是什么" class="headerlink" title="Hystrix是什么"></a>Hystrix是什么</h2><p>在一个分布式的系统当中，不可避免的会出现一些对于外部service的依赖调用报错。Hystrix可以添加一些对于延时的容忍和容错性来帮助你控制与这些外部service的交互，Hystrix是通过隔离这些单个的服务(比如把这些外部服务放在单独的线程池里面执行)来避免瀑布式的报错，并且提供了降级fallback方法，以上这些都可以提供系统的可用性。</p><h2 id="Hystrix用来做什么"><a href="#Hystrix用来做什么" class="headerlink" title="Hystrix用来做什么"></a>Hystrix用来做什么</h2><blockquote><ul><li>对于调用外部服务提供容错和超时保护机制</li><li>避免在一个分布式系统中瀑布式报错</li><li>fail fast和及时恢复</li><li>fallback和优雅降级</li><li>近乎实时的监控，报警和运维</li></ul></blockquote><h2 id="Hystrix解决了什么问题"><a href="#Hystrix解决了什么问题" class="headerlink" title="Hystrix解决了什么问题"></a>Hystrix解决了什么问题</h2><p>在一个复杂的分布式系统当中，肯定会存在一系列的外部服务，其中每个服务都可能会在某个时刻发生错误。如果我们的应用不能与这些发生错误的服务隔离，那么我们的应用就有可能被他们拖垮。</p><p>所有外部服务都运行正常的情况下，我们服务是这样的:<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/healthy.jpeg" alt="服务正常"></p><p>当其中一个外部服务不可用(或者开始出现延时)，就会开始阻塞用户请求<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/unhealthy.jpeg" alt="服务异常"></p><p>当一个服务开始延时就会慢慢开始影响上游的一系列相关的服务，导致上游也出现延时。并且更糟糕的是，相关联的上游服务如果有一些重试机制就会耗尽线程池，io和一些其他的系统资源，就会在整个系统之间导致瀑布式的错误<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/unhealthy2.jpeg" alt="瀑布式异常"></p><h2 id="Hystrix采用以下设计原则"><a href="#Hystrix采用以下设计原则" class="headerlink" title="Hystrix采用以下设计原则"></a>Hystrix采用以下设计原则</h2><blockquote><ul><li>避免单个的外部依赖耗尽应用资源(例如tomcat)线程</li><li>通过fail fast机制代替队列来降低负载</li><li>在适当时候提供fallback机制</li><li>通过一些隔离的技术手段(例如bulkhead, swimlane, and circuit breaker patterns)来降低单个外部服务故障造成的影响</li><li>通过近乎实时的监控，报警和运维来更好更实时发现错误</li><li>通过动态的调整一些配置来修改系统运行的参数实时处理系统异常</li><li>提供完整的客户端调用保护机制，并不仅仅是网络调用方面。</li></ul></blockquote><h2 id="Hystrix如何实现它的设计目标"><a href="#Hystrix如何实现它的设计目标" class="headerlink" title="Hystrix如何实现它的设计目标"></a>Hystrix如何实现它的设计目标</h2><blockquote><ul><li>把对外部系统的一些调用包装成HystrixCommand或者HystrixObservableCommand命令在一个单独的线程池里面执行(command pattern)</li><li>可以自己设置超时相关的参数，默认情况超过你设置的最大值就超时，还可以通过设置一些属性，比如设置99.5那么比99.5%的请求慢的就是超时</li><li>对每一个外部调用都创建一个单独的线程池，如果线程池满了，那么就直接拒绝fail fast</li><li>测量所有的成功，失败，超时，thread rejections请求</li><li>如果某个服务的错误百分比超过设置的阈值，则通过手动或自动地中断一个断路器停止某一特定服务的所有请求一段时间。</li><li>当调用失败，超时，reject或者short-circuits时候提供fallback机制</li><li>监控指标和配置变更实时生效</li></ul></blockquote><p>当在一个分布式系统中使用了Hystrix后，所有对于外部的依赖调用都被隔离在一个单独的线程池，单独的服务故障不会影响其他服务。并通过提供fallback机制应对某个服务出现异常情况。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201709/network.jpeg" alt="Hystrix系统"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JedisPool连接池相关配置</title>
      <link href="2017/07/08/jedispoolconfig/"/>
      <url>2017/07/08/jedispoolconfig/</url>
      
        <content type="html"><![CDATA[<p>最近有些其他业务部门的同学在线上环境redis有出现以下错误Unexpected end of stream，这个错误大致是因为，redis服务器端已经关闭了客户端的连接，而客户端不知道依然拿着原来的连接去访问redis服务器，结果就会报出这个exception。既然我们知道原因是服务器端主动关闭与客户端连接，那么我们下面看下有哪些情况会导致服务器端主动关闭连接。主要在redis.conf中有以下两个参数client-output-buffer-limit、timeout，下面我们分别来介绍下这两个参数的作用。</p><span id="more"></span><h2 id="client-output-buffer-limit"><a href="#client-output-buffer-limit" class="headerlink" title="client-output-buffer-limit"></a>client-output-buffer-limit</h2><p>对于Redis服务器的输出（也就是命令的返回值）来说，其大小通常是不可控制的。有可能一个简单的命令，能够产生体积庞大的返回数据。另外也有可能因为执行了太多命令，导致产生返回数据的速率超过了往客户端发送的速率，这是也会导致服务器堆积大量消息，从而导致输出缓冲区越来越大，占用过多内存，甚至导致系统崩溃。redis有以下两种限制来避免出现这种情况，并且不同类型的客户端可以采取不同的配置。</p><ol><li>大小限制:若客户端缓冲区超过某一个设定的值，直接关闭客户端连接。</li><li>持续性限制:若客户端缓冲区连续一定时间内一直超过某个设定的值时，则关闭客户端连接。</li></ol><p>下面是一个配置的demo:</p><pre class="line-numbers language-none"><code class="language-none">client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 8mb 2mb 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>redis把客户端分为3种，一种是普通的客户端，比如应用程序获取的jedis连接、普通的redis-cli，上面配置的三个0意思是对于客户端缓冲区无限制；第二种slave客户端，上面配置的3个参数的意思是若缓冲区超过256m则redis服务器直接关闭客户端连接，或者持续60s缓冲区一直超过64m也会关闭客户端连接。第三种是pub/sub客户端配置。</p><p>通过以上几种不同的配置，redis就可以避免客户端缓冲区过大导致占用过大内存引起的问题。后来确认了，其他项目组的同学有一个大key超过了50m(我们配置的是30m)，直接导致redis服务器关闭了连接。但是应用程序还是从jedis连接池中获取到了这个被关闭的连接去get的时候，就抛出了Unexpected end of stream异常。</p><h2 id="timeout配置"><a href="#timeout配置" class="headerlink" title="timeout配置"></a>timeout配置</h2><p>redis为了避免客户端连接数过多，有一个timeout配置，意思是如果连接的空闲时间超过了timeout的值，则关闭连接。默认配置是0，意思是没有超时限制，永远不关闭连接。生产上显然不会配置0，我们生产上配置的是120。这个timeout参数配置，要跟客户端创建的连接池的参数配合起来一起使用。下面我们看下jedis连接池的的一个配置demo。</p><pre class="line-numbers language-none"><code class="language-none"> JedisPool jedisPool &#x3D; new JedisPool(getPoolConfig(), &quot;localhost&quot;);private static GenericObjectPoolConfig getPoolConfig() &#123;        GenericObjectPoolConfig conf &#x3D; new GenericObjectPoolConfig();        &#x2F;&#x2F; 设置获取连接的最大等待时间        conf.setMaxWaitMillis(poolWaitMillis);        &#x2F;&#x2F; 设置最大连接数        conf.setMaxTotal(poolMaxTotal);        &#x2F;&#x2F; 设置最大空闲连接数        conf.setMaxIdle(poolMaxIdle);        &#x2F;&#x2F; 设置最小空闲连接数        conf.setMinIdle(poolMinIdle);        &#x2F;&#x2F; 设置获取连接时不进行连接验证(通过 PoolableObjectFactory.validateObject() 验证连接是否有效)        conf.setTestOnBorrow(false);        &#x2F;&#x2F; 设置退还连接时不进行连接验证(通过 PoolableObjectFactory.validateObject() 验证连接是否有效)        conf.setTestOnReturn(false);        &#x2F;&#x2F; 设置连接空闲时进行连接验证        conf.setTestWhileIdle(true);        &#x2F;&#x2F; 设置连接被回收前的最大空闲时间        conf.setMinEvictableIdleTimeMillis(5 * 60000);        &#x2F;&#x2F; 设置检测线程的运行时间间隔        conf.setTimeBetweenEvictionRunsMillis(60000);        &#x2F;&#x2F; 设置检测线程每次检测的对象数        conf.setNumTestsPerEvictionRun(-1);        return conf;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码构建了一个JedisPool，我们可以看到jedis使用apache common-pool2来创建一个jedis连接池的。创建jedis连接池传入了一个GenericObjectPoolConfig配置参数，我只筛选了其中一些主要的属性来说明，有兴趣的同学可以自己去看common-pool2的源码。我们主要看下最下面的几个参数(第16行到24行)，我们设置了空闲时验证，连接被回收前最大空闲时间为300s，设置检测线程的运行时间间隔是60s，设置线程每次检测的对象数是-1(如果为负数，则检测所有空闲线程)</p><pre class="line-numbers language-none"><code class="language-none">private int getNumTests() &#123;        int numTestsPerEvictionRun &#x3D; this.getNumTestsPerEvictionRun();        return numTestsPerEvictionRun &gt;&#x3D; 0?        Math.min(numTestsPerEvictionRun, this.idleObjects.size()):        (int)Math.ceil((double)this.idleObjects.size() &#x2F; Math.abs((double)numTestsPerEvictionRun));    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们redis服务端配置了timeout是120s，而我们客户端线程检测间隔是60s，每隔60s就会对所有空闲的连接进行检验，会调用JedisFactory的validateObject方法</p><pre class="line-numbers language-none"><code class="language-none">class JedisFactory implements PooledObjectFactory&lt;Jedis&gt; &#123;    @Override  public boolean validateObject(PooledObject&lt;Jedis&gt; pooledJedis) &#123;    final BinaryJedis jedis &#x3D; pooledJedis.getObject();    try &#123;      HostAndPort hostAndPort &#x3D; this.hostAndPort.get();      String connectionHost &#x3D; jedis.getClient().getHost();      int connectionPort &#x3D; jedis.getClient().getPort();      return hostAndPort.getHost().equals(connectionHost)          &amp;&amp; hostAndPort.getPort() &#x3D;&#x3D; connectionPort &amp;&amp; jedis.isConnected()          &amp;&amp; jedis.ping().equals(&quot;PONG&quot;);    &#125; catch (final Exception e) &#123;      return false;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到以上代码最后有一个jedis.ping().equals(“PONG”)，这样能保证那些没有被客户端使用的连接每60s之内都能向redis服务端发送心跳，这个时间在我们配置的timeout 120s范围内，redis服务端也就不会关闭这个连接。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cnblogs.com/kreo/p/4423362.html">redis配置详解</a></li><li><a href="http://bsr1983.iteye.com/blog/2092467">common-dbcp2数据库连接池参数说明</a></li><li><a href="http://blog.csdn.net/u011277123/article/details/53943351">common-pool2连接池详解与使用</a></li><li><a href="https://github.com/xetorthio/jedis/issues/932">jedis Issue 932</a></li><li><a href="https://github.com/xetorthio/jedis/issues/1029">jedis Issue 1029</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis-cluster </tag>
            
            <tag> jedis </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jedis源码分析</title>
      <link href="2017/06/18/jedis-cluster/"/>
      <url>2017/06/18/jedis-cluster/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201706/jedis-cluster.jpeg" alt="类图"></p><h2 id="创建redisClient-BinaryJedisCluster"><a href="#创建redisClient-BinaryJedisCluster" class="headerlink" title="创建redisClient BinaryJedisCluster"></a>创建redisClient BinaryJedisCluster</h2><p>我们可以从jedis给出官方的redis-clusterdemo上可以看到通过构造一个BinaryJedisCluster，这个类就是jedis给我们提供的一个与redis-cluster集群交互的一个基本接口类，有了这个类我们就能执行各种查询写入操作了。</p><pre class="line-numbers language-none"><code class="language-none">Set&lt;HostAndPort&gt; set &#x3D; new HashSet&lt;&gt;();HostAndPort hostAndPort &#x3D; new HostAndPort(&quot;127.0.0.1&quot;, 7000);set.add(hostAndPort);BinaryJedisCluster client &#x3D; new BinaryJedisCluster(set);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><ul><li>我们从BinaryJedisCluster的构造函数一路debug下去，可以看到这个类有一个JedisClusterConnectionHandler成员变量，在该类的构造函数当中，会去给这个成员变量赋值。进而会调用JedisSlotBasedConnectionHandler类的构造方法，又会调用到父类的构造方法。</li><li>JedisClusterConnectionHandler类中有一个JedisClusterInfoCache成员变量，在该类的构造函数中，会给JedisClusterInfoCache初始化。JedisSlotBasedConnectionHandler这个类是该类的子类，实现了抽象父类的getConnection，getConnectionFromSlot(int)两个方法。</li><li>JedisClusterInfoCache这个类缓存了redis集群的集群分片信息，我们下面来看下。</li></ul><pre class="line-numbers language-none"><code class="language-none">abstract class JedisClusterConnectionHandler&#123;    protected final JedisClusterInfoCache cache;private void initializeSlotsCache(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolConfig, String password) &#123;    for (HostAndPort hostAndPort : startNodes) &#123;      Jedis jedis &#x3D; new Jedis(hostAndPort.getHost(), hostAndPort.getPort());      try &#123;        cache.discoverClusterNodesAndSlots(jedis);        break;      &#125; catch (JedisConnectionException e) &#123;      &#125; finally &#123;        if (jedis !&#x3D; null) &#123;          jedis.close();        &#125;      &#125;    &#125;  &#125;&#125;public class JedisClusterInfoCache &#123;    private final Map&lt;String, JedisPool&gt; nodes &#x3D; new HashMap&lt;String, JedisPool&gt;();    private final Map&lt;Integer, JedisPool&gt; slots &#x3D; new HashMap&lt;Integer, JedisPool&gt;();        public void discoverClusterNodesAndSlots(Jedis jedis) &#123;        w.lock();        try &#123;          reset();          List&lt;Object&gt; slots &#x3D; jedis.clusterSlots();              for (Object slotInfoObj : slots) &#123;            List&lt;Object&gt; slotInfo &#x3D; (List&lt;Object&gt;) slotInfoObj;            if (slotInfo.size() &lt;&#x3D; MASTER_NODE_INDEX) &#123;              continue;            &#125;            List&lt;Integer&gt; slotNums &#x3D; getAssignedSlotArray(slotInfo);            &#x2F;&#x2F; hostInfos            int size &#x3D; slotInfo.size();            for (int i &#x3D; MASTER_NODE_INDEX; i &lt; size; i++) &#123;              List&lt;Object&gt; hostInfos &#x3D; (List&lt;Object&gt;) slotInfo.get(i);              if (hostInfos.size() &lt;&#x3D; 0) &#123;                continue;              &#125;              HostAndPort targetNode &#x3D; generateHostAndPort(hostInfos);              setupNodeIfNotExist(targetNode);              if (i &#x3D;&#x3D; MASTER_NODE_INDEX) &#123;                assignSlotsToNode(slotNums, targetNode);              &#125;            &#125;          &#125;        &#125; finally &#123;          w.unlock();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，JedisClusterInfoCache的discoverClusterNodesAndSlots方法通过任意一个jedis实例然后调用jedis.clusterSlots()拿到redis集群分配的slot信息，然后把slot信息以及hostinfo信息缓存到两个对应的JedisPool map里面，这样启动阶段基本完成了。</p><h2 id="通过BinaryJedisCluster与redis-cluster交互"><a href="#通过BinaryJedisCluster与redis-cluster交互" class="headerlink" title="通过BinaryJedisCluster与redis-cluster交互"></a>通过BinaryJedisCluster与redis-cluster交互</h2><p>我们通过以下代码入手</p><pre class="line-numbers language-none"><code class="language-none">BinaryJedisCluster client &#x3D; new BinaryJedisCluster(set);client.get(&quot;key&quot;.getBytes());public class BinaryJedisCluster&#123;    @Override  public byte[] get(final byte[] key) &#123;    return new JedisClusterCommand&lt;byte[]&gt;(connectionHandler, maxAttempts) &#123;      @Override      public byte[] execute(Jedis connection) &#123;        return connection.get(key);      &#125;    &#125;.runBinary(key);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述通过一个简单的get操作，最终会调用到BinaryJedisCluster.runBinary(key)方法。</p><pre class="line-numbers language-none"><code class="language-none">public abstract class JedisClusterCommand&lt;T&gt; &#123;    private T runWithRetries(byte[] key, int attempts, boolean tryRandomNode, boolean asking) &#123;    if (attempts &lt;&#x3D; 0) &#123;      throw new JedisClusterMaxRedirectionsException(&quot;Too many Cluster redirections?&quot;);    &#125;    Jedis connection &#x3D; null;    try &#123;      if (asking) &#123;        &#x2F;&#x2F; TODO: Pipeline asking with the original command to make it        &#x2F;&#x2F; faster....        connection &#x3D; askConnection.get();        connection.asking();        &#x2F;&#x2F; if asking success, reset asking flag        asking &#x3D; false;      &#125; else &#123;        if (tryRandomNode) &#123;          connection &#x3D; connectionHandler.getConnection();        &#125; else &#123;          connection &#x3D; connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));        &#125;      &#125;      return execute(connection);    &#125; catch (JedisNoReachableClusterNodeException jnrcne) &#123;      throw jnrcne;    &#125; catch (JedisConnectionException jce) &#123;      &#x2F;&#x2F; release current connection before recursion      releaseConnection(connection);      connection &#x3D; null;      if (attempts &lt;&#x3D; 1) &#123;        &#x2F;&#x2F;We need this because if node is not reachable anymore - we need to finally initiate slots renewing,        &#x2F;&#x2F;or we can stuck with cluster state without one node in opposite case.        &#x2F;&#x2F;But now if maxAttempts &#x3D; 1 or 2 we will do it too often. For each time-outed request.        &#x2F;&#x2F;TODO make tracking of successful&#x2F;unsuccessful operations for node - do renewing only        &#x2F;&#x2F;if there were no successful responses from this node last few seconds        this.connectionHandler.renewSlotCache();        &#x2F;&#x2F;no more redirections left, throw original exception, not JedisClusterMaxRedirectionsException, because it&#39;s not MOVED situation        throw jce;      &#125;      return runWithRetries(key, attempts - 1, tryRandomNode, asking);    &#125; catch (JedisRedirectionException jre) &#123;      &#x2F;&#x2F; if MOVED redirection occurred,      if (jre instanceof JedisMovedDataException) &#123;        &#x2F;&#x2F; it rebuilds cluster&#39;s slot cache        &#x2F;&#x2F; recommended by Redis cluster specification        this.connectionHandler.renewSlotCache(connection);      &#125;      &#x2F;&#x2F; release current connection before recursion or renewing      releaseConnection(connection);      connection &#x3D; null;      if (jre instanceof JedisAskDataException) &#123;        asking &#x3D; true;        askConnection.set(this.connectionHandler.getConnectionFromNode(jre.getTargetNode()));      &#125; else if (jre instanceof JedisMovedDataException) &#123;      &#125; else &#123;        throw new JedisClusterException(jre);      &#125;      return runWithRetries(key, attempts - 1, false, asking);    &#125; finally &#123;      releaseConnection(connection);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>正常情况：上述代码connection=connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));这个是根据key来计算对应的slot，然后根据启动阶段JedisClusterInfoCache的private final Map&lt;Integer, JedisPool&gt; slots = new HashMap&lt;Integer,JedisPool&gt;()属性来找到该slot对应的JedisPool，然后从pool中获取一个jedis connection，最终执行connection.get(key);</li><li>异常情况1：JedisNoReachableClusterNodeException，显然都没有可以访问的节点了，直接向上层抛出，不做处理。</li><li>异常情况2：JedisConnectionException会进行重试，如果当前已经是最后一次重试，则this.connectionHandler.renewSlotCache()更新slotcache。</li><li>异常情况3：JedisRedirectionException和异常情况2差不多基本也是更新slot，不同是此时jedis是通的，所以可以直接传进renewSlotCache(jedis)，避免renewSlotCache方法内部多余的轮询获取jedis的操作。然后重试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis-cluster </tag>
            
            <tag> jedis </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何编写整洁代码</title>
      <link href="2017/06/04/cleancode/"/>
      <url>2017/06/04/cleancode/</url>
      
        <content type="html"><![CDATA[<h2 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h2><ul><li>认识到整洁代码对于提高代码质量的重要性，有内在意愿去写好整洁的代码</li><li>思考如何加强、提升外部管理，从整洁代码角度去提高代码质量</li><li>熟悉掌握一些方法技能，清楚什么是整洁代码，能够写出整洁的代码</li></ul><h2 id="二、意义"><a href="#二、意义" class="headerlink" title="二、意义"></a>二、意义</h2><ul><li>再复杂的系统最终也是由一行行代码构成的。所以，整洁的代码是构建一个良好系统的基石。</li><li>整洁代码是易读的，可维护性强，有利于节约维护成本，减少维护代价。</li><li>有利于防止“破窗效应”扩散</li><li>减少”技术债务”</li></ul><h2 id="三、背景介绍"><a href="#三、背景介绍" class="headerlink" title="三、背景介绍"></a>三、背景介绍</h2><p>什么是整洁的代码？<br><img src="/2017/06/04/cleancode/definition1.png" width="60%/"><br><img src="/2017/06/04/cleancode/definition2.png" width="60%/"><br><img src="/2017/06/04/cleancode/definition3.png" width="60%/"></p><h2 id="四、程序员的自我修养"><a href="#四、程序员的自我修养" class="headerlink" title="四、程序员的自我修养"></a>四、程序员的自我修养</h2><ul><li>端正态度(勒布朗法则，Later equals never)</li><li>良好的责任心意识</li><li>写好的、整洁的代码是与人方便，与己方便，是一件高尚的事，这样的人是一个高尚的人；反之，写烂的，晦涩难度的，给人挖坑的代码，则会给自己和别人带来麻烦，甚至为团队带去负价值。</li><li>在其意识里降低对代码“坏味道”的容忍程度，提高代码品味，养成“代码洁癖”的习惯</li><li>“让世界在你走时比你来时更美好些”。</li></ul><h2 id="五、管理"><a href="#五、管理" class="headerlink" title="五、管理"></a>五、管理</h2><ul><li>营造崇尚高质量代码的团队氛围</li><li>加强人员交流，共同提升</li><li>高质量代码规则制定，遵守</li><li>自动工具和code review检查机制</li></ul><h2 id="六、技能提升"><a href="#六、技能提升" class="headerlink" title="六、技能提升"></a>六、技能提升</h2><p>下面将通过一些实例，来提升大家对各种“坏味道”代码的甄别能力，提高写出“整洁代码”的技能，从而达到提高代码质量的目的。</p><h3 id="6-1、重视命名"><a href="#6-1、重视命名" class="headerlink" title="6.1、重视命名"></a>6.1、重视命名</h3><p>坏味道代码<br><img src="/2017/06/04/cleancode/name.png" width="60%/"></p><ul><li>名正才能言顺，一个好的命名往往是做好一件事情的开始</li><li>像给自己的小孩取名字一样重视程序中的每一次命名，变量，方法，类，包等等。</li><li>类名一般用名词短语；方法名一般是动宾短语；根据用途、目的起有意义的名字；优先考虑用良好的命名来表达含义而非注释；命名不宜过长；给每个抽象的概念选一个恰当词，并一以贯之；不同概念的命名要做有意义的区分。</li><li>别害怕长名称，长而具有描述性的名称比短而令人费解的名称号，比描述性的长注释好</li></ul><h3 id="6-2、良好的注释"><a href="#6-2、良好的注释" class="headerlink" title="6.2、良好的注释"></a>6.2、良好的注释</h3><ul><li>注释应该恰到好处</li><li>注释不应该为了掩饰糟糕的代码而存在</li><li>误导：过多的注释难以维护，容易在修改代码后忘记修改注释，导致注释与代码含义不一致，产生误导</li><li>多余：代码表达已经很明确了，没必要在重复的写注释</li><li>日志类的注释：用来记录一段代码的修改历史，没必要，代码版本管理工具可以做到</li><li>注释的格式：类，方法，块，行等等</li><li> 无论todo目的如何，都不留下糟糕代码借口</li></ul><h3 id="6-3、变量单一用途"><a href="#6-3、变量单一用途" class="headerlink" title="6.3、变量单一用途"></a>6.3、变量单一用途</h3><p>坏味道代码<br><img src="/2017/06/04/cleancode/badMethod.png" width="60%/"></p><h3 id="6-4、重复代码"><a href="#6-4、重复代码" class="headerlink" title="6.4、重复代码"></a>6.4、重复代码</h3><p>坏味道代码<br><img src="/2017/06/04/cleancode/repeat.png" width="60%/"><br><img src="/2017/06/04/cleancode/repeat2.png" width="60%/"><br><img src="/2017/06/04/cleancode/repeatRefactor.png" width="60%/"></p><ul><li>如果同一代码反复出现，就表示某种想法未在代码中得到良好的体现。</li><li>减少重复代码，提高表达力，提早构件简单对象</li></ul><p>模板方法</p><ul><li>定义一个操作的算法的骨架，而将一些步骤延迟到子类中。模板方法是的子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</li><li>如果某些步骤逻辑相同，则可以很好的重用。</li></ul><h3 id="6-5、性能优化误区"><a href="#6-5、性能优化误区" class="headerlink" title="6.5、性能优化误区"></a>6.5、性能优化误区</h3><img src="/2017/06/04/cleancode/mistake2.png" width="60%/"><ul><li>“过早的优化是一切罪恶的根源”-高纳德（《计算机程序设计艺术》作者，图灵奖获得者）</li><li>先做对，再做快。</li><li>先做可靠，再做快。</li><li>先把代码做整洁，再做快。</li><li>别为获得“一丁点”性能，就牺牲整洁。</li><li>让整洁正确的程序更快，要比让快速的程序运行正确容易得多。</li><li>不要想当然的做调优，请先用工具测试分析。</li><li>整洁获得性能</li><li>习惯上，所有的函数调用都增加了不必要的负担。事实上，一流的编译器优化会将短的代码转成内联函数。在现代的计算机上，函数调用代价接近0. – Joseph M.Comer</li><li>所以，不要为了所谓的性能，把本应拆分成多个函数的代码揉到一个函数里。</li></ul><p>你会使用下面哪一种写法？<br><img src="/2017/06/04/cleancode/mistake.png" width="60%/"></p><ul><li>首先现代的java编译器会将第一种优化成第二种，所以性能是一样的</li><li>我们应该尽量缩小变量的作用域，就意味着：1变量能更早的被回收；2减少错误的概率</li><li>第一种写法相比起来也更加直观和更佳简单，易于维护</li></ul><h3 id="6-6、助手方法"><a href="#6-6、助手方法" class="headerlink" title="6.6、助手方法"></a>6.6、助手方法</h3><img src="/2017/06/04/cleancode/refactor1.png" width="60%/"><img src="/2017/06/04/cleancode/refactor2.png" width="60%/"><ul><li>提取小的，私有的方法来使计算的主体部分表达得更简明，代码也比较易懂</li><li>通过隐藏目前不关心的细节，让读者可以通过方法名字来理解意图，从而将复杂度分解到不同层次，使得需要同时关注的复杂度降低。</li><li>助手方法有助增强复用</li><li>助手方法利于方法职责单一，降低“误改”风险</li></ul><h3 id="6-7、方法的短小规则"><a href="#6-7、方法的短小规则" class="headerlink" title="6.7、方法的短小规则"></a>6.7、方法的短小规则</h3><ul><li>方法的第一规则是要“短小”</li><li>方法的第二规则是还要“更短小”</li><li>我的目标：80%的方法在15行内，19%在15-20行，1%可以超过20行。</li><li>把方法写长很容易，把方法写短很难。</li><li>“如果我有更长的时间，我会给你写更短的信”—Pascal</li><li>短小的方法一目了然，只专注做一件事</li></ul><h3 id="6-8、圈复杂度"><a href="#6-8、圈复杂度" class="headerlink" title="6.8、圈复杂度"></a>6.8、圈复杂度</h3><ul><li>圈复杂度是一种软件复杂程度的度量方法，用于计算一个方法中执行路径的数量。</li><li>圈复杂度大于10的方法存在很大的出错风险。</li><li>1-4：低复杂度</li><li>5-7：中复杂</li><li>8-10：高复杂度</li><li>11+：非常高复杂度</li></ul><p>如何计算圈复杂读：</p><ul><li>初始值为1，从上到下通过代码</li><li>遇到关键字if/for/and/while/or，每个加1</li><li>每个case（包括default）语句，加1</li><li>遇到一个三元运算符，加1</li><li>遇到catch语句，加1</li></ul><h3 id="6-9、使用卫语句"><a href="#6-9、使用卫语句" class="headerlink" title="6.9、使用卫语句"></a>6.9、使用卫语句</h3><p>坏味道代码<br><img src="/2017/06/04/cleancode/badSmile1.png" width="60%/"></p><p>使用卫语句优化后的代码<br><img src="/2017/06/04/cleancode/badSmileRefactor.png" width="60%/"></p><ul><li>如果条件分支的某个分支的很特殊，很罕见，就应该提前检查，如果为真就应及早退出。这样的检查常常称作卫语句。</li><li>方法中的条件逻辑使人难以看清正常的执行途径。使用卫语句表现所有特殊情况。使用卫语句往往意味着各分支地位不是平等的。</li><li>卫语句可以减少条件表达式嵌套层次。</li></ul><h3 id="6-10、无副作用的方法"><a href="#6-10、无副作用的方法" class="headerlink" title="6.10、无副作用的方法"></a>6.10、无副作用的方法</h3><p>坏味道代码<br><img src="/2017/06/04/cleancode/badSmile2.png" width="60%/"><br><img src="/2017/06/04/cleancode/badSmile3.png" width="60%/"></p><ul><li>方法承诺做一件事，但实际还会做其他隐藏起来的事。（从命令上看是个读方法，实际会有写操作）</li><li>容易让调用者发生误解，错误的使用该方法。</li></ul><h3 id="6-11、写一个方法要思考的东西"><a href="#6-11、写一个方法要思考的东西" class="headerlink" title="6.11、写一个方法要思考的东西"></a>6.11、写一个方法要思考的东西</h3><ul><li>我写这个方法是做什么的，要完成什么样的目标和任务。确定方法的参数个数。</li><li>根据要做什么来给方法取个恰当的名字。</li><li>方法的执行步骤是在同一个抽象层次吗？不是则将低层逻辑提取到低抽象层次的方法中去。</li><li>一些代码行是不是在解决不同的子问题，如是则抽取到独立的方法。</li><li>这个方法做了几件事，做了目标外的其他事吗？如是则考虑拆分方法。</li><li>每个方法是否有副作用？</li></ul><h3 id="6-12、一些经典的“坏味道”"><a href="#6-12、一些经典的“坏味道”" class="headerlink" title="6.12、一些经典的“坏味道”"></a>6.12、一些经典的“坏味道”</h3><ul><li>代码重复</li><li>方法过长</li><li>循环体太长</li><li>嵌套太深</li><li>抽象层次不一致</li><li>方法参数过多</li><li>用注释来掩饰拙劣的代码</li><li>命名太差</li><li>逻辑表达式太复杂</li><li>魔法数</li><li>一个变量多种用途</li><li>使用循环控制变量</li><li>一行代码表达多件事</li><li>一个循环做了多件事</li><li>一个方法同时做多件事</li><li>方法圈复杂度过高</li><li>方法返回null或者传递null(returning null from methodsis bad,but passing null to methods is worse)</li><li>简单代码过于复杂(炫技)</li><li>线上代码里面有很多测试的main函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三天骑行青海湖</title>
      <link href="2017/05/30/qinghaihu/"/>
      <url>2017/05/30/qinghaihu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、5月26日人在囧途"><a href="#一、5月26日人在囧途" class="headerlink" title="一、5月26日人在囧途"></a>一、5月26日人在囧途</h2><p>用生命在做的说骑就骑的旅行[流泪]，早晨4点从兰州坐火车到西宁，然后西宁2个小时到西海镇，11点半开始骑行，到8点半到住的地方，一共110公里，没有空调，洗完澡冻的浑身直打颤，睡觉了[困]<br><img src="/2017/05/30/qinghaihu/052601.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052602.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052603.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052604.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052605.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052606.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052607.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052608.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052609.jpg" width="60%/"></p><h2 id="二、5月29日骑行风光"><a href="#二、5月29日骑行风光" class="headerlink" title="二、5月29日骑行风光"></a>二、5月29日骑行风光</h2><p>骑行没有终点，永远都在路上[捂脸]，BTW 当时怂恿dyd买单反，果断培养了一个人像大师[嘿哈]<br><img src="/2017/05/30/qinghaihu/052901.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052902.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052903.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052904.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052905.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052906.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052907.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052908.jpg" width="60%/"><br><img src="/2017/05/30/qinghaihu/052909.jpg" width="60%/"></p>]]></content>
      
      
      <categories>
          
          <category> 旅行足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
            <tag> 青海湖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring容器启动@Value属性无法注入</title>
      <link href="2017/04/16/springvalueannotation/"/>
      <url>2017/04/16/springvalueannotation/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一个同事基于Annotation配置了一段代码，结果有一个Configuration类的两个@Value标注的属性值没有注入进来，代码如下:</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@PropertySource(&quot;mysql.properties&quot;)public class GroupDataSourceAnatationSample &#123;    @Value(&quot;$&#123;zebra.jdbcref&#125;&quot;)    private String jdbcRef;    @Value(&quot;$&#123;zebra.pooltype&#125;&quot;)    private String poolType;    @Bean(destroyMethod &#x3D; &quot;close&quot;)    public DataSource dataSource() &#123;        。。。。。。    &#125;    @Bean    public ZebraMapperScannerConfigurer mapperScannerConfigurer() &#123;        ZebraMapperScannerConfigurer mapperScannerConfigurer &#x3D; new ZebraMapperScannerConfigurer();        mapperScannerConfigurer.setBasePackage(&quot;com.sankuai.flight.flagship.mapper&quot;);        return mapperScannerConfigurer;    &#125;    @Bean    public SqlSessionFactory sqlSessionFactoryBean() throws Exception &#123;        。。。。。。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>上面这段代码是基于java Annotation注解配置的zebra-dao的demo，上述存在一个问题，就是Value注解标注的两个属性jdbcType和poolType的值不能被注入进来。这个原因有点复杂，需要对spring容器的加载比较熟悉，之前我有两篇博客已经分析了spring容器加载的源码，有兴趣可以看一下《<a href="http://yeming.me/2016/04/16/spring/">SpringIOC源码分析</a>》《<a href="http://yeming.me/2016/04/26/spring2/">SpringIOC源码分析二(Bean实例化)</a>》。这里稍微提一下。</p><p><img src="/2017/04/16/springvalueannotation/refresh.jpg" alt="spring容器初始化"></p><p>上面这个图是spring容器的加载顺序。ZebraMapperScannerConfigurer这个类实现了BeanDefinitionRegistryPostProcessor，这是一个BeanFactoryPostProcessor可以看到若实现了这个processor，那么会在第5步调用的时候触发这个processor，所以ZebraMapperScannerConfigurer这个类会先初始化。(本来初始化是第完成第6个步骤向spring容器注册了若干个BeanPostProcessor）</p><p><img src="/2017/04/16/springvalueannotation/WechatIMG3.jpeg" alt="注册BeanPostProcessor"></p><p>注意第5个BeanPostProcessor，有了这个processor，才会在bean被实例化的时候调用这个processor来完成对@Value标注属性值的注入)。正因为现在在完成spring容器初始化第5个步骤的时候，由于实现了BeanDefinitionRegistryPostProcessor这个接口，会提前触发对ZebraMapperScannerConfigurer的实例化，可以把ZebraMapperScannerConfigurer看做GroupDataSourceAnatationSample的一个成员属性，所以也会提前触发GroupDataSourceAnatationSample的实例化，因为没有注册上述红框圈出的第5个BeanPostProcessor所以jdbcRef和poorType不会被注入。</p><p><img src="/2017/04/16/springvalueannotation/WechatIMG4.jpeg"></p><p>这个图是在ZebraMapperScannerConfigurer(singletonObject的第5个属性)初始化过程中debug出来的数据，证明了上述分析。<font color="#08c"><b>所以总结原因，就是因为ZebraMapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor这个接口造成后续spring容器的执行的一些顺序问题,引起了上述@Value属性不能注入</b></font></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>那么我们该怎么解决，我提供以下3种解决方案，下述三种方法都可以解决问题，大家有兴趣可以去尝试一下。</p><h3 id="嵌套Configuration"><a href="#嵌套Configuration" class="headerlink" title="嵌套Configuration"></a>嵌套Configuration</h3><pre class="line-numbers language-none"><code class="language-none">@Configuration@PropertySource(&quot;annotation&#x2F;mysql.properties&quot;)public class GroupDataSourceAnnotationSample &#123;    @Configuration    static class DataSourceConfig&#123;        @Value(&quot;$&#123;zebra.jdbcref&#125;&quot;)        &#x2F;&#x2F;@Value(&quot;flagshipbiz_flagship_test&quot;)        private String jdbcRef;        @Value(&quot;$&#123;zebra.pooltype&#125;&quot;)        &#x2F;&#x2F;@Value(&quot;tomcat-jdbc&quot;)        private String poolType;        @Bean(destroyMethod &#x3D; &quot;close&quot;)        public DataSource dataSource() &#123;           。。。。。。        &#125;        @Bean        public SqlSessionFactory sqlSessionFactoryBean() throws Exception &#123;            。。。。。。        &#125;    &#125;    @Bean    public ZebraMapperScannerConfigurer mapperScannerConfigurer() &#123;        ZebraMapperScannerConfigurer mapperScannerConfigurer &#x3D; new ZebraMapperScannerConfigurer();        mapperScannerConfigurer.setBasePackage(&quot;com.dianping.zebra.sample.dao&quot;);        return mapperScannerConfigurer;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非单例-多例模式"><a href="#非单例-多例模式" class="headerlink" title="非单例(多例模式)"></a>非单例(多例模式)</h3><p>第二种方法@Scope(“protoType”)多例模式(这只是一个纯粹解决问题的方法，线上不推荐这里使用多例，还请注意)</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@Scope(&quot;protoType&quot;)@PropertySource(&quot;mysql.properties&quot;)public class GroupDataSourceAnatationSample &#123;    @Value(&quot;$&#123;zebra.jdbcref&#125;&quot;)    private String jdbcRef;    @Value(&quot;$&#123;zebra.pooltype&#125;&quot;)    private String poolType;    @Bean(destroyMethod &#x3D; &quot;close&quot;)    public DataSource dataSource() &#123;        。。。。。。    &#125;    @Bean    public ZebraMapperScannerConfigurer mapperScannerConfigurer() &#123;        ZebraMapperScannerConfigurer mapperScannerConfigurer &#x3D; new ZebraMapperScannerConfigurer();        mapperScannerConfigurer.setBasePackage(&quot;com.sankuai.flight.flagship.mapper&quot;);        return mapperScannerConfigurer;    &#125;    @Bean    public SqlSessionFactory sqlSessionFactoryBean() throws Exception &#123;        。。。。。。    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拆分配置类"><a href="#拆分配置类" class="headerlink" title="拆分配置类"></a>拆分配置类</h3><p>把ZebraMapperScannerConfigurer这个bean的配置从上述DataSource中抽出来，单独放到另外一个独立的@Configuration类里面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/2016/04/16/spring/">SpringIOC源码分析</a></li><li><a href="/2016/04/26/spring2/">SpringIOC源码分析二(Bean实例化)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>樱花季的日本之旅</title>
      <link href="2017/04/05/japan/"/>
      <url>2017/04/05/japan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、3月24日初到日本"><a href="#一、3月24日初到日本" class="headerlink" title="一、3月24日初到日本"></a>一、3月24日初到日本</h2><p>乘坐日本国内的廉价航空-乐桃航空顺利到达日本<br><img src="/2017/04/05/japan/firstCome.jpg" width="60%/"></p><h2 id="二、3月26日结交各国朋友"><a href="#二、3月26日结交各国朋友" class="headerlink" title="二、3月26日结交各国朋友"></a>二、3月26日结交各国朋友</h2><p>来日本3天了，没有樱花，都不想拍照了[捂脸]。不谈政治，不知道是不是人品好，碰到的日本人真心热情，很多日本人尽管都不是顺路都会带你一起走很远，自己如果不知道路还会帮你问其他人，如果他们自己也帮不了你的忙，会感到很愧疚。另外，路上的司机确实也是会让行人先走的。问路的路上也认识了来自世界各地的朋友。<br><img src="/2017/04/05/japan/032601.jpg" width="60%/"><br><img src="/2017/04/05/japan/032602.jpg" width="60%/"><br><img src="/2017/04/05/japan/032603.jpg" width="60%/"><br><img src="/2017/04/05/japan/032604.jpg" width="60%/"><br><img src="/2017/04/05/japan/032605.jpg" width="60%/"><br><img src="/2017/04/05/japan/032606.jpg" width="60%/"></p><h2 id="三、3月29日樱花初见"><a href="#三、3月29日樱花初见" class="headerlink" title="三、3月29日樱花初见"></a>三、3月29日樱花初见</h2><p>与我而言，旅行就是用脚步丈量城市的温度。今天去了哲学之道，樱花虽未开，不影响我思考人生。如果说樱花下落的速度是秒速5里米，那么我该以怎样的速度才能与你相遇—致樱花。讲道理去东京能看到满开的樱花吧[嘿哈]<br><img src="/2017/04/05/japan/032901.jpg" width="60%/"><br><img src="/2017/04/05/japan/032902.jpg" width="60%/"><br><img src="/2017/04/05/japan/032903.jpg" width="60%/"><br><img src="/2017/04/05/japan/032904.jpg" width="60%/"><br><img src="/2017/04/05/japan/032905.jpg" width="60%/"><br><img src="/2017/04/05/japan/032906.jpg" width="60%/"><br><img src="/2017/04/05/japan/032907.jpg" width="60%/"><br><img src="/2017/04/05/japan/032908.jpg" width="60%/"><br><img src="/2017/04/05/japan/032909.jpg" width="60%/"></p><h2 id="四、4月1日伏见稻荷小憩"><a href="#四、4月1日伏见稻荷小憩" class="headerlink" title="四、4月1日伏见稻荷小憩"></a>四、4月1日伏见稻荷小憩</h2><p>与我而言，旅行就是用脚步丈量城市的温度。今天去了哲学之道，樱花虽未开，不影响我思考人生。如果说樱花下落的速度是秒速5里米，那么我该以怎样的速度才能与你相遇—致樱花。讲道理去东京能看到满开的樱花吧[嘿哈]<br><img src="/2017/04/05/japan/040101.jpg" width="60%/"><br><img src="/2017/04/05/japan/040102.jpg" width="60%/"><br><img src="/2017/04/05/japan/040103.jpg" width="60%/"><br><img src="/2017/04/05/japan/040104.jpg" width="60%/"><br><img src="/2017/04/05/japan/040105.jpg" width="60%/"><br><img src="/2017/04/05/japan/040106.jpg" width="60%/"><br><img src="/2017/04/05/japan/040107.jpg" width="60%/"><br><img src="/2017/04/05/japan/040108.jpg" width="60%/"></p><h2 id="五、4月2日富士山河口瑞士小哥"><a href="#五、4月2日富士山河口瑞士小哥" class="headerlink" title="五、4月2日富士山河口瑞士小哥"></a>五、4月2日富士山河口瑞士小哥</h2><p>出来玩不光是欣赏沿途风景，每次一个人出来路上总能遇到新朋友。之前在京都一个台湾老大爷，一个夏威夷老奶奶跟我聊了一个下午[捂脸]。今天在河口湖这边青旅碰到一个瑞士小伙，让我以后去瑞士玩可以联系他，哈哈。不过有一说一，英语还是要锻炼下才行。<br><img src="/2017/04/05/japan/040201.jpg" width="60%/"><br><img src="/2017/04/05/japan/040202.jpg" width="60%/"></p><h2 id="六、4月5日灌篮高手朝圣-致逝去的青春"><a href="#六、4月5日灌篮高手朝圣-致逝去的青春" class="headerlink" title="六、4月5日灌篮高手朝圣-致逝去的青春"></a>六、4月5日灌篮高手朝圣-致逝去的青春</h2><p>灌篮高手朝圣篇，果然镰仓高校前站都是国人。表示已经cos的很到位了，就差晴子了[捂脸]<br><img src="/2017/04/05/japan/040501.jpg" width="60%/"><br><img src="/2017/04/05/japan/040502.jpg" width="60%/"><br><img src="/2017/04/05/japan/040503.jpg" width="60%/"><br><img src="/2017/04/05/japan/040504.jpg" width="60%/"></p>]]></content>
      
      
      <categories>
          
          <category> 旅行足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 穷游 </tag>
            
            <tag> 日本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elastic-job源码分析</title>
      <link href="2017/01/24/elasticjob/"/>
      <url>2017/01/24/elasticjob/</url>
      
        <content type="html"><![CDATA[<p>先简单介绍下<a href="https://github.com/dangdangdotcom/elastic-job">elastic-job</a>，它是当当公司开源的一个分布式调度解决方案。大家都知道，当数据量比较小的时候，我们可以只用quartz只在一台服务器上处理所有的数据。随着业务发展，数据量越来越大，一台机器已经不足以支撑，就必须想办法将一个任务分成多个小任务，拆分到不同的服务器上并行的执行。例如：有一个遍历数据库某张表的作业，现有2台服务器。为了快速的执行作业，那么每台服务器应执行作业的50%。 为满足此需求，可将作业分成2片，每台服务器执行1片。需要注意的是elastic-job并不直接提供数据处理的功能，框架只会将分片项分配至各个运行中的作业服务器，开发者需要自行处理分片项与真实数据的对应关系。</p><span id="more"></span><h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><ul><li>分布式调度协调</li><li>弹性扩容缩容</li><li>失效转移</li><li>错过执行作业重触发</li><li>作业分片一致性，保证同一分片在分布式环境中仅一个执行实例</li><li>支持并行调度</li><li>支持作业声明周期操作</li><li>丰富的作业类型</li><li>Spring整合以及命名空间提供</li><li>运维平台</li></ul><p>这是我从当当网在github上开源的elastic-job上复制过来的，<a href="https://github.com/dangdangdotcom/elastic-job/blob/master/README_cn.md">elastic-job的github地址</a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们会针对上面功能列表中提到的一些功能，来研究一下源码，看下elastic-job是怎么实现它说的一些功能的。</p><h3 id="测试用demo"><a href="#测试用demo" class="headerlink" title="测试用demo"></a>测试用demo</h3><p>我们基于spring配置的一个SimpleJob。<br><font color="#08c">Application.xml</font></p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;    &lt;bean id&#x3D;&quot;elasticJobLog&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;event.rdb.driver&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;event.rdb.url&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;event.rdb.username&#125;&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;event.rdb.password&#125;&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;reg:zookeeper id&#x3D;&quot;regCenter&quot; server-lists&#x3D;&quot;$&#123;serverLists&#125;&quot; namespace&#x3D;&quot;$&#123;namespace&#125;&quot; base-sleep-time-milliseconds&#x3D;&quot;$&#123;baseSleepTimeMilliseconds&#125;&quot; max-sleep-time-milliseconds&#x3D;&quot;$&#123;maxSleepTimeMilliseconds&#125;&quot; max-retries&#x3D;&quot;$&#123;maxRetries&#125;&quot; &#x2F;&gt;    &lt;job:simple id&#x3D;&quot;$&#123;simple.id&#125;&quot; class&#x3D;&quot;$&#123;simple.class&#125;&quot; registry-center-ref&#x3D;&quot;regCenter&quot; sharding-total-count&#x3D;&quot;$&#123;simple.shardingTotalCount&#125;&quot; cron&#x3D;&quot;$&#123;simple.cron&#125;&quot; sharding-item-parameters&#x3D;&quot;$&#123;simple.shardingItemParameters&#125;&quot; monitor-execution&#x3D;&quot;$&#123;simple.monitorExecution&#125;&quot; monitor-port&#x3D;&quot;$&#123;simple.monitorPort&#125;&quot; failover&#x3D;&quot;$&#123;simple.failover&#125;&quot; description&#x3D;&quot;$&#123;simple.description&#125;&quot; disabled&#x3D;&quot;$&#123;simple.disabled&#125;&quot; overwrite&#x3D;&quot;$&#123;simple.overwrite&#125;&quot; event-trace-rdb-data-source&#x3D;&quot;elasticJobLog&quot;&gt;        &lt;job:listener class&#x3D;&quot;$&#123;listener.simple&#125;&quot; &#x2F;&gt;        &lt;job:distributed-listener class&#x3D;&quot;$&#123;listener.distributed&#125;&quot; started-timeout-milliseconds&#x3D;&quot;$&#123;listener.distributed.startedTimeoutMilliseconds&#125;&quot; completed-timeout-milliseconds&#x3D;&quot;$&#123;listener.distributed.completedTimeoutMilliseconds&#125;&quot; &#x2F;&gt;    &lt;&#x2F;job:simple&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#08c">*.properties</font></p><pre class="line-numbers language-none"><code class="language-none">&lt;!--zk相关配置--&gt;serverLists&#x3D;localhost:2181namespace&#x3D;elastic-job-example-lite-springbaseSleepTimeMilliseconds&#x3D;1000maxSleepTimeMilliseconds&#x3D;3000maxRetries&#x3D;3&lt;!--job配置--&gt;listener.simple&#x3D;com.dangdang.ddframe.job.example.listener.SpringSimpleListenerlistener.distributed&#x3D;com.dangdang.ddframe.job.example.listener.SpringSimpleDistributeListenerlistener.distributed.startedTimeoutMilliseconds&#x3D;10000listener.distributed.completedTimeoutMilliseconds&#x3D;30000simple.id&#x3D;springSimpleJobsimple.class&#x3D;com.dangdang.ddframe.job.example.job.simple.SpringSimpleJobsimple.cron&#x3D;0&#x2F;10 * * * * ?simple.shardingTotalCount&#x3D;3simple.shardingItemParameters&#x3D;0&#x3D;Beijing,1&#x3D;Shanghai,2&#x3D;Guangzhousimple.monitorExecution&#x3D;falsesimple.failover&#x3D;truesimple.description&#x3D;\u53EA\u8FD0\u884C\u4E00\u6B21\u7684\u4F5C\u4E1A\u793A\u4F8Bsimple.disabled&#x3D;falsesimple.overwrite&#x3D;truesimple.monitorPort&#x3D;9888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个xml，我们可以得到以下几个信息:</p><ul><li>Spring整合以及命名空间提供</li><li>利用了zookeeper，我们不难猜出，这个zk应该是用住配置中心的，提供集群相关的一些配置</li></ul><h3 id="应用启动配置zk监听"><a href="#应用启动配置zk监听" class="headerlink" title="应用启动配置zk监听"></a>应用启动配置zk监听</h3><p><font color="#08c">JobScheduler</font></p><pre class="line-numbers language-none"><code class="language-none">public void init() &#123;    jobExecutor.init();    JobTypeConfiguration jobTypeConfig &#x3D; jobExecutor.getSchedulerFacade().loadJobConfiguration().getTypeConfig();    JobScheduleController jobScheduleController &#x3D; new JobScheduleController(            createScheduler(jobTypeConfig.getCoreConfig().isMisfire()), createJobDetail(jobTypeConfig.getJobClass()), jobExecutor.getSchedulerFacade(), jobName);    jobScheduleController.scheduleJob(jobTypeConfig.getCoreConfig().getCron());    jobRegistry.addJobScheduleController(jobName, jobScheduleController);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法会调用到jobExecutor.init();<br><font color="#08c">JobExecutor</font></p><pre class="line-numbers language-none"><code class="language-none">public void init() &#123;    log.debug(&quot;Job &#39;&#123;&#125;&#39; controller init.&quot;, liteJobConfig.getJobName());    schedulerFacade.clearPreviousServerStatus();    regCenter.addCacheData(&quot;&#x2F;&quot; + liteJobConfig.getJobName());    schedulerFacade.registerStartUpInfo(liteJobConfig);&#125;public void registerStartUpInfo(final LiteJobConfiguration liteJobConfig) &#123;    listenerManager.startAllListeners();    leaderElectionService.leaderForceElection();    configService.persist(liteJobConfig);    serverService.persistServerOnline(!liteJobConfig.isDisabled());    serverService.clearJobPausedStatus();    shardingService.setReshardingFlag();    monitorService.listen();    listenerManager.setCurrentShardingTotalCount(configService.load(false).getTypeConfig().getCoreConfig().getShardingTotalCount());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每次作业启动前清理上次运行状态(删除zk上之前本服务器ip的节点: /{namespace}/{jobName}/servers/{ip});</li><li>然后缓存/{namespace}/{jobName}/节点;</li><li>最后注册一些TreeCacheListener(上面注册的listener都实现了这个接口)的实例来监听zk集群的节点变化，并发起主节点选举。</li></ul><p>接着来看<font color="#08c">JobScheduler</font>.init方法后面的内容，可以看到先获取需要运行的job的配置信息，然后创建Scheduler和jobDetail，通过quartz配合job，并把该job对应的jobScheduleController缓存到本地的jobRegistry中。(通过quartz会创建一个{jobName}_worker的线程，这个线程就是用来启动批处理作业的)</p><h3 id="jobName-worker线程"><a href="#jobName-worker线程" class="headerlink" title="{jobName}_worker线程"></a>{jobName}_worker线程</h3><pre class="line-numbers language-none"><code class="language-none">public static final class LiteJob implements Job &#123;    @Setter    private ElasticJob elasticJob;    @Setter    private JobFacade jobFacade;    @Override    public void execute(final JobExecutionContext context) throws JobExecutionException &#123;        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个LiteJob实现了quartz的Job接口，是job执行的入口。<br><font color="#08c">AbstractElasticJobExecutor</font></p><pre class="line-numbers language-none"><code class="language-none">public final void execute() &#123;    try &#123;        jobFacade.checkJobExecutionEnvironment();    &#125; catch (final JobExecutionEnvironmentException cause) &#123;        jobExceptionHandler.handleException(jobName, cause);    &#125;    ShardingContexts shardingContexts &#x3D; jobFacade.getShardingContexts();    jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(&quot;Job &#39;%s&#39; execute begin.&quot;, jobName));    if (jobFacade.misfireIfNecessary(shardingContexts.getShardingItemParameters().keySet())) &#123;        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(                &quot;Previous job &#39;%s&#39; - shardingItems &#39;%s&#39; is still running, misfired job will start after previous job completed.&quot;, jobName, shardingContexts.getShardingItemParameters().keySet()));        return;    &#125;    jobFacade.cleanPreviousExecutionInfo();    try &#123;        jobFacade.beforeJobExecuted(shardingContexts);        &#x2F;&#x2F;CHECKSTYLE:OFF    &#125; catch (final Throwable cause) &#123;        &#x2F;&#x2F;CHECKSTYLE:ON        jobExceptionHandler.handleException(jobName, cause);    &#125;    execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);    while (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;        jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());        execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);    &#125;    jobFacade.failoverIfNecessary();    try &#123;        jobFacade.afterJobExecuted(shardingContexts);        &#x2F;&#x2F;CHECKSTYLE:OFF    &#125; catch (final Throwable cause) &#123;        &#x2F;&#x2F;CHECKSTYLE:ON        jobExceptionHandler.handleException(jobName, cause);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述execute过程包含以下几个步骤：</p><ul><li>检查作业执行环境(本机与注册中心的时间误差秒数是否在允许范围)</li><li>然后获取该job分片信息的上下文shardingContexts(通过从zk获取job分片的总数，当前可以用来执行job的server总数，然后默认通过<font color="#08c">基于平均分配算法的分片策略</font>对总的job分片进行分配)</li><li>然后执行jobFacade.beforeJobExecuted(shardingContexts);如果有定义ElasticJobListener监听，则执行beforeJobExecuted方法。</li><li>执行execute方法(这个后面再详细分析)</li><li>然后执行jobFacade.doAfterJobExecutedAtLastCompleted(shardingContexts);如果有定义ElasticJobListener监听，则执行doAfterJobExecutedAtLastCompleted方法。</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 基于平均分配算法的分片策略. * * &lt;p&gt; * 如果分片不能整除, 则不能整除的多余分片将依次追加到序号小的服务器. * 如: * 1. 如果有3台服务器, 分成9片, 则每台服务器分到的分片是: 1&#x3D;[0,1,2], 2&#x3D;[3,4,5], 3&#x3D;[6,7,8]. * 2. 如果有3台服务器, 分成8片, 则每台服务器分到的分片是: 1&#x3D;[0,1,6], 2&#x3D;[2,3,7], 3&#x3D;[4,5]. * 3. 如果有3台服务器, 分成10片, 则每台服务器分到的分片是: 1&#x3D;[0,1,2,9], 2&#x3D;[3,4,5], 3&#x3D;[6,7,8]. * &lt;&#x2F;p&gt; * * @author zhangliang *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着分析之前一笔带过的execute的方法，最终会调用到<br><font color="#08c">AbstractElasticJobExecutor.process方法</font></p><pre class="line-numbers language-none"><code class="language-none">private void process(final ShardingContexts shardingContexts, final JobExecutionEvent.ExecutionSource executionSource) &#123;    Collection&lt;Integer&gt; items &#x3D; shardingContexts.getShardingItemParameters().keySet();    if (1 &#x3D;&#x3D; items.size()) &#123;        int item &#x3D; shardingContexts.getShardingItemParameters().keySet().iterator().next();        JobExecutionEvent jobExecutionEvent &#x3D;  new JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);        process(shardingContexts, item, jobExecutionEvent);        return;    &#125;    final CountDownLatch latch &#x3D; new CountDownLatch(items.size());    for (final int each : items) &#123;        final JobExecutionEvent jobExecutionEvent &#x3D; new JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);        if (executorService.isShutdown()) &#123;            return;        &#125;        executorService.submit(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    process(shardingContexts, each, jobExecutionEvent);                &#125; finally &#123;                    latch.countDown();                &#125;            &#125;        &#125;);    &#125;    try &#123;        latch.await();    &#125; catch (final InterruptedException ex) &#123;        Thread.currentThread().interrupt();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到如果分配到本作业服务器上的分片数若大于1，则通过线程分别把本作业上获取的n个分片构建分片上下文信息丢进线程池；若分片数目为1，则直接在本线程中执行。我们看下执行的process方法<br><font color="#08c">AbstractElasticJobExecutor.process方法</font></p><pre class="line-numbers language-none"><code class="language-none">private void process(final ShardingContexts shardingContexts, final int item, final JobExecutionEvent startEvent) &#123;    jobFacade.postJobExecutionEvent(startEvent);    log.trace(&quot;Job &#39;&#123;&#125;&#39; executing, item is: &#39;&#123;&#125;&#39;.&quot;, jobName, item);    JobExecutionEvent completeEvent &#x3D; null;    try &#123;        process(new ShardingContext(shardingContexts, item));        completeEvent &#x3D; startEvent.executionSuccess();        log.trace(&quot;Job &#39;&#123;&#125;&#39; executed, item is: &#39;&#123;&#125;&#39;.&quot;, jobName, item);        &#x2F;&#x2F; CHECKSTYLE:OFF    &#125; catch (final Throwable cause) &#123;        &#x2F;&#x2F; CHECKSTYLE:ON        completeEvent &#x3D; startEvent.executionFailure(cause);        itemErrorMessages.put(item, ExceptionUtil.transform(cause));        jobExceptionHandler.handleException(jobName, cause);    &#125; finally &#123;        jobFacade.postJobExecutionEvent(completeEvent);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法会调用到process(new ShardingContext(shardingContexts, item));这个方法在AbstractElasticJobExecutor是个抽象方法。回头看下我们上面的一段代码</p><pre class="line-numbers language-none"><code class="language-none">public static final class LiteJob implements Job &#123;    @Setter    private ElasticJob elasticJob;    @Setter    private JobFacade jobFacade;    @Override    public void execute(final JobExecutionContext context) throws JobExecutionException &#123;        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最早我们通过JobExecutorFactory获取JobExecutor，因为最开始我们创建的是SimpleJob，所以这里我们获取的实际上是一个SimpleJobExecutor，这个类继承AbstractElasticJobExecutor，所以最终会调用到<br>SimpleJobExecutor的process方法。然后SimpleJobExecutor持有一个SimpleJob的实例，最终会把分片上下文作为参数传递给我们自己实现的一个SimpleJob的实例。我们就可以根据传递给我们的分片上下文信息来编写业务批处理代码了。</p><pre class="line-numbers language-none"><code class="language-none">public final class SimpleJobExecutor extends AbstractElasticJobExecutor &#123;    private final SimpleJob simpleJob;    public SimpleJobExecutor(final SimpleJob simpleJob, final JobFacade jobFacade) &#123;        super(jobFacade);        this.simpleJob &#x3D; simpleJob;    &#125;    @Override    protected void process(final ShardingContext shardingContext) &#123;        simpleJob.execute(shardingContext);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/dangdangdotcom/elastic-job">当当elastic-job github源码地址</a></li><li><a href="http://dangdangdotcom.github.io/elastic-job/post/principles/lite/">Elastic-Job-Lite实现原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic-job </tag>
            
            <tag> 分布式调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-kafka源码分析二(Consumer)</title>
      <link href="2016/12/30/kafkaconsumer/"/>
      <url>2016/12/30/kafkaconsumer/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章我们分析了spring-kafka的producer，这篇文章我们就要来分析下consumer。</p><pre class="line-numbers language-none"><code class="language-none">ContainerProperties containerProps &#x3D; new ContainerProperties(&quot;topic1&quot;, &quot;topic2&quot;);containerProps.setMessageListener(new MessageListener&lt;Integer, String&gt;() &#123;    @Override    public void onMessage(ConsumerRecord&lt;Integer, String&gt; message) &#123;        System.out.println(&quot;received: &quot; + message);    &#125;&#125;);KafkaMessageListenerContainer&lt;Integer, String&gt; container &#x3D; createContainer(containerProps);container.setBeanName(&quot;testAuto&quot;);container.start();private static KafkaMessageListenerContainer&lt;Integer, String&gt; createContainer(ContainerProperties containerProps) &#123;    Map&lt;String, Object&gt; props &#x3D; consumerProps();    DefaultKafkaConsumerFactory&lt;Integer, String&gt; cf &#x3D;            new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(props);    KafkaMessageListenerContainer&lt;Integer, String&gt; container &#x3D;            new KafkaMessageListenerContainer&lt;Integer, String&gt;(cf, containerProps);    return container;&#125;private static Map&lt;String, Object&gt; consumerProps() &#123;        Map&lt;String, Object&gt; props &#x3D; new HashMap&lt;String, Object&gt;();        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);        props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;group&quot;);        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true);        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, &quot;100&quot;);        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, &quot;15000&quot;);        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class);        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);        return props;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到我们需要创建一个KafkaMessageListenerContainer，而创建上述container又需要创建一个DefaultKafkaConsumerFactory和一个ContainerProperties。注意ContainerProperties必须设置一个MessageListener，这个listener有个onMessage方法，如果consumer收到消息，就会调用这个方法。创建了上述container之后，然后调用container.start方法就可以开启consumer了。</p><span id="more"></span><h2 id="KafkaMessageListenerContainer-start"><a href="#KafkaMessageListenerContainer-start" class="headerlink" title="KafkaMessageListenerContainer.start"></a>KafkaMessageListenerContainer.start</h2><p>看源码不难发现，上述方法最终会调用到KafkaMessageListenerContainer.doStart方法<br>KafkaMessageListenerContainer.start==&gt;AbstractMessageListenerContainer.start==&gt;KafkaMessageListenerContainer.doStart</p><pre class="line-numbers language-none"><code class="language-none">protected void doStart() &#123;    if (isRunning()) &#123;        return;    &#125;    ContainerProperties containerProperties &#x3D; getContainerProperties();    if (!this.consumerFactory.isAutoCommit()) &#123;        AckMode ackMode &#x3D; containerProperties.getAckMode();        if (ackMode.equals(AckMode.COUNT) || ackMode.equals(AckMode.COUNT_TIME)) &#123;            Assert.state(containerProperties.getAckCount() &gt; 0, &quot;&#39;ackCount&#39; must be &gt; 0&quot;);        &#125;        if ((ackMode.equals(AckMode.TIME) || ackMode.equals(AckMode.COUNT_TIME))                &amp;&amp; containerProperties.getAckTime() &#x3D;&#x3D; 0) &#123;            containerProperties.setAckTime(5000);        &#125;    &#125;    Object messageListener &#x3D; containerProperties.getMessageListener();    Assert.state(messageListener !&#x3D; null, &quot;A MessageListener is required&quot;);    if (messageListener instanceof GenericAcknowledgingMessageListener) &#123;        this.acknowledgingMessageListener &#x3D; (GenericAcknowledgingMessageListener&lt;?&gt;) messageListener;    &#125;    else if (messageListener instanceof GenericMessageListener) &#123;        this.listener &#x3D; (GenericMessageListener&lt;?&gt;) messageListener;    &#125;    else &#123;        throw new IllegalStateException(&quot;messageListener must be &#39;MessageListener&#39; &quot;                + &quot;or &#39;AcknowledgingMessageListener&#39;, not &quot; + messageListener.getClass().getName());    &#125;    if (containerProperties.getConsumerTaskExecutor() &#x3D;&#x3D; null) &#123;        SimpleAsyncTaskExecutor consumerExecutor &#x3D; new SimpleAsyncTaskExecutor(                (getBeanName() &#x3D;&#x3D; null ? &quot;&quot; : getBeanName()) + &quot;-kafka-consumer-&quot;);        containerProperties.setConsumerTaskExecutor(consumerExecutor);    &#125;    if (containerProperties.getListenerTaskExecutor() &#x3D;&#x3D; null) &#123;        SimpleAsyncTaskExecutor listenerExecutor &#x3D; new SimpleAsyncTaskExecutor(                (getBeanName() &#x3D;&#x3D; null ? &quot;&quot; : getBeanName()) + &quot;-kafka-listener-&quot;);        containerProperties.setListenerTaskExecutor(listenerExecutor);    &#125;    this.listenerConsumer &#x3D; new ListenerConsumer(this.listener, this.acknowledgingMessageListener);    setRunning(true);    this.listenerConsumerFuture &#x3D; containerProperties            .getConsumerTaskExecutor()            .submitListenable(this.listenerConsumer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个方法给containerProperties设置了consumerTaskExecutor和listenerTaskExecutor。然后我们重点关注下这个方法最后会调用xxx.getConsumerTaskExecutor().submitListenable(this.listenerConsumer);这个方法会开启一个”-kafka-consumer-“线程，这个线程会运行ListenerConsumer.run()方法。<br><font color="#08c">KafkaMessageListenerContainer</font></p><pre class="line-numbers language-none"><code class="language-none">public void run() &#123;    if (this.autoCommit &amp;&amp; this.theListener instanceof ConsumerSeekAware) &#123;        ((ConsumerSeekAware) this.theListener).registerSeekCallback(this);    &#125;    this.count &#x3D; 0;    this.last &#x3D; System.currentTimeMillis();    if (isRunning() &amp;&amp; this.definedPartitions !&#x3D; null) &#123;        initPartitionsIfNeeded();        &#x2F;&#x2F; we start the invoker here as there will be no rebalance calls to        &#x2F;&#x2F; trigger it, but only if the container is not set to autocommit        &#x2F;&#x2F; otherwise we will process records on a separate thread        if (!this.autoCommit) &#123;            startInvoker();        &#125;    &#125;    long lastReceive &#x3D; System.currentTimeMillis();    long lastAlertAt &#x3D; lastReceive;    while (isRunning()) &#123;        try &#123;            if (!this.autoCommit) &#123;                processCommits();            &#125;            processSeeks();            if (this.logger.isTraceEnabled()) &#123;                this.logger.trace(&quot;Polling (paused&#x3D;&quot; + this.paused + &quot;)...&quot;);            &#125;            ConsumerRecords&lt;K, V&gt; records &#x3D; this.consumer.poll(this.containerProperties.getPollTimeout());            if (records !&#x3D; null &amp;&amp; this.logger.isDebugEnabled()) &#123;                this.logger.debug(&quot;Received: &quot; + records.count() + &quot; records&quot;);            &#125;            if (records !&#x3D; null &amp;&amp; records.count() &gt; 0) &#123;                if (this.containerProperties.getIdleEventInterval() !&#x3D; null) &#123;                    lastReceive &#x3D; System.currentTimeMillis();                &#125;                &#x2F;&#x2F; if the container is set to auto-commit, then execute in the                &#x2F;&#x2F; same thread                &#x2F;&#x2F; otherwise send to the buffering queue                if (this.autoCommit) &#123;                    invokeListener(records);                &#125;                else &#123;                    if (sendToListener(records)) &#123;                        if (this.assignedPartitions !&#x3D; null) &#123;                            &#x2F;&#x2F; avoid group management rebalance due to a slow                            &#x2F;&#x2F; consumer                            this.consumer.pause(this.assignedPartitions);                            this.paused &#x3D; true;                            this.unsent &#x3D; records;                        &#125;                    &#125;                &#125;            &#125;            else &#123;                if (this.containerProperties.getIdleEventInterval() !&#x3D; null) &#123;                    long now &#x3D; System.currentTimeMillis();                    if (now &gt; lastReceive + this.containerProperties.getIdleEventInterval()                            &amp;&amp; now &gt; lastAlertAt + this.containerProperties.getIdleEventInterval()) &#123;                        publishIdleContainerEvent(now - lastReceive);                        lastAlertAt &#x3D; now;                        if (this.theListener instanceof ConsumerSeekAware) &#123;                            seekPartitions(getAssignedPartitions(), true);                        &#125;                    &#125;                &#125;            &#125;            this.unsent &#x3D; checkPause(this.unsent);        &#125;        catch (WakeupException e) &#123;            this.unsent &#x3D; checkPause(this.unsent);        &#125;        catch (Exception e) &#123;            if (this.containerProperties.getGenericErrorHandler() !&#x3D; null) &#123;                this.containerProperties.getGenericErrorHandler().handle(e, null);            &#125;            else &#123;                this.logger.error(&quot;Container exception&quot;, e);            &#125;        &#125;    &#125;    if (this.listenerInvokerFuture !&#x3D; null) &#123;        stopInvokerAndCommitManualAcks();    &#125;    try &#123;        this.consumer.unsubscribe();    &#125;    catch (WakeupException e) &#123;        &#x2F;&#x2F; No-op. Continue process    &#125;    this.consumer.close();    if (this.logger.isInfoEnabled()) &#123;        this.logger.info(&quot;Consumer stopped&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="#08c">我们需要注意一点，上述代码很多地方都判断了if (!this.autoCommit)是不是自动提交，这个地方我们后面会提到</font>。我们先看到while(isRunning())循环里面有个ConsumerRecords&lt;K, V&gt; records = this.consumer.poll(this.containerProperties.getPollTimeout());这个是获取从kafka broker拿到的record，下面会判断如果record不为空，并且</p><pre class="line-numbers language-none"><code class="language-none">if (this.autoCommit) &#123;invokeListener(records);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则最终通过这个方法会调用到我们最早注册的MessageListener的onMessage方法。下面我们就会就这两个方面来分析一下源码。</p><h2 id="从broker获取record"><a href="#从broker获取record" class="headerlink" title="从broker获取record"></a>从broker获取record</h2><pre class="line-numbers language-none"><code class="language-none">public ConsumerRecords&lt;K, V&gt; poll(long timeout) &#123;    acquire();    try &#123;        if (timeout &lt; 0)            throw new IllegalArgumentException(&quot;Timeout must not be negative&quot;);        &#x2F;&#x2F; poll for new data until the timeout expires        long start &#x3D; time.milliseconds();        long remaining &#x3D; timeout;        do &#123;            Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records &#x3D; pollOnce(remaining);            if (!records.isEmpty()) &#123;                fetcher.sendFetches();                client.pollNoWakeup();                if (this.interceptors &#x3D;&#x3D; null)                    return new ConsumerRecords&lt;&gt;(records);                else                    return this.interceptors.onConsume(new ConsumerRecords&lt;&gt;(records));            &#125;            long elapsed &#x3D; time.milliseconds() - start;            remaining &#x3D; timeout - elapsed;        &#125; while (remaining &gt; 0);        return ConsumerRecords.empty();    &#125; finally &#123;        release();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到上述方法又会调用pollOnce方法来获取record</p><pre class="line-numbers language-none"><code class="language-none">private Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollOnce(long timeout) &#123;    &#x2F;&#x2F; TODO: Sub-requests should take into account the poll timeout (KAFKA-1894)    coordinator.ensureCoordinatorReady();    &#x2F;&#x2F; ensure we have partitions assigned if we expect to    if (subscriptions.partitionsAutoAssigned())        coordinator.ensurePartitionAssignment();    &#x2F;&#x2F; fetch positions if we have partitions we&#39;re subscribed to that we    &#x2F;&#x2F; don&#39;t know the offset for    if (!subscriptions.hasAllFetchPositions())        updateFetchPositions(this.subscriptions.missingFetchPositions());    long now &#x3D; time.milliseconds();    &#x2F;&#x2F; execute delayed tasks (e.g. autocommits and heartbeats) prior to fetching records    client.executeDelayedTasks(now);    &#x2F;&#x2F; init any new fetches (won&#39;t resend pending fetches)    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records &#x3D; fetcher.fetchedRecords();    &#x2F;&#x2F; if data is available already, e.g. from a previous network client poll() call to commit,    &#x2F;&#x2F; then just return it immediately    if (!records.isEmpty())        return records;    fetcher.sendFetches();    client.poll(timeout, now);    return fetcher.fetchedRecords();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法通过注释就能看到，它首先在获取数据之前会确保subscribed topics or partitions，然后执行autocommits and heartbeats任务，最后会调用client.poll(timeout, now)方法。我们猜测这个方法会把获取的record放在一个类似于queue里面，然后通过fetcher.fetchedRecords()返回。</p><pre class="line-numbers language-none"><code class="language-none">private void poll(long timeout, long now, boolean executeDelayedTasks) &#123;    &#x2F;&#x2F; send all the requests we can send now    trySend(now);    &#x2F;&#x2F; ensure we don&#39;t poll any longer than the deadline for    &#x2F;&#x2F; the next scheduled task    timeout &#x3D; Math.min(timeout, delayedTasks.nextTimeout(now));    clientPoll(timeout, now);    now &#x3D; time.milliseconds();    &#x2F;&#x2F; handle any disconnects by failing the active requests. note that disconnects must    &#x2F;&#x2F; be checked immediately following poll since any subsequent call to client.ready()    &#x2F;&#x2F; will reset the disconnect status    checkDisconnects(now);    &#x2F;&#x2F; execute scheduled tasks    if (executeDelayedTasks)        delayedTasks.poll(now);    &#x2F;&#x2F; try again to send requests since buffer space may have been    &#x2F;&#x2F; cleared or a connect finished in the poll    trySend(now);    &#x2F;&#x2F; fail requests that couldn&#39;t be sent if they have expired    failExpiredRequests(now);&#125;private void clientPoll(long timeout, long now) &#123;    client.poll(timeout, now);    maybeTriggerWakeup();&#125;@Overridepublic List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;    long metadataTimeout &#x3D; metadataUpdater.maybeUpdate(now);    try &#123;        this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));    &#125; catch (IOException e) &#123;        log.error(&quot;Unexpected error during I&#x2F;O&quot;, e);    &#125;    &#x2F;&#x2F; process completed actions    long updatedNow &#x3D; this.time.milliseconds();    List&lt;ClientResponse&gt; responses &#x3D; new ArrayList&lt;&gt;();    handleCompletedSends(responses, updatedNow);    handleCompletedReceives(responses, updatedNow);    handleDisconnections(responses, updatedNow);    handleConnections();    handleTimedOutRequests(responses, updatedNow);    &#x2F;&#x2F; invoke callbacks    for (ClientResponse response : responses) &#123;        if (response.request().hasCallback()) &#123;            try &#123;                response.request().callback().onComplete(response);            &#125; catch (Exception e) &#123;                log.error(&quot;Uncaught error in request completion:&quot;, e);            &#125;        &#125;    &#125;    return responses;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到最终又会调用到NetworkClient.poll方法，上一篇关于spring-kafka producer的文章我们已经讲到了这个类。它是通过NIO的Selector，将各种socketChannel绑定在这个selector上面，然后监听各种事件。</p><p>我们接下来看下kafka的selector是怎么处理就绪的读事件的<br><font color="#08c">org.apache.kafka.common.network.Selector</font></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void poll(long timeout) throws IOException &#123;    if (timeout &lt; 0)        throw new IllegalArgumentException(&quot;timeout should be &gt;&#x3D; 0&quot;);    clear();    if (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty())        timeout &#x3D; 0;    &#x2F;* check ready keys *&#x2F;    long startSelect &#x3D; time.nanoseconds();    int readyKeys &#x3D; select(timeout);    long endSelect &#x3D; time.nanoseconds();    currentTimeNanos &#x3D; endSelect;    this.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());    if (readyKeys &gt; 0 || !immediatelyConnectedKeys.isEmpty()) &#123;        pollSelectionKeys(this.nioSelector.selectedKeys(), false);        pollSelectionKeys(immediatelyConnectedKeys, true);    &#125;    addToCompletedReceives();    long endIo &#x3D; time.nanoseconds();    this.sensors.ioTime.record(endIo - endSelect, time.milliseconds());    maybeCloseOldestConnection();&#125;private void pollSelectionKeys(Iterable&lt;SelectionKey&gt; selectionKeys, boolean isImmediatelyConnected) &#123;    Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();    while (iterator.hasNext()) &#123;        SelectionKey key &#x3D; iterator.next();        iterator.remove();        KafkaChannel channel &#x3D; channel(key);            &#x2F;* if channel is ready read from any connections that have readable data *&#x2F;            if (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;                NetworkReceive networkReceive;                while ((networkReceive &#x3D; channel.read()) !&#x3D; null)                    addToStagedReceives(channel, networkReceive);&#125;private void addToStagedReceives(KafkaChannel channel, NetworkReceive receive) &#123;    if (!stagedReceives.containsKey(channel))        stagedReceives.put(channel, new ArrayDeque&lt;NetworkReceive&gt;());    Deque&lt;NetworkReceive&gt; deque &#x3D; stagedReceives.get(channel);    deque.add(receive);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到如果当前channel已经准备好并且SelectionKey已经可以读取并且没有staged receive，那么就把收到的消息缓存到Map&lt;KafkaChannel, Deque<NetworkReceive>&gt; stagedReceives这个里面。然后我们看下后续是怎么处理这些缓存的消息的。<br>上面poll方法处理完了pollSelectionKeys之后，就会调用addToCompletedReceives，从方法名字也可以看出，它是把上面暂存的stagedReceives放进一个List<NetworkReceive> completedReceives里面。<br>下面handleCompletedReceives会用到这个list</NetworkReceive></NetworkReceive></p><p><font color="#08c">NetworkClient</font></p><pre class="line-numbers language-none"><code class="language-none">public List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;    long metadataTimeout &#x3D; metadataUpdater.maybeUpdate(now);    try &#123;        this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));    &#125; catch (IOException e) &#123;        log.error(&quot;Unexpected error during I&#x2F;O&quot;, e);    &#125;    &#x2F;&#x2F; process completed actions    long updatedNow &#x3D; this.time.milliseconds();    List&lt;ClientResponse&gt; responses &#x3D; new ArrayList&lt;&gt;();    handleCompletedSends(responses, updatedNow);    handleCompletedReceives(responses, updatedNow);    handleDisconnections(responses, updatedNow);    handleConnections();    handleTimedOutRequests(responses, updatedNow);    &#x2F;&#x2F; invoke callbacks    for (ClientResponse response : responses) &#123;        if (response.request().hasCallback()) &#123;            try &#123;                response.request().callback().onComplete(response);            &#125; catch (Exception e) &#123;                log.error(&quot;Uncaught error in request completion:&quot;, e);            &#125;        &#125;    &#125;    return responses;&#125;private void handleCompletedReceives(List&lt;ClientResponse&gt; responses, long now) &#123;    for (NetworkReceive receive : this.selector.completedReceives()) &#123;        String source &#x3D; receive.source();        ClientRequest req &#x3D; inFlightRequests.completeNext(source);        Struct body &#x3D; parseResponse(receive.payload(), req.request().header());        if (!metadataUpdater.maybeHandleCompletedReceive(req, now, body))            responses.add(new ClientResponse(req, now, false, body));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上述方法会根据之前获得的List<NetworkReceive> completedReceives组装response，然后调用response.request().callback().onComplete(response);最终会触发Fetcher类sendFetches方法中注册RequestFutureListener的回调onSuccess方法</NetworkReceive></p><pre class="line-numbers language-none"><code class="language-none">public void sendFetches() &#123;    for (Map.Entry&lt;Node, FetchRequest&gt; fetchEntry: createFetchRequests().entrySet()) &#123;        final FetchRequest request &#x3D; fetchEntry.getValue();        client.send(fetchEntry.getKey(), ApiKeys.FETCH, request)                .addListener(new RequestFutureListener&lt;ClientResponse&gt;() &#123;                    @Override                    public void onSuccess(ClientResponse resp) &#123;                        FetchResponse response &#x3D; new FetchResponse(resp.responseBody());                        Set&lt;TopicPartition&gt; partitions &#x3D; new HashSet&lt;&gt;(response.responseData().keySet());                        FetchResponseMetricAggregator metricAggregator &#x3D; new FetchResponseMetricAggregator(sensors, partitions);                        for (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&gt; entry : response.responseData().entrySet()) &#123;                            TopicPartition partition &#x3D; entry.getKey();                            long fetchOffset &#x3D; request.fetchData().get(partition).offset;                            FetchResponse.PartitionData fetchData &#x3D; entry.getValue();                            completedFetches.add(new CompletedFetch(partition, fetchOffset, fetchData, metricAggregator));                        &#125;                        sensors.fetchLatency.record(resp.requestLatencyMs());                        sensors.fetchThrottleTimeSensor.record(response.getThrottleTime());                    &#125;                    @Override                    public void onFailure(RuntimeException e) &#123;                        log.debug(&quot;Fetch failed&quot;, e);                    &#125;                &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到onSuccess回调方法会把record封装后，添加到List<CompletedFetch> completedFetches，之前上面讲到的pollOnce方法会调用<br>fetcher.fetchedRecords()方法，这个方法会根据获得的completedFetches，返回一个封装好的Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; recordMap。</CompletedFetch></p><h2 id="消费获取的record"><a href="#消费获取的record" class="headerlink" title="消费获取的record"></a>消费获取的record</h2><h3 id="配置了自动commit"><a href="#配置了自动commit" class="headerlink" title="配置了自动commit"></a>配置了自动commit</h3><p>回到最开始的KafkaMessageListenerContainer.ListenerConsumer类的run方法</p><pre class="line-numbers language-none"><code class="language-none">ConsumerRecords&lt;K, V&gt; records &#x3D; this.consumer.poll(this.containerProperties.getPollTimeout());if (records !&#x3D; null &amp;&amp; this.logger.isDebugEnabled()) &#123;this.logger.debug(&quot;Received: &quot; + records.count() + &quot; records&quot;);&#125;if (records !&#x3D; null &amp;&amp; records.count() &gt; 0) &#123;if (this.containerProperties.getIdleEventInterval() !&#x3D; null) &#123;    lastReceive &#x3D; System.currentTimeMillis();&#125;if (this.autoCommit) &#123;invokeListener(records);&#125;else &#123;if (sendToListener(records)) &#123;if (this.assignedPartitions !&#x3D; null) &#123;    this.consumer.pause(this.assignedPartitions）;this.paused &#x3D; true;this.unsent &#x3D; records;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到若获取到的records不为空，并且配置了自动commit，则会执行invokeListener(records);</p><pre class="line-numbers language-none"><code class="language-none">private void invokeListener(final ConsumerRecords&lt;K, V&gt; records) &#123;if (this.isBatchListener) &#123;    invokeBatchListener(records);    &#125;else &#123;    invokeRecordListener(records);    &#125;&#125;private void invokeRecordListener(final ConsumerRecords&lt;K, V&gt; records) &#123;    Iterator&lt;ConsumerRecord&lt;K, V&gt;&gt; iterator &#x3D; records.iterator();    while (iterator.hasNext() &amp;&amp; (this.autoCommit || (this.invoker !&#x3D; null &amp;&amp; this.invoker.active))) &#123;        final ConsumerRecord&lt;K, V&gt; record &#x3D; iterator.next();        if (this.logger.isTraceEnabled()) &#123;            this.logger.trace(&quot;Processing &quot; + record);        &#125;        try &#123;            if (this.acknowledgingMessageListener !&#x3D; null) &#123;                this.acknowledgingMessageListener.onMessage(record,                        this.isAnyManualAck                                ? new ConsumerAcknowledgment(record, this.isManualImmediateAck)                                : null);            &#125;            else &#123;                this.listener.onMessage(record);            &#125;            if (!this.isAnyManualAck &amp;&amp; !this.autoCommit) &#123;                this.acks.add(record);            &#125;            if (this.isRecordAck) &#123;                this.consumer.wakeup();            &#125;        &#125;        catch (Exception e) &#123;            if (this.containerProperties.isAckOnError() &amp;&amp; !this.autoCommit) &#123;                this.acks.add(record);            &#125;            try &#123;                this.errorHandler.handle(e, record);            &#125;            catch (Exception ee) &#123;                this.logger.error(&quot;Error handler threw an exception&quot;, ee);            &#125;            catch (Error er) &#123; &#x2F;&#x2F;NOSONAR                this.logger.error(&quot;Error handler threw an error&quot;, er);                throw er;            &#125;        &#125;    &#125;    if (this.isManualAck || this.isBatchAck) &#123;        this.consumer.wakeup();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到最终会调用到this.listener.onMessage(record);<br>这个listnerer就是我们最开始给ContainerProperties设置的MessageListener，这样就调用到了这个listener的onMessage方法，也就回调到了业务逻辑了。可以看到这里就和我们上一篇文章有点比较像了，上一篇文章我们也可以添加发送消息成功后的回调函数，这里也可以看做是一个回调函数用来消费消息。两者都是在发送/接受消息的io线程里面。所以尽量都不能在这里面做一些比较耗时的操作，如果实在需要，建议开启子线程来处理。</p><h3 id="没有配置自动commit"><a href="#没有配置自动commit" class="headerlink" title="没有配置自动commit"></a>没有配置自动commit</h3><p>我们可以看到KafkaMessageListenerContainer.ListenerConsumer的run方法开始，有以下逻辑</p><pre class="line-numbers language-none"><code class="language-none">if (!this.autoCommit) &#123;    startInvoker();&#125;private void startInvoker() &#123;ListenerConsumer.this.invoker &#x3D; new ListenerInvoker();ListenerConsumer.this.listenerInvokerFuture &#x3D;      this.containerProperties.getListenerTaskExecutor().submit(ListenerConsumer.this.invoker);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到如果没有配置自动commit，就会用到了KafkaMessageListenerContainer的doStart方法中设置的listenerTaskExecutor，并开启了一个<font color="#08c">‘-kafka-listener-‘线程</font>。</p><pre class="line-numbers language-none"><code class="language-none">if (this.autoCommit) &#123;invokeListener(records);&#125;else &#123;if (sendToListener(records)) &#123;if (this.assignedPartitions !&#x3D; null) &#123;this.consumer.pause(this.assignedPartitions);this.paused &#x3D; true;this.unsent &#x3D; records;&#125;&#125;&#125;private boolean sendToListener(final ConsumerRecords&lt;K, V&gt; records) throws InterruptedException &#123;if (this.containerProperties.isPauseEnabled() &amp;&amp; CollectionUtils.isEmpty(this.definedPartitions)) &#123;return !this.recordsToProcess.offer(records, this.containerProperties.getPauseAfter(),TimeUnit.MILLISECONDS);&#125;else &#123;this.recordsToProcess.put(records);return false;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到如果不是自动commit，则会把这个record丢进BlockingQueue&lt;ConsumerRecords&lt;K, V&gt;&gt; recordsToProcess 里面，然后上面开启的<font color="#08c">‘-kafka-listener-‘线程</font>会用到这个</p><pre class="line-numbers language-none"><code class="language-none">public void run() &#123;Assert.isTrue(this.active, &quot;This instance is not active anymore&quot;);if (ListenerConsumer.this.theListener instanceof ConsumerSeekAware) &#123;((ConsumerSeekAware) ListenerConsumer.this.theListener).registerSeekCallback(ListenerConsumer.this);&#125;try &#123;this.executingThread &#x3D; Thread.currentThread();while (this.active) &#123;try &#123;ConsumerRecords&lt;K, V&gt; records &#x3D; ListenerConsumer.this.recordsToProcess.poll(1,TimeUnit.SECONDS);if (this.active) &#123;if (records !&#x3D; null) &#123;invokeListener(records);&#125;else &#123;if (ListenerConsumer.this.logger.isTraceEnabled()) &#123;ListenerConsumer.this.logger.trace(&quot;No records to process&quot;);&#125;&#125;&#125;&#125;catch (InterruptedException e) &#123;if (!this.active) &#123;Thread.currentThread().interrupt();&#125;else &#123;ListenerConsumer.this.logger.debug(&quot;Interrupt ignored&quot;);&#125;&#125;if (!ListenerConsumer.this.isManualImmediateAck &amp;&amp; this.active) &#123;ListenerConsumer.this.consumer.wakeup();&#125;&#125;&#125;finally &#123;this.active &#x3D; false;this.exitLatch.countDown();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里先从recordsToProcess取出一条record，如果record不为空，则跟之前一样调用invokeListener(records);所以我们可以理解这个<font color="#08c">‘-kafka-listener-‘线程</font>仅仅是把消息的真正消费的逻辑从consumer的io线程搬到了这个单独的线程。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
            <tag> spring-kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-kafka源码分析一(Producer)</title>
      <link href="2016/12/17/kafkaproducer/"/>
      <url>2016/12/17/kafkaproducer/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/kafkaUml.jpeg" alt="spring kafka uml类图"><br>spring-kafka是运用spring的概念基于apache kafka(linkedin开源已经捐献给apache基金会)消息解决方案开发的一个java client端。它提供了一些接口来更方便收发消息与kafka server端交互，并且支持spring 注解形式。并且我们知道消息是一个异步调用逻辑，我们下文也会分析源码体现出spring kafka怎么实现这个异步的过程。下面我们通过一个demo来分析下spring kafka的源码。</p><span id="more"></span><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws InterruptedException &#123;        ContainerProperties containerProps &#x3D; new ContainerProperties(&quot;topic1&quot;, &quot;topic2&quot;);        containerProps.setMessageListener(new MessageListener&lt;Integer, String&gt;() &#123;            @Override            public void onMessage(ConsumerRecord&lt;Integer, String&gt; message) &#123;                System.out.println(&quot;received: &quot; + message);            &#125;        &#125;);        KafkaMessageListenerContainer&lt;Integer, String&gt; container &#x3D; createContainer(containerProps);        container.setBeanName(&quot;testAuto&quot;);        container.start();---------------------------------------------------------        KafkaTemplate&lt;Integer, String&gt; template &#x3D; createTemplate();        template.setDefaultTopic(&quot;topic1&quot;);        template.sendDefault(0, &quot;foo&quot;);        template.flush();        container.stop();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法被“—-”分割为两部分，上面一部分是从kafka server接受消息的相关配置，下面一部分是发消息给kafka server的配置。本文我们也主要从这两个方面来分析spring-kafka的源码(消息系统理所当然就是收发消息的嘛)</p><h2 id="发消息主线程-调用发送消息的线程"><a href="#发消息主线程-调用发送消息的线程" class="headerlink" title="发消息主线程(调用发送消息的线程)"></a>发消息主线程(调用发送消息的线程)</h2><h3 id="KafkaTemplate"><a href="#KafkaTemplate" class="headerlink" title="KafkaTemplate"></a>KafkaTemplate</h3><p>KafkaTemplate是spring提供给我们用来发送消息的实现类，我们看下怎么创建一个KafkaTemplate</p><pre class="line-numbers language-none"><code class="language-none">KafkaTemplate&lt;Integer, String&gt; template &#x3D; createTemplate();private static KafkaTemplate&lt;Integer, String&gt; createTemplate() &#123;        Map&lt;String, Object&gt; senderProps &#x3D; senderProps();        ProducerFactory&lt;Integer, String&gt; pf &#x3D;                new DefaultKafkaProducerFactory&lt;Integer, String&gt;(senderProps);        KafkaTemplate&lt;Integer, String&gt; template &#x3D; new KafkaTemplate&lt;Integer, String&gt;(pf);        return template;    &#125;private static Map&lt;String, Object&gt; senderProps() &#123;        Map&lt;String, Object&gt; props &#x3D; new HashMap&lt;String, Object&gt;();        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);        props.put(ProducerConfig.RETRIES_CONFIG, 0);        props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);        props.put(ProducerConfig.LINGER_MS_CONFIG, 1);        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class);        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);        return props;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，你首先需要创建一个DefaultKafkaConsumerFactory，而创建<br>DefaultKafkaConsumerFactory需要指定kafka server地址相关的一些配置参数，然后调用KafkaTemplate的构造方法把factory当作参数传进去</p><pre class="line-numbers language-none"><code class="language-none">   public KafkaTemplate(ProducerFactory&lt;K, V&gt; producerFactory)    &#123;this(producerFactory, false);&#125;public KafkaTemplate(ProducerFactory&lt;K, V&gt; producerFactory, boolean autoFlush) &#123;this.producerFactory &#x3D; producerFactory;this.autoFlush &#x3D; autoFlush;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释下autoFlush，默认为false，若设置为true，则代表每次send后自动flush。</p><h3 id="主线程KafkaTemplate-send发消息"><a href="#主线程KafkaTemplate-send发消息" class="headerlink" title="主线程KafkaTemplate.send发消息"></a>主线程KafkaTemplate.send发消息</h3><p>文章开头的main方法中template.sendDefault最终会调用KafkaTemplate.doSend方法。</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, K key, V data) &#123;ProducerRecord&lt;K, V&gt; producerRecord &#x3D; new ProducerRecord&lt;&gt;(topic, key, data);return doSend(producerRecord);&#125;protected ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(final ProducerRecord&lt;K, V&gt; producerRecord) &#123;getTheProducer();  -------------(1)--------------if (this.logger.isTraceEnabled()) &#123;this.logger.trace(&quot;Sending: &quot; + producerRecord);&#125;final SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future &#x3D; new SettableListenableFuture&lt;&gt;();--(2)---getTheProducer().send(producerRecord, new Callback() &#123;@Overridepublic void onCompletion(RecordMetadata metadata, Exception exception) &#123;if (exception &#x3D;&#x3D; null) &#123;future.set(new SendResult&lt;&gt;(producerRecord, metadata));if (KafkaTemplate.this.producerListener !&#x3D; null&amp;&amp; KafkaTemplate.this.producerListener.isInterestedInSuccess()) &#123;KafkaTemplate.this.producerListener.onSuccess(producerRecord.topic(),producerRecord.partition(), producerRecord.key(), producerRecord.value(), metadata);&#125;&#125;else &#123;future.setException(new KafkaProducerException(producerRecord, &quot;Failed to send&quot;, exception));if (KafkaTemplate.this.producerListener !&#x3D; null) &#123;KafkaTemplate.this.producerListener.onError(producerRecord.topic(),producerRecord.partition(), producerRecord.key(), producerRecord.value(), exception);&#125;&#125;&#125;&#125;);if (this.autoFlush) &#123;flush();&#125;if (this.logger.isTraceEnabled()) &#123;this.logger.trace(&quot;Sent: &quot; + producerRecord);&#125;return future;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们下面关注下getTheProducer(),时序图如下<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/kafkaProducer.jpeg" alt="getTheProducer()时序图"></p><p><font color="#08c">KafkaTemplate</font></p><pre class="line-numbers language-none"><code class="language-none">private Producer&lt;K, V&gt; getTheProducer() &#123;if (this.producer &#x3D;&#x3D; null) &#123;synchronized (this) &#123;if (this.producer &#x3D;&#x3D; null) &#123;this.producer &#x3D; this.producerFactory.createProducer();&#125;&#125;&#125;return this.producer;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到KafkaTemplate里面getTheProducer方法会初始化一个KafkaProducer，并且采用了synchronized，保证了只会new一次。我们从KafkaProducer类开头的注释可以看到，KafkaProducer是kafka client端publish record到kafka cluster上的。并且它是线程安全的，并且在多线程环境下共享一个实例比多个实例效率高很多。<br><font color="#08c">另外我们关注到上面时序图最后一步KafkaProducer构造方法会初始化producer相关的参数，比如会初始化一个类似于mesageQueue的RecordAccumulator(这个后面会提到)，并启动一个sender线程，这个线程基本就是kafaka producer的工作io线程(可能大家会想难道producer就靠一个线程，没错，我们等会会讲，它也用到了nio的selector事件循环机制，讲多个kafka server clusters对应的channel都绑定到这个selector上面)。</font></p><h3 id="KafkaProducer-send"><a href="#KafkaProducer-send" class="headerlink" title="KafkaProducer.send"></a>KafkaProducer.send</h3><p>继续看最上面一段代码我们标记的—(2)—getTheProducer().send(x,x)。这个getTheProducer()会返回一个CloseSafeProducer，从本文第一张图可以看到这个类其实有个代理类KafkaProducer。最终会调用到KafkaProducer.doSend(ProducerRecord&lt;K, V&gt; record, Callback callback)方法。</p><pre class="line-numbers language-none"><code class="language-none">private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) &#123;    TopicPartition tp &#x3D; null;    &#x2F;&#x2F; first make sure the metadata for the topic is available    long waitedOnMetadataMs &#x3D; waitOnMetadata(record.topic(), this.maxBlockTimeMs);    long remainingWaitMs &#x3D; Math.max(0, this.maxBlockTimeMs - waitedOnMetadataMs);    byte[] serializedKey;    try &#123;        serializedKey &#x3D; keySerializer.serialize(record.topic(), record.key());    &#125; catch (ClassCastException cce) &#123;        throw new SerializationException(&quot;Can&#39;t convert key of class &quot; + record.key().getClass().getName() +                &quot; to class &quot; + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +                &quot; specified in key.serializer&quot;);    &#125;    byte[] serializedValue;    try &#123;        serializedValue &#x3D; valueSerializer.serialize(record.topic(), record.value());    &#125; catch (ClassCastException cce) &#123;        throw new SerializationException(&quot;Can&#39;t convert value of class &quot; + record.value().getClass().getName() +                &quot; to class &quot; + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +                &quot; specified in value.serializer&quot;);    &#125;    int partition &#x3D; partition(record, serializedKey, serializedValue, metadata.fetch());    int serializedSize &#x3D; Records.LOG_OVERHEAD + Record.recordSize(serializedKey, serializedValue);    ensureValidRecordSize(serializedSize);    tp &#x3D; new TopicPartition(record.topic(), partition);    long timestamp &#x3D; record.timestamp() &#x3D;&#x3D; null ? time.milliseconds() : record.timestamp();    log.trace(&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;, record, callback, record.topic(), partition);    &#x2F;&#x2F; producer callback will make sure to call both &#39;callback&#39; and interceptor callback    Callback interceptCallback &#x3D; this.interceptors &#x3D;&#x3D; null ? callback : new InterceptorCallback&lt;&gt;(callback, this.interceptors, tp);    RecordAccumulator.RecordAppendResult result &#x3D; accumulator.append(tp, timestamp, serializedKey, serializedValue, interceptCallback, remainingWaitMs);    if (result.batchIsFull || result.newBatchCreated) &#123;        log.trace(&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;, record.topic(), partition);        this.sender.wakeup();    &#125;    return result.future;    &#x2F;&#x2F; handling exceptions and record the errors;    &#x2F;&#x2F; for API exceptions return them in the future,    &#x2F;&#x2F; for other exceptions throw directly&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面源码我们可以看到它首先会把消息的key和value都序列化，然后得到要发送到的partition，然后验证消息的长度是否合法，最后会调用到RecordAccumulator.append方法。这个方法会把消息append到这个accumulator，以供producer io子线程发给kafka server。<br><font color="#08c">总结上面的send过程，我们可以看到主线程(调用template.sendDefault线程)并没有把消息真正发送到kafka server，只是把消息累加到一个类似于queue的RecordAccumulator上面。(正因为这样，所以发消息才会很迅速，因为都是操作内存，没有io)我们不难猜测上文我们提到的sender子线程会获取RecordAccumulator上的消息record，然后把消息发给kafka server，这也体现了发送消息确实是一个异步的过程</font></p><h2 id="真正与server交互的线程"><a href="#真正与server交互的线程" class="headerlink" title="真正与server交互的线程"></a>真正与server交互的线程</h2><h3 id="sender线程时序图"><a href="#sender线程时序图" class="headerlink" title="sender线程时序图"></a>sender线程时序图</h3><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/sender.jpeg" alt="kafka producer线程时序图"></p><h3 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h3><p>通过Sender类开头的注释我们可以知道它是真正与kafka server交互的一个后台线程，它会把待发送的消息发给合适的server集群节点。它实现了Runnable接口，来看下它的run方法。</p><pre class="line-numbers language-none"><code class="language-none">public void run() &#123;        log.debug(&quot;Starting Kafka producer I&#x2F;O thread.&quot;);        &#x2F;&#x2F; main loop, runs until close is called        while (running) &#123;            try &#123;                run(time.milliseconds());            &#125; catch (Exception e) &#123;                log.error(&quot;Uncaught error in kafka producer I&#x2F;O thread: &quot;, e);            &#125;        &#125;        log.debug(&quot;Beginning shutdown of Kafka producer I&#x2F;O thread, sending remaining records.&quot;);        &#x2F;&#x2F; okay we stopped accepting requests but there may still be        &#x2F;&#x2F; requests in the accumulator or waiting for acknowledgment,        &#x2F;&#x2F; wait until these are completed.        while (!forceClose &amp;&amp; (this.accumulator.hasUnsent() || this.client.inFlightRequestCount() &gt; 0)) &#123;            try &#123;                run(time.milliseconds());            &#125; catch (Exception e) &#123;                log.error(&quot;Uncaught error in kafka producer I&#x2F;O thread: &quot;, e);            &#125;        &#125;        if (forceClose) &#123;            &#x2F;&#x2F; We need to fail all the incomplete batches and wake up the threads waiting on            &#x2F;&#x2F; the futures.            this.accumulator.abortIncompleteBatches();        &#125;        try &#123;            this.client.close();        &#125; catch (Exception e) &#123;            log.error(&quot;Failed to close network client&quot;, e);        &#125;        log.debug(&quot;Shutdown of Kafka producer I&#x2F;O thread has completed.&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码大致可以分为3部分：</p><ul><li>如果sender线程还处于running状态，则调用run方法发送消息。</li><li>如果sender线程不在running状态，调用者也没有强制close，accumulator中还有待发送的request或者还有等待kafka server返回ack的请求，都会继续调用run方法。</li><li>若sender线程不在running状态，并且已经强制关闭了，则放弃所有还未完成的request</li></ul><p>我们主要分析下第一部分中的run方法</p><pre class="line-numbers language-none"><code class="language-none">void run(long now) &#123;        Cluster cluster &#x3D; metadata.fetch();        &#x2F;&#x2F; get the list of partitions with data ready to send        RecordAccumulator.ReadyCheckResult result &#x3D; this.accumulator.ready(cluster, now);        &#x2F;&#x2F; if there are any partitions whose leaders are not known yet, force metadata update        if (result.unknownLeadersExist)            this.metadata.requestUpdate();        &#x2F;&#x2F; remove any nodes we aren&#39;t ready to send to        Iterator&lt;Node&gt; iter &#x3D; result.readyNodes.iterator();        long notReadyTimeout &#x3D; Long.MAX_VALUE;        while (iter.hasNext()) &#123;            Node node &#x3D; iter.next();            if (!this.client.ready(node, now)) &#123;                iter.remove();                notReadyTimeout &#x3D; Math.min(notReadyTimeout, this.client.connectionDelay(node, now));            &#125;        &#125;        &#x2F;&#x2F; create produce requests        Map&lt;Integer, List&lt;RecordBatch&gt;&gt; batches &#x3D; this.accumulator.drain(cluster,                                                                         result.readyNodes,                                                                         this.maxRequestSize,                                                                         now);        if (guaranteeMessageOrder) &#123;            &#x2F;&#x2F; Mute all the partitions drained            for (List&lt;RecordBatch&gt; batchList : batches.values()) &#123;                for (RecordBatch batch : batchList)                    this.accumulator.mutePartition(batch.topicPartition);            &#125;        &#125;        List&lt;RecordBatch&gt; expiredBatches &#x3D; this.accumulator.abortExpiredBatches(this.requestTimeout, now);        &#x2F;&#x2F; update sensors        for (RecordBatch expiredBatch : expiredBatches)            this.sensors.recordErrors(expiredBatch.topicPartition.topic(), expiredBatch.recordCount);        sensors.updateProduceRequestMetrics(batches);        List&lt;ClientRequest&gt; requests &#x3D; createProduceRequests(batches, now);        &#x2F;&#x2F; If we have any nodes that are ready to send + have sendable data, poll with 0 timeout so this can immediately        &#x2F;&#x2F; loop and try sending more data. Otherwise, the timeout is determined by nodes that have partitions with data        &#x2F;&#x2F; that isn&#39;t yet sendable (e.g. lingering, backing off). Note that this specifically does not include nodes        &#x2F;&#x2F; with sendable data that aren&#39;t ready to send since they would cause busy looping.        long pollTimeout &#x3D; Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);        if (result.readyNodes.size() &gt; 0) &#123;            log.trace(&quot;Nodes with data ready to send: &#123;&#125;&quot;, result.readyNodes);            log.trace(&quot;Created &#123;&#125; produce requests: &#123;&#125;&quot;, requests.size(), requests);            pollTimeout &#x3D; 0;        &#125;        for (ClientRequest request : requests)            client.send(request, now);        &#x2F;&#x2F; if some partitions are already ready to be sent, the select time would be 0;        &#x2F;&#x2F; otherwise if some partition already has some data accumulated but not ready yet,        &#x2F;&#x2F; the select time will be the time difference between now and its linger expiry time;        &#x2F;&#x2F; otherwise the select time will be the time difference between now and the metadata expiry time;        this.client.poll(pollTimeout, now);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看到它先从accumulator(之前template.sendDefault的线程已经把待发的record append到accumulator了)读取待发送的消息信息。考虑到这段代码比较复杂，我们只关注一下两部分:</p><ul><li>怎么与kafka server端建立连接</li><li>向kafka server端发送数据</li></ul><h3 id="与kafka-server端建立连接"><a href="#与kafka-server端建立连接" class="headerlink" title="与kafka server端建立连接"></a>与kafka server端建立连接</h3><p>NetworkClient类</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**     * Initiate a connection to the given node     *&#x2F;    private void initiateConnect(Node node, long now) &#123;        String nodeConnectionId &#x3D; node.idString();        try &#123;            log.debug(&quot;Initiating connection to node &#123;&#125; at &#123;&#125;:&#123;&#125;.&quot;, node.id(), node.host(), node.port());            this.connectionStates.connecting(nodeConnectionId, now);            selector.connect(nodeConnectionId,                             new InetSocketAddress(node.host(), node.port()),                             this.socketSendBuffer,                             this.socketReceiveBuffer);        &#125; catch (IOException e) &#123;            &#x2F;* attempt failed, we&#39;ll try again after the backoff *&#x2F;            connectionStates.disconnected(nodeConnectionId, now);            &#x2F;* maybe the problem is our metadata, update it *&#x2F;            metadataUpdater.requestUpdate();            log.debug(&quot;Error connecting to node &#123;&#125; at &#123;&#125;:&#123;&#125;:&quot;, node.id(), node.host(), node.port(), e);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述这个方法也是在sender子线程里面完成的，它会调用selector.connect方法(这个类是spring-kafka封装的一个类似于nio selector的实现类，它通过持有一个java.nio.channels.Selector成员变量，采用非阻塞事件驱动形式，用来实现非阻塞的连接，发送，接受消息，之前我们再nio源码分析中已经讲到过)，源码如下:</p><pre class="line-numbers language-none"><code class="language-none">public void connect(String id, InetSocketAddress address, int sendBufferSize, int receiveBufferSize) throws IOException &#123;        if (this.channels.containsKey(id))            throw new IllegalStateException(&quot;There is already a connection for id &quot; + id);        SocketChannel socketChannel &#x3D; SocketChannel.open();        socketChannel.configureBlocking(false);        Socket socket &#x3D; socketChannel.socket();        socket.setKeepAlive(true);        if (sendBufferSize !&#x3D; Selectable.USE_DEFAULT_BUFFER_SIZE)            socket.setSendBufferSize(sendBufferSize);        if (receiveBufferSize !&#x3D; Selectable.USE_DEFAULT_BUFFER_SIZE)            socket.setReceiveBufferSize(receiveBufferSize);        socket.setTcpNoDelay(true);        boolean connected;        try &#123;            connected &#x3D; socketChannel.connect(address);        &#125; catch (UnresolvedAddressException e) &#123;            socketChannel.close();            throw new IOException(&quot;Can&#39;t resolve address: &quot; + address, e);        &#125; catch (IOException e) &#123;            socketChannel.close();            throw e;        &#125;        SelectionKey key &#x3D; socketChannel.register(nioSelector, SelectionKey.OP_CONNECT);        KafkaChannel channel &#x3D; channelBuilder.buildChannel(id, key, maxReceiveSize);        key.attach(channel);        this.channels.put(id, channel);        if (connected) &#123;            &#x2F;&#x2F; OP_CONNECT won&#39;t trigger for immediately connected channels            log.debug(&quot;Immediately connected to node &#123;&#125;&quot;, channel.id());            immediatelyConnectedKeys.add(key);            key.interestOps(0);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码我们在之前的博文中<a href="http://yeming.me/2016/02/28/nio/">Nio学习简单理解</a>已经分析过了，首先与kafka serve端建立了一个non blocking 的SocketChannel，然后将该channel注册到一个java.nio.channels.Selector上面，并注册OP_CONNECT事件，可以看到这是很典型的nio selector的用法。</p><h3 id="真正的向kafka-sever发送消息"><a href="#真正的向kafka-sever发送消息" class="headerlink" title="真正的向kafka sever发送消息"></a>真正的向kafka sever发送消息</h3><p>先来看下KafkaChannel类里面的这个方法</p><pre class="line-numbers language-none"><code class="language-none">public void setSend(Send send) &#123;        if (this.send !&#x3D; null)            throw new IllegalStateException(&quot;Attempt to begin a send operation with prior send operation still in progress.&quot;);        this.send &#x3D; send;        this.transportLayer.addInterestOps(SelectionKey.OP_WRITE);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这里又注册了OP_WRITE事件。</p><p>然后我们再回到之前的sender run(long time)方法，看下这个方法最后一部分</p><pre class="line-numbers language-none"><code class="language-none"> for (ClientRequest request : requests)            client.send(request, now);        &#x2F;&#x2F; if some partitions are already ready to be sent, the select time would be 0;        &#x2F;&#x2F; otherwise if some partition already has some data accumulated but not ready yet,        &#x2F;&#x2F; the select time will be the time difference between now and its linger expiry time;        &#x2F;&#x2F; otherwise the select time will be the time difference between now and the metadata expiry time;this.client.poll(pollTimeout, now);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它先把待发给kafka server的request放进queue里面(client.send方法)，然后调用client.poll方法</p><pre class="line-numbers language-none"><code class="language-none">public List&lt;ClientResponse&gt; poll(long timeout, long now) &#123;        long metadataTimeout &#x3D; metadataUpdater.maybeUpdate(now);        try &#123;            this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));        &#125; catch (IOException e) &#123;            log.error(&quot;Unexpected error during I&#x2F;O&quot;, e);        &#125;        &#x2F;&#x2F; process completed actions        long updatedNow &#x3D; this.time.milliseconds();        List&lt;ClientResponse&gt; responses &#x3D; new ArrayList&lt;&gt;();        handleCompletedSends(responses, updatedNow);        handleCompletedReceives(responses, updatedNow);        handleDisconnections(responses, updatedNow);        handleConnections();        handleTimedOutRequests(responses, updatedNow);        &#x2F;&#x2F; invoke callbacks        for (ClientResponse response : responses) &#123;            if (response.request().hasCallback()) &#123;                try &#123;                    response.request().callback().onComplete(response);                &#125; catch (Exception e) &#123;                    log.error(&quot;Uncaught error in request completion:&quot;, e);                &#125;            &#125;        &#125;        return responses;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法又会调用this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs))方法，并且会调用回调函数，这里我们先来讲解一下回调</p><pre class="line-numbers language-none"><code class="language-none">ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future &#x3D; template.sendDefault(0, &quot;foo&quot;);        future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() &#123;            @Override            public void onSuccess(SendResult&lt;Integer, String&gt; result) &#123;                System.out.println(&quot;xiaoming send success&quot;);            &#125;            @Override            public void onFailure(Throwable ex) &#123;            &#125;        &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最早发送消息template.sendDefault方法会返回一个ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; future参数，如果你对发送消息的结果(是否发送成功)之类的感兴趣，当然你可以直接调用future.get，但是这是个阻塞方法，会阻塞当前线程。所以你可以像上面一样future.addCallback添加一个回调参数。<br>最终这个response.request().callback().onComplete(response)就会调用这个回调函数(具体这个回调是怎么实现的我这里就不展开了)。<br><font color="#08c">所以这个回调函数显示不是发生在template.sendDefault的线程里面，它是在kafka producer的工作io线程中，也就是nio eventloop那个事件循环的线程中，所以我们这个回调函数里面最好不要直接进行一些耗时的操作，这样会影响整个producer的工作。实在要进行耗时操作，可以启动一个子线程来完成</font></p><p>然后我们回到this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs))这个方法。这个方法最终会调用到Selector.pollSelectionKeys方法</p><pre class="line-numbers language-none"><code class="language-none">private void pollSelectionKeys(Iterable&lt;SelectionKey&gt; selectionKeys, boolean isImmediatelyConnected) &#123;        Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();        while (iterator.hasNext()) &#123;            SelectionKey key &#x3D; iterator.next();            iterator.remove();            KafkaChannel channel &#x3D; channel(key);            &#x2F;&#x2F; register all per-connection metrics at once            sensors.maybeRegisterConnectionMetrics(channel.id());            lruConnections.put(channel.id(), currentTimeNanos);            try &#123;                &#x2F;* complete any connections that have finished their handshake (either normally or immediately) *&#x2F;                if (isImmediatelyConnected || key.isConnectable()) &#123;                    if (channel.finishConnect()) &#123;                        this.connected.add(channel.id());                        this.sensors.connectionCreated.record();                    &#125; else                        continue;                &#125;                &#x2F;* if channel is not ready finish prepare *&#x2F;                if (channel.isConnected() &amp;&amp; !channel.ready())                    channel.prepare();                &#x2F;* if channel is ready read from any connections that have readable data *&#x2F;                if (channel.ready() &amp;&amp; key.isReadable() &amp;&amp; !hasStagedReceive(channel)) &#123;                    NetworkReceive networkReceive;                    while ((networkReceive &#x3D; channel.read()) !&#x3D; null)                        addToStagedReceives(channel, networkReceive);                &#125;                &#x2F;* if channel is ready write to any sockets that have space in their buffer and for which we have data *&#x2F;                if (channel.ready() &amp;&amp; key.isWritable()) &#123;                    Send send &#x3D; channel.write();                    if (send !&#x3D; null) &#123;                        this.completedSends.add(send);                        this.sensors.recordBytesSent(channel.id(), send.size());                    &#125;                &#125;                &#x2F;* cancel any defunct sockets *&#x2F;                if (!key.isValid()) &#123;                    close(channel);                    this.disconnected.add(channel.id());                &#125;            &#125; catch (Exception e) &#123;                String desc &#x3D; channel.socketDescription();                if (e instanceof IOException)                    log.debug(&quot;Connection with &#123;&#125; disconnected&quot;, desc, e);                else                    log.warn(&quot;Unexpected error from &#123;&#125;; closing connection&quot;, desc, e);                close(channel);                this.disconnected.add(channel.id());            &#125;        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这个方法的名字就能看到这里是找到之前注册的OP_CONNECT，OP_WRITE，OP_READ(后面接受消息会讲)这些事件已经就绪的事件，然后调用相应方法来处理。对于发送消息，就是想上面那样，如果channel.ready() &amp;&amp; key.isWritable()那么就调用Send send = channel.write()</p><pre class="line-numbers language-none"><code class="language-none">public Send write() throws IOException &#123;        Send result &#x3D; null;        if (send !&#x3D; null &amp;&amp; send(send)) &#123;            result &#x3D; send;            send &#x3D; null;        &#125;        return result;    &#125;private boolean send(Send send) throws IOException &#123;        send.writeTo(transportLayer);        if (send.completed())            transportLayer.removeInterestOps(SelectionKey.OP_WRITE);        return send.completed();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>真正向socker写数据，写完必须删除OP_WRITE事件，不然会造成空循环，这个我们之前nio那篇文章中也已经讲过。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
            <tag> spring-kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-eureka源码分析二(server端)</title>
      <link href="2016/12/02/eureka2/"/>
      <url>2016/12/02/eureka2/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章我们介绍了eureka client的工作模式，我们知道eureka client是通过http rest来与eureka server交互，来注册服务，续约服务，取消服务，服务查询。所以，eureka server肯定要提供上述http的服务端实现，这也是我们本篇文章研究eureka server的一个切入点。另外我们还要关注下，server是怎么剔除一些长时间没有发送心跳的client端，server集群之间是怎么replicate的也是我们需要关注的一个重点。</p><span id="more"></span><h2 id="server端提供的rest接口"><a href="#server端提供的rest接口" class="headerlink" title="server端提供的rest接口"></a>server端提供的rest接口</h2><p>server端提供给client端的rest接口主要包括注册服务，续约服务，取消服务，获取服务，下面我们会一个接一个的看下server端是什么实现这些接口的</p><h3 id="server端启动注册rest接口"><a href="#server端启动注册rest接口" class="headerlink" title="server端启动注册rest接口"></a>server端启动注册rest接口</h3><p>我们看下server端启动源码</p><pre class="line-numbers language-none"><code class="language-none">@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServerApplication.class, args);    &#125;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(EurekaServerConfiguration.class)public @interface EnableEurekaServer &#123;&#125;@Configuration@Import(EurekaServerInitializerConfiguration.class)@EnableDiscoveryClient@EnableConfigurationProperties(EurekaDashboardProperties.class)@PropertySource(&quot;classpath:&#x2F;eureka&#x2F;server.properties&quot;)public class EurekaServerConfiguration extends WebMvcConfigurerAdapter &#123;&#x2F;** * Register the Jersey filter *&#x2F;@Beanpublic FilterRegistrationBean jerseyFilterRegistration(javax.ws.rs.core.Application eurekaJerseyApp) &#123;FilterRegistrationBean bean &#x3D; new FilterRegistrationBean();bean.setFilter(new ServletContainer(eurekaJerseyApp));bean.setOrder(Ordered.LOWEST_PRECEDENCE);bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + &quot;&#x2F;*&quot;));return bean;&#125;&#x2F;** * Construct a Jersey &#123;@link javax.ws.rs.core.Application&#125; with all the resources * required by the Eureka server. *&#x2F;@Beanpublic javax.ws.rs.core.Application jerseyApplication(Environment environment,ResourceLoader resourceLoader) &#123;ClassPathScanningCandidateComponentProvider provider &#x3D; new ClassPathScanningCandidateComponentProvider(false, environment);&#x2F;&#x2F; Filter to include only classes that have a particular annotation.&#x2F;&#x2F;provider.addIncludeFilter(new AnnotationTypeFilter(Path.class));provider.addIncludeFilter(new AnnotationTypeFilter(Provider.class));&#x2F;&#x2F; Find classes in Eureka packages (or subpackages)&#x2F;&#x2F;Set&lt;Class&lt;?&gt;&gt; classes &#x3D; new HashSet&lt;Class&lt;?&gt;&gt;();for (String basePackage : EUREKA_PACKAGES) &#123;Set&lt;BeanDefinition&gt; beans &#x3D; provider.findCandidateComponents(basePackage);for (BeanDefinition bd : beans) &#123;Class&lt;?&gt; cls &#x3D; ClassUtils.resolveClassName(bd.getBeanClassName(),resourceLoader.getClassLoader());classes.add(cls);&#125;&#125;&#x2F;&#x2F; Construct the Jersey ResourceConfig&#x2F;&#x2F;Map&lt;String, Object&gt; propsAndFeatures &#x3D; new HashMap&lt;String, Object&gt;();propsAndFeatures.put(&#x2F;&#x2F; Skip static content used by the webappServletContainer.PROPERTY_WEB_PAGE_CONTENT_REGEX,EurekaConstants.DEFAULT_PREFIX + &quot;&#x2F;(fonts|images|css|js)&#x2F;.*&quot;);DefaultResourceConfig rc &#x3D; new DefaultResourceConfig(classes);rc.setPropertiesAndFeatures(propsAndFeatures);return rc;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和client端启动一样，重点关注<font color="#08c">@EnableEurekaServer</font>，这个注解import了EurekaServerConfiguration配置类。EurekaServerConfiguration这个配置类有两个方法，jerseyFilterRegistration方法用来注册jersey fliter，jerseyApplication方法会加载下面这个类<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_1.jpeg" alt="jersery resources"><br>之列resources类可以理解成spring mvc中的controller，用来接收client端的rest请求的，下面就逐个分析这些rest请求。</p><h3 id="注册服务-register"><a href="#注册服务-register" class="headerlink" title="注册服务(register)"></a>注册服务(register)</h3><p>时序图如下：<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_2.jpeg" alt="注册服务时序图"></p><p>可以看到ApplicationResource接收到client端的注册请求后，调用PeerAwareInstanceRegistryImpl的register方法，该方法先调用父类register方法将client端传过来的实例注册到自身，然后再同步给其他节点</p><pre class="line-numbers language-none"><code class="language-none">@Override    public void register(final InstanceInfo info, final boolean isReplication) &#123;        ......        super.register(info, leaseDuration, isReplication);        replicateToPeers(Action.Register, info.getAppName(),   info.getId(), info, null, isReplication);    &#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AbstractInstanceRegistry的register方法是注册服务的真正实现，具体源码不看了，主要是通过各种锁(ReentrantReadWriteLock,synchronized)来获取待注册实例，然后保存到一个二维map<br>第一层map的key是应用的名称(appName)，value是该应用下面所有实例组成的一个map。(比如user这个应用，生产环境肯定有多台user应用)<br>第二层map的key是单个应用的实例id(全集群唯一确定)，value是应用info</p><p>然后看下replicateToPeers这个方法，这个方法在以下几个条件，就提前return:</p><ul><li>集群中没有其他server，显然不需要replicate</li><li>轮训出来的节点是自身，显然也不需要通知自己</li><li>isReplication为true，首先我们要清楚，client发起rest请求只会到一台server上，client发出的rest请求header里面isReplication为false，所以接收到client请求的某台server就会把这个信息同步给其他其他server，也是调用相同的rest接口请求其他server，只不过此时会把hader参数isReplication设置为true，就可以避免通知已经注册过的节点</li></ul><pre class="line-numbers language-none"><code class="language-none">private void replicateToPeers(Action action, String appName, String id,InstanceInfo info &#x2F;* optional *&#x2F;,InstanceStatus newStatus &#x2F;* optional *&#x2F;, boolean isReplication) &#123;        Stopwatch tracer &#x3D; action.getTimer().start();        try &#123;            if (isReplication) &#123;                numberOfReplicationsLastMin.increment();            &#125;            if (peerEurekaNodes &#x3D;&#x3D; Collections.EMPTY_LIST || isReplication) &#123;                return;            &#125;            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;                if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;                    continue;                &#125;                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);            &#125;        &#125; finally &#123;            tracer.stop();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="续约服务-renew"><a href="#续约服务-renew" class="headerlink" title="续约服务(renew)"></a>续约服务(renew)</h3><p>同上面注册服务过程基本一样，直接画出时序图<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_3.jpeg" alt="renew"></p><h3 id="取消服务-cancel"><a href="#取消服务-cancel" class="headerlink" title="取消服务(cancel)"></a>取消服务(cancel)</h3><p>同上面注册服务过程基本一样，直接画出时序图<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_4.jpeg" alt="renew"></p><h3 id="服务列表查询-fetch-registry"><a href="#服务列表查询-fetch-registry" class="headerlink" title="服务列表查询(fetch registry)"></a>服务列表查询(fetch registry)</h3><p>比较简单，直接画出时序图<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_5.jpeg" alt="renew"></p><h2 id="定时任务剔除失效服务-Eviction"><a href="#定时任务剔除失效服务-Eviction" class="headerlink" title="定时任务剔除失效服务(Eviction)"></a>定时任务剔除失效服务(Eviction)</h2><p>时序图如下：<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_7.jpeg" alt="Eviction"></p><p>Eviction（失效服务剔除）用来定期在Eureka Server检测失效的服务，检测标准就是超过一定时间没有Renew的服务。</p><p>默认失效时间为90秒，也就是如果有服务超过90秒没有向Eureka Server发起Renew请求的话，就会被当做失效服务剔除掉。</p><p>失效时间可以通过eureka.instance.leaseExpirationDurationInSeconds进行配置，默认90s(这个时间设置太大的话，有可能客户端会获得已经失效的服务，设置太小的话，由于网络原因，客户端心跳没有及时发过来导致被剔除。这个时间最少应该设置大于客户端心跳发送的时间)定期扫描时间可以通过eureka.server.evictionIntervalTimerInMs进行配置，默认60s。</p><h2 id="新server加入server集群"><a href="#新server加入server集群" class="headerlink" title="新server加入server集群"></a>新server加入server集群</h2><p>最后再来看一下一个新的Eureka Server节点加进来，或者Eureka Server重启后，如何来做初始化，从而能够正常提供服务，整体时序图如下：<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_server_6.jpeg" alt="新server"></p><pre class="line-numbers language-none"><code class="language-none">@Path(&quot;batch&quot;)@POSTpublic Response batchReplication(ReplicationList replicationList) &#123;    for (ReplicationInstance instanceInfo :  replicationList.getReplicationList()) &#123;         batchResponse.addResponse(dispatch(instanceInfo));    &#125;&#125;private ReplicationInstanceResponse dispatch(ReplicationInstance instanceInfo) &#123;        switch (instanceInfo.getAction()) &#123;            case Register:                singleResponseBuilder &#x3D; handleRegister(instanceInfo, applicationResource);                break;            case Heartbeat:                singleResponseBuilder &#x3D; handleHeartbeat(resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);                break;            case Cancel:                singleResponseBuilder &#x3D; handleCancel(resource);                break;            case StatusUpdate:                singleResponseBuilder &#x3D; handleStatusUpdate(instanceInfo, resource);                break;            case DeleteStatusOverride:                singleResponseBuilder &#x3D; handleDeleteStatusOverride(instanceInfo, resource);                break;        &#125;        return singleResponseBuilder.build();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面PeerReplicationResource这个类作为一个jersey resource会定时接收其他server同步过来的信息(debug调试可以知道包括其他server，或者client端的Register，Heartbeat，Cancel，StatusUpdate，DeleteStatusUpdate)，然后调用dispatch方法，根据不同类型处理不同的事件。所以新的server一启动，其他server就会把已经注册的服务实例传送过来，然后对每一个实例调用上面的服务注册(register)方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-eureka源码分析一(client端)</title>
      <link href="2016/12/01/eureka1/"/>
      <url>2016/12/01/eureka1/</url>
      
        <content type="html"><![CDATA[<h2 id="what-is-eureka"><a href="#what-is-eureka" class="headerlink" title="what is eureka"></a>what is eureka</h2><p>先介绍下eureka是什么玩意。eureka是netflix公司开源的一款基于REST的服务自动注册和发现的产品，并且提供了java客户端给eureka client端更好的与eureka server交互。另外不得不提一下netflix这个公司，这是一家在线影片租赁商，开源了很多java的产品，其中很多产品都被收入进了spring cloud项目里面。除了上面说的eureka，还有处理熔断的hystrix，提供客户端负载均衡的ribbon，无线网关的zuul等等。下面先看一下eureka的整体架构图<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/1.jpeg" alt="eureka架构图"></p><span id="more"></span><p>可以看到eueka按逻辑上可以划分为3个模块，eureka-server，eureka-client-service-provider，eureka-client-service-consumer。</p><ul><li>eureka-server：服务端，提供服务注册和发现</li><li>eureka-client-service-provider：客户端，服务提供者，通过http rest告知服务端注册，更新，取消服务</li><li>eureka-client-service-consumer：客户端，服务消费者，通过http rest从服务端获取需要服务的地址列表，然后配合一些负载均衡策略（ribbon）来调用服务端服务。</li></ul><p>值得注意的一点，不同于其他服务注册与发现(zookeeper，dubbo等其他产品需要单独以中间件的形式部署集群server)，以上3个角色都是逻辑角色，甚至可以在相同的jvm进程上。@EnableDiscoveryClient注解从字面意思就可以猜到这个和服务注册发现有关，下面我们就来看下源码。</p><h2 id="client应用启动"><a href="#client应用启动" class="headerlink" title="client应用启动"></a>client应用启动</h2><p>下面是基于spring cloud的eureka的client端启动代码</p><pre class="line-numbers language-none"><code class="language-none">@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaProviderApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaProviderApplication.class,            args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到基于spring boot的启动配置相当简单,这里不详细介绍spring boot了，只需知道@SpringBootApplication这个注解开启了spring boot的组件扫描和自动配置功能，SpringApplication.run方法负责启动引导应用程序。</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(EnableDiscoveryClientImportSelector.class)public @interface EnableDiscoveryClient &#123;&#125;@Order(Ordered.LOWEST_PRECEDENCE - 100)public class EnableDiscoveryClientImportSelectorextends SpringFactoryImportSelector&lt;EnableDiscoveryClient&gt; &#123;.......&#125;@CommonsLogpublic abstract class SpringFactoryImportSelector&lt;T&gt;implements DeferredImportSelector, BeanClassLoaderAware, EnvironmentAware &#123;@Overridepublic String[] selectImports(AnnotationMetadata metadata)&#123;最终返回一个[&quot;org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration&quot;]一元数组&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实从这个注解EnableDiscoveryClient也不难看出最终会注入DiscoveryClient，这个调用过程链异常复杂，有兴趣的可以自己debug看下调用方法堆栈。</p><h2 id="spring-cloud-DiscoveryClient"><a href="#spring-cloud-DiscoveryClient" class="headerlink" title="spring cloud DiscoveryClient"></a>spring cloud DiscoveryClient</h2><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_2.jpeg"></p><p>其中左边的<font color="#e96900">org.springframework.cloud.client.discovery.DiscoveryClient</font>是spring cloud定义的接口，它定义了发现服务的抽象方法。<br>下面的<font color="#e96900">EurekaDiscoveryClient</font>是它的实现类。<br>右边的<font color="#e96900">LookupService</font>是netflix开源的发现服务的接口。<br>最终实现是<font color="#e96900">com.netflix.discovery.DiscoveryClient</font>。</p><p>大家可以发现中间有个1：1的线把左右两个部分关联起来了，我们如果仔细研究spring cloud的一些源码，可以发现很多这种设计模式。spring cloud自己包装了很多wrapper类，最终实现其实都是那些开源产品自己的类。大家看下面的EurekaDiscoveryClient的源码就知道了</p><pre class="line-numbers language-none"><code class="language-none">    public class EurekaDiscoveryClient implements DiscoveryClient &#123;public static final String DESCRIPTION &#x3D; &quot;Spring Cloud Eureka Discovery Client&quot;;private final EurekaInstanceConfig config;private final EurekaClient eurekaClient;@Overridepublic List&lt;ServiceInstance&gt; getInstances(String serviceId) &#123;List&lt;InstanceInfo&gt; infos &#x3D; this.eurekaClient.getInstancesByVipAddress(serviceId,false);List&lt;ServiceInstance&gt; instances &#x3D; new ArrayList&lt;&gt;();for (InstanceInfo info : infos) &#123;instances.add(new EurekaServiceInstance(info));&#125;return instances;&#125;@Overridepublic List&lt;String&gt; getServices() &#123;Applications applications &#x3D; this.eurekaClient.getApplications();if (applications &#x3D;&#x3D; null) &#123;return Collections.emptyList();&#125;List&lt;Application&gt; registered &#x3D; applications.getRegisteredApplications();List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();for (Application app : registered) &#123;if (app.getInstances().isEmpty()) &#123;continue;&#125;names.add(app.getName().toLowerCase());&#125;return names;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然EurekaDiscoveryClient获取服务最终会通过它的成员变量private final EurekaClient eurekaClient(也就是那条线右边的接口)来真正的调用服务端接口获取服务。</p><h2 id="netflix-DiscoveryClient"><a href="#netflix-DiscoveryClient" class="headerlink" title="netflix DiscoveryClient"></a>netflix DiscoveryClient</h2><p>先看下DiscoveryClient的构造方法</p><pre class="line-numbers language-none"><code class="language-none">@Inject    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, DiscoveryClientOptionalArgs args,                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;        ......        try &#123;            scheduler &#x3D; Executors.newScheduledThreadPool(3,                    new ThreadFactoryBuilder()                            .setNameFormat(&quot;DiscoveryClient-%d&quot;)                            .setDaemon(true)                            .build());            heartbeatExecutor &#x3D; new ThreadPoolExecutor(                    1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,                    new SynchronousQueue&lt;Runnable&gt;(),                    new ThreadFactoryBuilder()                            .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;)                            .setDaemon(true)                            .build()            );  &#x2F;&#x2F; use direct handoff            cacheRefreshExecutor &#x3D; new ThreadPoolExecutor(                    1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,                    new SynchronousQueue&lt;Runnable&gt;(),                    new ThreadFactoryBuilder()                            .setNameFormat(&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;)                            .setDaemon(true)                            .build()            );  &#x2F;&#x2F; use direct handoff            eurekaTransport &#x3D; new EurekaTransport();            scheduleServerEndpointTask(eurekaTransport, args);            if (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(false)) &#123;            fetchRegistryFromBackup();        &#125;            initScheduledTasks();        try &#123;            Monitors.registerObject(this);        &#125; catch (Throwable e) &#123;            logger.warn(&quot;Cannot register timers&quot;, e);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个构造方法里面，主要做了下面几件事</p><ul><li>创建了scheduler定时任务的线程池，heartbeatExecutor心跳检查线程池(<font color="#e96900">服务续约</font>)，cacheRefreshExecutor(<font color="#e96900">服务获取</font>)</li><li>然后initScheduledTasks()开启上面三个线程池，往上面3个线程池分别添加相应任务。然后创建了一个instanceInfoReplicator(Runnable任务)，然后调用InstanceInfoReplicator.start方法，把这个任务放进上面scheduler定时任务线程池(<font color="#e96900">服务注册并更新</font>)。</li></ul><h2 id="服务注册-Registry"><a href="#服务注册-Registry" class="headerlink" title="服务注册(Registry)"></a>服务注册(Registry)</h2><p>上面说了，initScheduledTasks()方法中调用了InstanceInfoReplicator.start()方法，下面看下InstanceInfoReplicator源码</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * A task for updating and replicating the local instanceinfo to the remote server. Properties of this task are: * - configured with a single update thread to guarantee sequential update to the remote server * - update tasks can be scheduled on-demand via onDemandUpdate() * - task processing is rate limited by burstSize * - a new update task is always scheduled automatically after an earlier update task. However if an on-demand task *   is started, the scheduled automatic update task is discarded (and a new one will be scheduled after the new *   on-demand update). * *   @author dliu *&#x2F;class InstanceInfoReplicator implements Runnable &#123;    public void start(int initialDelayMs) &#123;        if (started.compareAndSet(false, true)) &#123;            instanceInfo.setIsDirty();  &#x2F;&#x2F; for initial register            Future next &#x3D; scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS);            scheduledPeriodicRef.set(next);        &#125;    &#125;    public void stop() &#123;        scheduler.shutdownNow();        started.set(false);    &#125;    public boolean onDemandUpdate() &#123;        if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123;            scheduler.submit(new Runnable() &#123;                @Override                public void run() &#123;                    logger.debug(&quot;Executing on-demand update of local InstanceInfo&quot;);                    Future latestPeriodic &#x3D; scheduledPeriodicRef.get();                    if (latestPeriodic !&#x3D; null &amp;&amp; !latestPeriodic.isDone()) &#123;                        logger.debug(&quot;Canceling the latest scheduled update, it will be rescheduled at the end of on demand update&quot;);                        latestPeriodic.cancel(false);                    &#125;                    InstanceInfoReplicator.this.run();                &#125;            &#125;);            return true;        &#125; else &#123;            logger.warn(&quot;Ignoring onDemand update due to rate limiter&quot;);            return false;        &#125;    &#125;    public void run() &#123;        try &#123;            discoveryClient.refreshInstanceInfo();            Long dirtyTimestamp &#x3D; instanceInfo.isDirtyWithTime();            if (dirtyTimestamp !&#x3D; null) &#123;                discoveryClient.register();                instanceInfo.unsetIsDirty(dirtyTimestamp);            &#125;        &#125; catch (Throwable t) &#123;            logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);        &#125; finally &#123;            Future next &#x3D; scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);            scheduledPeriodicRef.set(next);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码和类的注释可以看到，这个Runnable类用来注册和更新接口，被放在了一个单线程定时任务线程池中连续不断运行。除非应用状态listener监听到应用状态发生变化，会主动调用instanceInfoReplicator.onDemandUpdate();</p><pre class="line-numbers language-none"><code class="language-none">statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;    @Override    public String getId() &#123;        return &quot;statusChangeListener&quot;;    &#125;    @Override    public void notify(StatusChangeEvent s)&#123;        instanceInfoReplicator.onDemandUpdate();    &#125;&#125;;if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;    applicationInfoManager.registerStatusChangeListener(statusChangeListener);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着上面InstanceInfoReplicator的run方法，run方法中会调用DiscoveryClient的register方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**     * Register with the eureka service by making the appropriate REST call.     *&#x2F;    boolean register() throws Throwable &#123;        EurekaHttpResponse&lt;Void&gt; httpResponse;        try &#123;            httpResponse &#x3D; eurekaTransport.registrationClient.register(instanceInfo);        &#125; catch (Exception e) &#123;            logger.warn(&quot;&#123;&#125; - registration failed &#123;&#125;&quot;, PREFIX + appPathIdentifier, e.getMessage(), e);            throw e;        &#125;        if (logger.isInfoEnabled()) &#123;            logger.info(&quot;&#123;&#125; - registration status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());        &#125;        return httpResponse.getStatusCode() &#x3D;&#x3D; 204;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终又经过一系列调用，最终会调用到AbstractJerseyEurekaHttpClient的register方法</p><pre class="line-numbers language-none"><code class="language-none">public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123;    String urlPath &#x3D; &quot;apps&#x2F;&quot; + info.getAppName();    ClientResponse response &#x3D; null;    try &#123;        Builder resourceBuilder &#x3D; jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();        addExtraHeaders(resourceBuilder);        response &#x3D; resourceBuilder                .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)                .type(MediaType.APPLICATION_JSON_TYPE)                .accept(MediaType.APPLICATION_JSON)                .post(ClientResponse.class, info);        return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();    &#125; finally &#123;        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;Jersey HTTP POST &#123;&#125;&#x2F;&#123;&#125; with instance &#123;&#125;; statusCode&#x3D;&#123;&#125;&quot;, serviceUrl, urlPath, info.getId(),                    response &#x3D;&#x3D; null ? &quot;N&#x2F;A&quot; : response.getStatus());        &#125;        if (response !&#x3D; null) &#123;            response.close();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到最终通过http rest请求eureka server端，把应用自身的InstanceInfo实例注册给server端，我们再来完整梳理一下服务注册流程。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_3.jpeg" alt="register流程"></p><h2 id="服务续约renew"><a href="#服务续约renew" class="headerlink" title="服务续约renew"></a>服务续约renew</h2><p>大致过程和上面类似，不再分析源码，直接画出时序图<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_4.jpeg" alt="renew"></p><h2 id="服务下线cancel"><a href="#服务下线cancel" class="headerlink" title="服务下线cancel"></a>服务下线cancel</h2><p>在服务shutdown的时候，需要及时通知服务端把自己剔除，以避免客户端调用已经下线的服务<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_6.jpeg" alt="cancel"></p><h2 id="定时更新已经注册服务的地址fetchRegistry"><a href="#定时更新已经注册服务的地址fetchRegistry" class="headerlink" title="定时更新已经注册服务的地址fetchRegistry"></a>定时更新已经注册服务的地址fetchRegistry</h2><p>客户端会定时每隔一段时间获取远程服务地址，然后更新本地缓存<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_5.jpeg" alt="fetchRegistry"></p><h2 id="定时更新eureka-server的地址"><a href="#定时更新eureka-server的地址" class="headerlink" title="定时更新eureka server的地址"></a>定时更新eureka server的地址</h2><p>上面可以看到不管是client-service-provider，client-service-consumer都是通过http rest来与eureka-server端交互的，所以那么client端是怎么获取server端的地址的呢？默认是从配置文件里面取得，如果需要更灵活的控制，可以通过override getEurekaServerServiceUrls方法来提供自己的实现。定期更新频率可以通过eureka.client.eurekaServiceUrlPollIntervalSeconds配置<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201612/eureka_7.jpeg" alt="定时更新eureka server地址"></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
            <tag> eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs简介</title>
      <link href="2016/07/03/nodejs/"/>
      <url>2016/07/03/nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Nodejs是一个为实时web应用开发而诞生的平台，它从诞生之初就考虑了在实时响应，超大规模数据要求下架构的可扩展性。它摒弃了传统平台依靠多线程来实现高并发，采用了单线程、异步式io、事件驱动式的程序设计模型(听起来是不是感觉很高大上😂)</p><span id="more"></span><h3 id="异步式io和事件驱动"><a href="#异步式io和事件驱动" class="headerlink" title="异步式io和事件驱动"></a>异步式io和事件驱动</h3><p>Nodejs最大的特定就是采用了异步式io和事件驱动的架构设计。他使用了单线程模型，对于所有的io都采用异步请求，避免了频繁的上下文切换，避免浪费大量内存资源，也可以避免遭受低速连接攻击。<br>例如，对于传统的数据查询：</p><pre class="line-numbers language-none"><code class="language-none">res &#x3D; db.query(&#39;select * from table&#39;);res.output();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上代码之行到第一行时候线程会阻塞，等待数据库查询完成后才会返回。<br>而nodejs采用下面方法来解决这个问题：</p><pre class="line-numbers language-none"><code class="language-none">db.query(&#39;select * from table&#39;, function(res)&#123;res.output();&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进程在执行到 db.query的时候,不会等待结果返回,而是直接继续执行后面的语句,直到进入事件循环。 当数据库查询结果返回时,会将事件发送到事件队列,等到线程进入事件循环以后,才会调 用之前的回调函数继续执行后面的逻辑</p><h3 id="nodejs的性能"><a href="#nodejs的性能" class="headerlink" title="nodejs的性能"></a>nodejs的性能</h3><p>nodejs使用异步io和事件驱动代替多线程，带来了可观的性能提升，nodejs除了使用V8作为javascript引擎以外，还使用了高效的libev和libeio库支持事件驱动和异步式io。nodejs开发者在libev和libeio的基础上抽象出了libuv。对于POISX系统（LINUX,UNIX,MAC OS X）libuv通过封装libev和libeio来利用epoll和kqueue。而在windows下，libuv使用了windows的IOCP机制。</p><h2 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h2><p>nodejs由于采用了事件和异步io机制，所以很适合那些高并发的io密集型的应用。</p><ul><li>RESTful API: nodejs采用事件和异步io机制，可以处理大量客户端连接，本身没有复杂业务逻辑，本质都是查询数据库获取数据来组装响应给客户端。</li><li>统一WEB应用的UI层: 目前的mvc架构，在某种意义上说，有2个ui层，一个是在浏览器我们最终看到的，另一个是我们在server端，负责生成和拼接页面。先不说这种架构好坏与否，如果我们引入nodejs。这样后端人员可以最小粒度的开发各种RESTful 接口，前端人员通过nodejs来调用这些api，后端人员只需提供api，不需要关心数据如何从一个页面传递到另一个页面，也不需要关心用户数据更新是通过ajax还是刷新页面。这样就真正实现了前后端的分离。</li><li>Web Socket 服务器: 传统的B/S架构都是客户端发起请求，服务端响应这种单方向的架构。我们可以用nodejs＋socket.io来实现Web领域的实时推送，也被称作Realtime技术。这种技术要达到的目的是让用户不需要刷新浏览器就可以获得实时更新。它有着广泛的应用场景，比如在线聊天室、在线客服系统、评论系统、WebIM等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贵州游记</title>
      <link href="2016/06/12/guizhou/"/>
      <url>2016/06/12/guizhou/</url>
      
        <content type="html"><![CDATA[<p><img src="/2016/06/12/guizhou/13.JPG" alt="西江千户苗寨"><br><img src="/2016/06/12/guizhou/15.jpg" alt="小七孔"><br><img src="/2016/06/12/guizhou/9.JPG" alt="卧龙潭"><br><img src="/2016/06/12/guizhou/8.JPG" alt="小七孔"><br>6月7号中午12点就请了一天半的假，直接从公司出发去浦东机场，6月11号回到上海。总共4天半的时间，这次贵州之行，给我最大的印象就是贵州的山真是多，雨也很多，空气很好。另外本次贵州之行，也是我第一次在外面住青旅，在青旅结识了不少喜欢旅游的朋友，大家在一起相互吹逼，感觉很有意思。</p><span id="more"></span><h2 id="Day1－黄果树瀑布"><a href="#Day1－黄果树瀑布" class="headerlink" title="Day1－黄果树瀑布"></a>Day1－黄果树瀑布</h2><p>黄果树瀑布总共有3个景区，大瀑布，天星桥，陡坡塘。大瀑布是整个亚洲最大的瀑布，名声在外。但是天星桥我认为也是飞去不可，里面总共有20多个景点。<br><img src="/2016/06/12/guizhou/7.JPG" alt="大瀑布"><br><font color="#08c">大瀑布当时还有彩虹，水花溅的很远，镜头都湿了</font><br><img src="/2016/06/12/guizhou/6.JPG" alt="大瀑布"><br><font color="#08c">远处看大瀑布</font><br><img src="/2016/06/12/guizhou/1.JPG" alt="天星桥"><br><img src="/2016/06/12/guizhou/2.JPG" alt="天星桥"><br><font color="#08c">天星桥里面很多很窄的小路</font><br><img src="/2016/06/12/guizhou/3.JPG" alt="天星桥"><br><font color="#08c">天星洞，喀斯特地形，独特的钟乳石</font><br><img src="/2016/06/12/guizhou/4.JPG" alt="天星桥"><br><img src="/2016/06/12/guizhou/5.JPG" alt="天星桥"><br>第一天3个景点加起来，估计走了有10几公里，虽然很累，但是景色确实很美，由于一直在下雨，雨水很充足，大瀑布很壮观。</p><h2>Day2－小七孔</h2><p>小七孔景区之名由桥而得，是一座小巧玲珑的七孔古石桥。当然除了七孔桥之外，其他景点也很美，像卧龙潭，还有鸳鸯湖（很遗憾，因为下雨，没有划船）。在里面也玩了几个小时。</p><p><img src="/2016/06/12/guizhou/15.jpg" alt="小七孔"><br><font color="#08c">传说中的小七孔，确实很美</font><br><img src="/2016/06/12/guizhou/11.JPG" alt="小七孔"><br><img src="/2016/06/12/guizhou/9.JPG" alt="小七孔"><br><font color="#08c">卧龙潭，第一次尝试用快门优先，慢速快门，让水成流线型</font><br><img src="/2016/06/12/guizhou/10.JPG" alt="小七孔"><br><font color="#08c">卧龙潭</font><br><img src="/2016/06/12/guizhou/8.JPG" alt="小七孔"></p><h2>Day3－西江千户苗寨</h2><p>夜景站在观景台，可以俯视整个苗寨，很有感觉。<br><img src="/2016/06/12/guizhou/12.JPG" alt="苗寨"><br><font color="#08c">苗寨</font><br><img src="/2016/06/12/guizhou/13.JPG" alt="苗寨"><br><font color="#08c">夜晚的苗寨，自我感觉这张拍的不错，嘿嘿</font><br><img src="/2016/06/12/guizhou/14.JPG" alt="苗寨"><br><font color="#08c">白天的苗寨</font></p>]]></content>
      
      
      <categories>
          
          <category> 旅行足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 穷游 </tag>
            
            <tag> 贵州 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池源码分析二(ScheduledThreadPoolExecutor)</title>
      <link href="2016/05/13/threadpool2/"/>
      <url>2016/05/13/threadpool2/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池类图"><a href="#线程池类图" class="headerlink" title="线程池类图"></a>线程池类图</h2><p>本篇文章我们从右边这条线<br>Executor==&gt;ExcutorService==&gt;ScheduledExecutorService==&gt;ScheduledThreadPoolExecutor来分析一下。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201605/threadPool1/uml.jpg" alt="线程池UML类图"></p><span id="more"></span><h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><pre class="line-numbers language-none"><code class="language-none">public interface ScheduledExecutorService extends ExecutorService &#123;    public ScheduledFuture&lt;?&gt; schedule(Runnablcommand,        long delay, TimeUnit unit);    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay, TimeUnit unit);    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit);    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前2个方法是在一段时间后(delay,unit决定)，开启一个任务，任务只运行一次。后2个方法是每隔一段时间定时触发一个任务。其中方法3是每隔固定的时间启动一个任务(若前一个任务还未完成，则下一个任务可能会晚一点，不会并发的运行)。方法4是前一个任务运行完成后经过指定的时间运行下一个任务。</p><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>(1)schedule和scheduleAtFixedRate</p><pre class="line-numbers language-none"><code class="language-none">public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) &#123;    if (callable &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)        throw new NullPointerException();    RunnableScheduledFuture&lt;V&gt; t &#x3D; decorateTask(callable,new ScheduledFutureTask&lt;V&gt;(callable,triggerTime(delay, unit)));    delayedExecute(t);    return t;&#125;public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) &#123;    if (command &#x3D;&#x3D; null || unit &#x3D;&#x3D; null)        throw new NullPointerException();    if (period &lt;&#x3D; 0)        throw new IllegalArgumentException();    ScheduledFutureTask&lt;Void&gt; sft &#x3D;        new ScheduledFutureTask&lt;Void&gt;(command,null,triggerTime(initialDelay, unit),unit.toNanos(period));    RunnableScheduledFuture&lt;Void&gt; t &#x3D; decorateTask(command, sft);    sft.outerTask &#x3D; t;    delayedExecute(t);    return t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们选取上述2个方法分别代表只运行一次的任务和定时执行的任务。可以看到多次执行的定时任务就多了sft.outerTask = t，其他基本一样。<br>(2)delayedExecute</p><pre class="line-numbers language-none"><code class="language-none">private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123;    if (isShutdown())        reject(task);    else &#123;        super.getQueue().add(task);        if (isShutdown() &amp;&amp;        !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;            remove(task))            task.cancel(false);        else            ensurePrestart();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果线程池状态不是RUNNING状态，则执行拒绝策略拒绝任务，否则将任务添加到queue中。接着判断若状态不是RUNNING，并且删除成功，然后取消任务。若正常，则执行ensurePrestart()方法。<br>(3)ensurePrestart</p><pre class="line-numbers language-none"><code class="language-none">void ensurePrestart() &#123;    int wc &#x3D; workerCountOf(ctl.get());    if (wc &lt; corePoolSize)        addWorker(null, true);    else if (wc &#x3D;&#x3D; 0)        addWorker(null, false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就调用到了我们上一篇文章中讲的ThreadPoolExecutor的addWorker方法。这里的command都为null，意思是所有的工作线程都是从queue中获取任务。<br>上章我们知道若addWorker成功，则会启动一个工作线程调用runWorker方法</p><pre class="line-numbers language-none"><code class="language-none">final void runWorker(Worker w) &#123;    。。。。。。    try &#123;        while (task !&#x3D; null || (task &#x3D; getTask())!&#x3D; null) &#123;            try &#123;                beforeExecute(wt, task);                task.run();                afterExecute(task, thrown);            &#125; finally &#123;                task &#x3D; null;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly &#x3D; false;    &#125; finally &#123;        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们主要关注和上一章普通的ThreadPoolExecutor的不同点。在我看来，有以下2个地方：</p><ul><li>task = getTask()，这个方法从queue里面取得一个Task，这里用的queue是DelayedWorkQueue，和普通的LinkedBlockingQueue不同，从名字上可以看出这个是实现延时任务的。</li><li>task.run();这个task是ScheduledFutureTask，FutureTask的子类。<br>下面我们会单独来分析下上面2个方法。</li></ul><p>(4)ScheduledFutureTask.run()</p><pre class="line-numbers language-none"><code class="language-none">public void run() &#123;        boolean periodic &#x3D; isPeriodic();        if (!canRunInCurrentRunState(periodic))            cancel(false);        else if (!periodic)            ScheduledFutureTask.super.run();        else if (ScheduledFutureTask.super.runAndReset()) &#123;            setNextRunTime();            reExecutePeriodic(outerTask);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若线程池不是RUNNING状态，则取消；若只运行一次的任务，则调用父类FutureTask的run方法；若周期运行的任务，先设置下次运行的时间，然后调用reExecutePeriodic方法。</p><pre class="line-numbers language-none"><code class="language-none">void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) &#123;    if (canRunInCurrentRunState(true)) &#123;        super.getQueue().add(task);        if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))            task.cancel(false);        else            ensurePrestart();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法首先将任务添加到workQueue中，然后又会调用到上面的ensurePrestart方法。<br>(4)getTask()方法</p><pre class="line-numbers language-none"><code class="language-none">private Runnable getTask() &#123;    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?    for (;;) &#123;        int c &#x3D; ctl.get();        int rs &#x3D; runStateOf(c);        &#x2F;&#x2F; Check if queue empty only if necessary.        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            return null;        &#125;        int wc &#x3D; workerCountOf(c);        &#x2F;&#x2F; Are workers subject to culling?        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;            if (compareAndDecrementWorkerCount(c))                return null;            continue;        &#125;        try &#123;            Runnable r &#x3D; timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r !&#x3D; null)                return r;            timedOut &#x3D; true;        &#125; catch (InterruptedException retry) &#123;            timedOut &#x3D; false;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个workQueue是ScheduledThreadPoolExecutor中定义的DelayedWorkQueue。</p><h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><pre class="line-numbers language-none"><code class="language-none">public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException &#123;        final ReentrantLock lock &#x3D; this.lock;        lock.lockInterruptibly();        try &#123;            for (;;) &#123;                RunnableScheduledFuture&lt;?&gt; first &#x3D; queue[0];                if (first &#x3D;&#x3D; null)                    available.await();                else &#123;                    long delay &#x3D; first.getDelay(NANOSECONDS);                    if (delay &lt;&#x3D; 0)                        return finishPoll(first);                    first &#x3D; null; &#x2F;&#x2F; don&#39;t retain ref while waiting                    if (leader !&#x3D; null)                        available.await();                    else &#123;                        Thread thisThread &#x3D; Thread.currentThread();                        leader &#x3D; thisThread;                        try &#123;                            available.awaitNanos(delay);                        &#125; finally &#123;                            if (leader &#x3D;&#x3D; thisThread)                                leader &#x3D; null;                        &#125;                    &#125;                &#125;            &#125;        &#125; finally &#123;            if (leader &#x3D;&#x3D; null &amp;&amp; queue[0] !&#x3D; null)                available.signal();            lock.unlock();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个take方法是个阻塞方法，会一直等到获取到任务为止(或者被其他线程中断)若工作队列为空，则当前线程await();若工作队列不为空，则先获取剩余delay时间，若delay&lt;=0(说明延时时间已经到了)，则从队列中取出任务并从队列中删除。若delay&gt;0，最终会运行到available.awaitNanos(delay)，等待剩下的时间。然后进行下一次for循环，显然此时queue不为空，并且此时delay&lt;=0，则从队列中取出任务并删除。然后运行finally方法，唤醒其他阻塞在当前lock的当前Condition上的线程。<br>poll方法就不分析了。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池源码分析</title>
      <link href="2016/05/07/threadpool1/"/>
      <url>2016/05/07/threadpool1/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池类图"><a href="#线程池类图" class="headerlink" title="线程池类图"></a>线程池类图</h2><p>本篇文章我们先从左边这条线<br>Executor==&gt;ExcutorService==&gt;AbstractExecutorService==&gt;ThreadPoolExecutor来分析一下。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201605/threadPool1/uml.jpg" alt="线程池UML类图"></p><span id="more"></span><ul><li>上面url继承类图，线程池的最顶层的接口是Executor，这个接口只有一个方法void execute(Runnable command)</li><li>ExecutorService继承Executor，新增了submit(Runnable(Callable))，shutDown，shutDownNow等几个主要方法</li><li>AbstractExecutorService实现了上面的ExecutorService接口的若干个方法。</li><li>ThreadPoolExecutor继承AbstractExecutorService，实现了线程池的一些主要的方法execute(Runnable)。</li></ul><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p>AbstractExecutorService实现了submit方法，代码如下:</p><ul><li>submit(Callable task)方法<pre class="line-numbers language-none"><code class="language-none">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;    if (task &#x3D;&#x3D; null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);    execute(ftask);    return ftask;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>newTaskFor(Callable callable)方法<pre class="line-numbers language-none"><code class="language-none">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;    return new FutureTask&lt;T&gt;(callable);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>上面的FutureTask实现了RunnableFuture接口，RunnableFuture继承了<br>Runnable和Future接口。Runnable接口只有一个void run方法，Future接口有cancel(boolean),V get(),V get(long timeout, TimeUnit unit),boolean isCancelled(),boolean isDone()方法。</li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>接着上面的AbstractExecutorService.submit方法，会调用到execute(ftask)，这个execute方法就是ThreadPoolExecutor中的。我们接下来就以execute方法作为起点来分析。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><pre class="line-numbers language-none"><code class="language-none">public void execute(Runnable command) &#123;    if (command &#x3D;&#x3D; null)        throw new NullPointerException();    int c &#x3D; ctl.get();    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            return;        c &#x3D; ctl.get();    &#125;    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        int recheck &#x3D; ctl.get();        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)            addWorker(null, false);    &#125;    else if (!addWorker(command, false))        reject(command);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>首先检查当前工作线程数是否小于corePoolSize，若小于，则添加一个worker来处理这个任务(commadn),添加任务成功则返回.</li><li>如果线程还处于running状态,并且任务成功添加到queue中，重新检查一次线程池的状态，若线程池非running，则从queue中删除任务，成功则调用reject，这里根据拒绝策略来执行；若当前工作的线程数为0，则添加一个worker(addWorker(null, false)，这里要注意，这次的addWorker的参数和上面第一次的不一样)</li><li>如果添加worker失败，也执行reject方法。</li></ul><h3 id="addWorker-Runnable-firstTask-boolean-core"><a href="#addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="addWorker(Runnable firstTask, boolean core)"></a>addWorker(Runnable firstTask, boolean core)</h3> <pre class="line-numbers language-none"><code class="language-none">private boolean addWorker(Runnable firstTask, boolean core) &#123;    retry:    for (;;) &#123;        int c &#x3D; ctl.get();        int rs &#x3D; runStateOf(c);        &#x2F;&#x2F; Check if queue empty only if necessary.        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;               firstTask &#x3D;&#x3D; null &amp;&amp;               ! workQueue.isEmpty()))            return false;        for (;;) &#123;            int wc &#x3D; workerCountOf(c);            if (wc &gt;&#x3D; CAPACITY ||                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))                return false;            if (compareAndIncrementWorkerCount(c))                break retry;            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl            if (runStateOf(c) !&#x3D; rs)                continue retry;            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop        &#125;    &#125;    boolean workerStarted &#x3D; false;    boolean workerAdded &#x3D; false;    Worker w &#x3D; null;    try &#123;        w &#x3D; new Worker(firstTask);        final Thread t &#x3D; w.thread;        if (t !&#x3D; null) &#123;            final ReentrantLock mainLock &#x3D; this.mainLock;            mainLock.lock();            try &#123;                &#x2F;&#x2F; Recheck while holding lock.                &#x2F;&#x2F; Back out on ThreadFactory failure or if                &#x2F;&#x2F; shut down before lock acquired.                int rs &#x3D; runStateOf(ctl.get());                if (rs &lt; SHUTDOWN ||                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;                    if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable                        throw new IllegalThreadStateException();                    workers.add(w);                    int s &#x3D; workers.size();                    if (s &gt; largestPoolSize)                        largestPoolSize &#x3D; s;                    workerAdded &#x3D; true;                &#125;            &#125; finally &#123;                mainLock.unlock();            &#125;            if (workerAdded) &#123;                t.start();                workerStarted &#x3D; true;            &#125;        &#125;    &#125; finally &#123;        if (! workerStarted)            addWorkerFailed(w);    &#125;    return workerStarted;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1)这个判断逻辑比较复杂，我们先来看下<br> <pre class="line-numbers language-none"><code class="language-none">if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;               firstTask &#x3D;&#x3D; null &amp;&amp;               ! workQueue.isEmpty()))            return false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>若当前状态大于SHUTDOWN，显然if判断条件为ture，直接returnfalse。(很好理解，线程池处于关闭状态，肯定不让新添加worker了)<br>若当前状态小于SHUTDOWN，if判断条件为false，接着往下走(线程池为RUNNING状态，很好理解)<br>若当前状态等于SHUTDOWN：若firstTask等于null并且工作队列有任务，则if判断条件为false，代码不会return，会继续往下运行；若firstTask不等于null或者工作队列为空，则判断条件为true，会return false（这个也好理解，我们知道SHUTDOWN状态，线程池不再接受新的任务，但是已经在工作队列中的任务还是要完成才行。所以若first等于null，并且工作队列有任务，还要继续往下走。若相反，则不会往下走）<br>(2)判断当前工作线程数</p><pre class="line-numbers language-none"><code class="language-none">for (;;) &#123;    int wc &#x3D; workerCountOf(c);    if (wc &gt;&#x3D; CAPACITY ||        wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))        return false;    if (compareAndIncrementWorkerCount(c))        break retry;    c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl    if (runStateOf(c) !&#x3D; rs)        continue retry;    &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前工作线程数没有超过线程池设置的参数的限制，则利用CAS添加一个worker，并跳出外层的for循环，继续向下运行。否则返回false，添加worker失败。<br>(3) 完成了上述1 2步骤后，会执行new Worker(firstTask)，Thread t = w.thread并再次检查线程池的状态，若合法，则向工作线程池HashSet中添加当前worker，并执行t.start。此时才开启了子线程来执行任务。</p><h3 id="子线程run方法"><a href="#子线程run方法" class="headerlink" title="子线程run方法"></a>子线程run方法</h3><p>上面步骤3调用了t.start，会开启一个子线程来运行Worker中的run方法。</p><pre class="line-numbers language-none"><code class="language-none">public void run() &#123;        runWorker(this);&#125;final void runWorker(Worker w) &#123;    Thread wt &#x3D; Thread.currentThread();    Runnable task &#x3D; w.firstTask;    w.firstTask &#x3D; null;    w.unlock(); &#x2F;&#x2F; allow interrupts    boolean completedAbruptly &#x3D; true;    try &#123;        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;            w.lock();            &#x2F;&#x2F; If pool is stopping, ensure thread is interrupted;            &#x2F;&#x2F; if not, ensure thread is not interrupted.  This            &#x2F;&#x2F; requires a recheck in second case to deal with            &#x2F;&#x2F; shutdownNow race while clearing interrupt            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try &#123;                beforeExecute(wt, task);                Throwable thrown &#x3D; null;                try &#123;                    task.run();                &#125;finally &#123;                    afterExecute(task, thrown);                &#125;            &#125; finally &#123;                task &#x3D; null;                w.completedTasks++;                w.unlock();            &#125;        &#125;        completedAbruptly &#x3D; false;    &#125; finally &#123;        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述worker不断通过getTask()方法，从workQueue中获取任务；若没有获取到任务，则调用processWorkerExit方法。</p><h3 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h3><pre class="line-numbers language-none"><code class="language-none">private Runnable getTask() &#123;    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?    for (;;) &#123;        int c &#x3D; ctl.get();        int rs &#x3D; runStateOf(c);        &#x2F;&#x2F; Check if queue empty only if necessary.        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            return null;        &#125;        int wc &#x3D; workerCountOf(c);        &#x2F;&#x2F; Are workers subject to culling?        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;            if (compareAndDecrementWorkerCount(c))                return null;            continue;        &#125;        try &#123;            Runnable r &#x3D; timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r !&#x3D; null)                return r;            timedOut &#x3D; true;        &#125; catch (InterruptedException retry) &#123;            timedOut &#x3D; false;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getTask方法是一个无限的for循环方法，它首先判断当前线程池的状态</p><pre class="line-numbers language-none"><code class="language-none">if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            return null;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个判断也很好理解，若rs==SHUTDOWN，workQueue为空，显然应该直接返回null，并提前是工作的worker减一。(getTask返回null，runWorker方法会调用processWorkerExit从HashSet中remove当前worker)；若rs&gt;大于SHUTDOWN(这个对应线程池的shutDownNow方法，工作队列中等待的任务不再执行)；其他情况，说明线程池处于运行状态，继续往下运行。然后根据当前线程池设置的最大线程数，以及是否允许线coreThread超时间以及workQueue的状态来判断是否通过CAS操作来是线程数减一并return null。最后我们要关注下下面这个从工作队列中取得任务的三目运算。</p><pre class="line-numbers language-none"><code class="language-none">Runnable r &#x3D; timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若timed为ture(设置allowCoreThreadTimeOut为true)，则超过了等待的时间还没有从workQueue中取得任务则r ＝ null，此时就有可能造成即使workerCount小于corePoolSize，当前的worker也可能被回收。<br>若timed为false，则调用阻塞方法从workQueue中获取任务，newFixedThreadPool就会一直调用这个阻塞方法，从而达到不显示关闭线程池的情况下，即使workQueue为空，也能维持固定的工作线程的个数。</p><h3 id="shutDown-shutDownNow-方法"><a href="#shutDown-shutDownNow-方法" class="headerlink" title="shutDown(shutDownNow)方法"></a>shutDown(shutDownNow)方法</h3><pre class="line-numbers language-none"><code class="language-none">public List&lt;Runnable&gt; shutdownNow() &#123;    List&lt;Runnable&gt; tasks;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        checkShutdownAccess();        &#x2F;&#x2F;shutDwonNow为STOP,shutDown为SHUTDOWN        advanceRunState(STOP);(advanceRunState(SHUTDOWN);)        interruptWorkers();(interruptIdleWorkers)        &#x2F;&#x2F;shutDownNow专用        tasks &#x3D; drainQueue();        &#x2F;&#x2F;shutDown专用 ScheduledThreadPoolExecutor回调        onShutdown();    &#125; finally &#123;        mainLock.unlock();    &#125;    tryTerminate();    return tasks;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shutDown和shutDownnNow方法区别(代码层面)：</p><ul><li>shutDownNow：advanceRunState(STOP),interruptWorkers<br>shutDown：advanceRunState(shutDown),interruptIdleWorkers</li><li>shutDown多了个onShutdown();ScheduledThreadPoolExecutor复写了onShutDown方法。</li><li>shutDownNow方法工作队列中还未完成的任务。</li><li>interruptIdleWorkers</li></ul><h3 id="interruptIdleWorkers与interruptWorkers"><a href="#interruptIdleWorkers与interruptWorkers" class="headerlink" title="interruptIdleWorkers与interruptWorkers"></a>interruptIdleWorkers与interruptWorkers</h3><p>(1)shutDownNow</p><pre class="line-numbers language-none"><code class="language-none">private void interruptWorkers() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        for (Worker w : workers)            w.interruptIfStarted();    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然这个是中断所有的线程<br>(2)shutDown</p><pre class="line-numbers language-none"><code class="language-none">private void interruptIdleWorkers(boolean onlyOne) &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        for (Worker w : workers) &#123;            Thread t &#x3D; w.thread;            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;                try &#123;                    t.interrupt();                &#125; catch (SecurityException ignore) &#123;                &#125; finally &#123;                    w.unlock();                &#125;            &#125;            if (onlyOne)                break;        &#125;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意onlyOne参数，这个只有在调用tryTerminate()方法里面，会调用interruptIdleWorkers(true)，其他情况都是interruptIdleWorkers(false)，所以对于shutDown方法，也是尝试中断所有还没有被中断的线程。<br>3)tryTerminate<br>上面(2)中提到了tryTerminate方法，接下来就来看下这个方法</p><pre class="line-numbers language-none"><code class="language-none">final void tryTerminate() &#123;    for (;;) &#123;        int c &#x3D; ctl.get();        if (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))            return;        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate            interruptIdleWorkers(ONLY_ONE);            return;        &#125;        final ReentrantLock mainLock &#x3D; this.mainLock;        mainLock.lock();        try &#123;            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;                try &#123;                    terminated();                &#125; finally &#123;                    ctl.set(ctlOf(TERMINATED, 0));                    termination.signalAll();                &#125;                return;            &#125;        &#125; finally &#123;            mainLock.unlock();        &#125;        &#x2F;&#x2F; else retry on failed CAS    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述代码可以看出，若线程池状态为SHUTDOWN，workQueue为空，工作线程数为0或者线程池状态为STOP，工作线程数为0，都最终会把线程池状态设置为TERMINATED，并且唤醒所有因为调用awaitTermination()方法阻塞在termination.awaitNanos(nanos)还未醒过来的线程。</p><pre class="line-numbers language-none"><code class="language-none">public boolean awaitTermination(long timeout, TimeUnit unit)    throws InterruptedException &#123;    long nanos &#x3D; unit.toNanos(timeout);    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        for (;;) &#123;            if (runStateAtLeast(ctl.get(), TERMINATED))                return true;            if (nanos &lt;&#x3D; 0)                return false;            nanos &#x3D; termination.awaitNanos(nanos);        &#125;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述tryTerminate方法，在addWorkerFailed()，processWorkerExit()，shutDown()，shutDownNow()，remove(Runnable task)方法中都会调用到。</p><h2 id="线程池5种状态解释"><a href="#线程池5种状态解释" class="headerlink" title="线程池5种状态解释"></a>线程池5种状态解释</h2><p>上面经常提到线程池的运行状态，这里稍作解释一下。</p><pre class="line-numbers language-none"><code class="language-none">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="种状态的定义"><a href="#种状态的定义" class="headerlink" title="种状态的定义"></a>种状态的定义</h3><ul><li>RUNNING: 接受新的任务，处理workQueue中的任务。</li><li>SHUTDOWN: 不接受新的任务，但是会继续完成workQueue中的任务</li><li>STOP: 不接受新的任务，也不处理workQueue中未完成的任务，尝试中断所有运行中的任务</li><li>TIDYING: 所有任务已经完成, 工作线程数为0,线程池状态变成TIDYING随之将会调用terminated()方法。</li><li>TERMINATED: terminated()方法已经完成</li></ul><h3 id="5种状态相互转换"><a href="#5种状态相互转换" class="headerlink" title="5种状态相互转换"></a>5种状态相互转换</h3><ul><li>RUNNING -&gt; SHUTDOWN: 调用shutdown()方法，也许隐式在finalize()方法</li><li>(RUNNING or SHUTDOWN) -&gt; STOP: 调用shutdownNow()方法</li><li>SHUTDOWN -&gt; TIDYING: workQueue和pool都为空</li><li>STOP -&gt; TIDYING: pool为空</li><li>TIDYING -&gt; TERMINATED: terminated()方法完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成都游记</title>
      <link href="2016/04/28/chengdu/"/>
      <url>2016/04/28/chengdu/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1－宽窄巷子"><a href="#Day1－宽窄巷子" class="headerlink" title="Day1－宽窄巷子"></a>Day1－宽窄巷子</h2><p>到了成都，酒店安排好后，就直接去了宽窄巷子，找了一个茶馆，边喝茶边看戏。值得一提的是，李天炜同学上去当了一次演员，冒着生命危险给我们赢得了一个果盘，只有他不知道😂。<br><img src="/2016/04/28/chengdu/7.jpg" alt="天炜同学"></p><span id="more"></span><h2 id="Day2－青城山＋都江堰"><a href="#Day2－青城山＋都江堰" class="headerlink" title="Day2－青城山＋都江堰"></a>Day2－青城山＋都江堰</h2><p>第二天7点钟就去了青城山，青城山不是很高，很顺利的就怕到了最高点，山上的风景确实不错。<br><img src="/2016/04/28/chengdu/8.jpg" alt="青城山"><br><img src="/2016/04/28/chengdu/9.jpg" alt="青城山"><br><img src="/2016/04/28/chengdu/4.jpg" alt="青城山"></p><h2 id="Day3－熊猫基地＋锦里"><a href="#Day3－熊猫基地＋锦里" class="headerlink" title="Day3－熊猫基地＋锦里"></a>Day3－熊猫基地＋锦里</h2><p>第三天去看了大熊猫，大熊猫的待遇真是太好了，每个大熊猫住的都是别墅啊。大熊猫真是太懒了，估计10个大熊猫有9个都在睡觉，睡觉都能成为国宝，估计也只有熊猫了。</p><p><img src="/2016/04/28/chengdu/2.jpg" alt="熊猫基地"><br>这只熊猫比较配合，一只在卖萌</p><p><img src="/2016/04/28/chengdu/5.jpg" alt="熊猫基地"></p><p><img src="/2016/04/28/chengdu/3.jpg" alt="锦里"><br>跪求把旁边一个人给p掉😂</p><p><img src="/2016/04/28/chengdu/6.jpg" alt="锦里"><br>锦里夜间被灯光照到的2棵树</p><p><img src="/2016/04/28/chengdu/10.jpg" alt="锦里"></p><h2 id="天府之国"><a href="#天府之国" class="headerlink" title="天府之国"></a>天府之国</h2><p>第一次去成都，在公路上感觉绿化很好。小吃什么的都不用说了，成都的饮食口味果然适合我这种喜欢池辣的人，火锅吃完，全身都是火锅味道。听说成都的房价也不是很贵，如果不是大学开始就呆在上海，去成都也是一个很不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 旅行足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成都 </tag>
            
            <tag> 穷游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC源码分析二(Bean实例化)</title>
      <link href="2016/04/26/spring2/"/>
      <url>2016/04/26/spring2/</url>
      
        <content type="html"><![CDATA[<h2 id="AbstractApplication-refresh"><a href="#AbstractApplication-refresh" class="headerlink" title="AbstractApplication.refresh"></a>AbstractApplication.refresh</h2><p>如下图，上一篇文章我们已经提到过refresh方法，spring容器启动的一系列步骤都是这个方法来实现的。上一篇文章我们主要基于obtainFreshBeanFactory()这个方法来分析IoC容器的resource资源定位，BeanDefinition的解析和载入以及最终向容器中注册。<br>下面我们重新审视下refresh方法，我们把整个IoC容器启动分为下图中的12个步骤。</p><span id="more"></span><p>对于步骤5和步骤6稍微解释下，步骤5涉及到了BeanFactoryPostProcessor，步骤6涉及到了BeanPostProcessor。下面比较下两者的异同点。<br><img src="/2016/04/26/spring2/refresh.jpg" alt="AbstractApplicationContext.refresh"></p><h2 id="BeanFactoryPostProcessor与BeanPostProcessor"><a href="#BeanFactoryPostProcessor与BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcessor与BeanPostProcessor"></a>BeanFactoryPostProcessor与BeanPostProcessor</h2><ul><li>从名字上看，两者都是一个后置的处理器，都提供了回调接口。</li><li>BeanFactoryPostProcessor<pre class="line-numbers language-none"><code class="language-none">public interface BeanFactoryPostProcessor &#123;    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>可以对bean的定义（配置元数据）进行处理。也就是说，Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其它的bean之前读取配置元数据，并有可能修改它。如果你愿意，你可以配置多个BeanFactoryPostProcessor。你还能通过设置’order’属性来控制BeanFactoryPostProcessor的执行次序。</li><li>BeanPostProcessor<pre class="line-numbers language-none"><code class="language-none">public interface BeanPostProcessor &#123;    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>BeanPostProcessor，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。这里说的初始化方法，指的是下面两种：<br>1）bean实现了InitializingBean接口，对应的方法为afterPropertiesSet<br>2）在bean定义的时候，通过init-method设置的方法<br>注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。另外从名字也可以看出，步骤6只是注册了定义的BeanPostProcessor，并没有触发。</li></ul><h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><p>我们主要关注refresh方法中的第11步finishBeanFactoryInitialization，这个是对spring容器中的非延迟加载的单例bean进行实例化的(步骤5和6也会通过getBean方法对一些processorBean进行实例化)。</p><h3 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h3><p>DefaultListableBeanFactory类这个方法可以看到如果bean是单例，并且没有设置延时加载，那么就会调用getBean(beanName)方法(这里我们先不考虑FactoryBean)，这个方法就会完成bean的依赖注入</p><h3 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h3><p>上面getBean会调用到AbstractBeanFactory.doGetBean()方法。这个方法首先会在singleton缓存中去寻找需要的bean，如果这个bean是单例的，则直接返回这个bean。负责判断此bean是否在此beanfactory中定义（containsBeanDefinition(beanName)），如果没有递归至双亲beanfactory，以上条件不满足的话，接下来得到beandefination的定义（getMergedLocalBeanDefinition(beanName)），开始创建bean。首先分析该bean有没有dependsOn，若有依赖的bean，则分别对依赖的bean进行递归getBean。第二步判断bean的生命周期，如果是singleton的话，使用对应的singletonFactory来生成，如果是prototype的，使用createBean(beanName, mbd, args)方法生成。</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>上一步会调用到AbstractAutowireCapableFactory的createBean方法。这个方法主要有2步骤:</p><ul><li>resolveBeforeInstantiation(beanName, mbdToUse)如果目标bean实现了InstantiationAwareBeanPostProcessor这个接口，在实例化目标bean之前，直接调用这个的postProcessBeforeInstantiation方法返回一个bean来代替目标bean。</li><li>若1中bean没有实现上述接口，则调用AbstractAutowireCapableFactory的doCreateBean方法。</li></ul><h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><ul><li>会创建一个 BeanWrapper 对象 用于存放实例化对象。如果此bean配置了工厂方法（mbd.getFactoryMethodName() != null），则使用工厂类进行bean的创建，如果此bean注入了构造器参数（ctors != null），则使用非默认的构造器对应的方法autowireConstructor进行生成，最后一种情况是最常见的，非工厂类，且使用默认无参的构造方法，instantiateBean(beanName, mbd)，这一步只是生成了一个对象，但是对象的属性值都没有注入进来。</li><li>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);第三个BeanPostProcessor扩展点，执行Bean定义的合并</li><li>populateBean，根据注入方式进行注入。根据是否有依赖检查进行依赖检查。<br>执行 bean 的注入里面会选择注入类型：AutowireByName，AutowireByType，接下来applyPropertyValues，把beanFactory中的字段属性值赋给步骤1中生成的对象。</li><li>initializeBean(beanName, exposedObject, mbd);<br>判断是否实现了 BeanNameAware 、 BeanClassLoaderAware 等 spring 提供的接口，如果实现了，进行默认的注入。同时判断是否实现了 InitializingBean 接口，如果是的话，调用 afterPropertySet 方法。<br><img src="/2016/04/26/spring2/initializeBean.jpg" alt="initializeBean"></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="http://www.iteye.com/topic/1122859">Spring开闭原则的表现-BeanPostProcessor扩展点</a><br> <a href="http://www.iteye.com/topic/1115391">SpringIOC核心源码学习（二）：容器初始化过程</a><br> <a href="http://www.iteye.com/topic/743998">Spring源码浅析依赖注入</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC源码分析</title>
      <link href="2016/04/16/spring/"/>
      <url>2016/04/16/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC简要解释"><a href="#IOC简要解释" class="headerlink" title="IOC简要解释"></a>IOC简要解释</h2><p>在应用开发中，开发人员往往需要引用和调用其它组件的服务，这种依赖关系如果固化在组件设计中，就会造成依赖关系的僵化和以后维护成本的增加。如果使用IoC容易，把资源的获取反转，具体相对java来说就是把bean的依赖关系交给IoC容易来处理。在反转实现中，具体通过可读的文件来配置。并且bean的耦合关系需要变动时候，可以不用重新改变或者编译源代码就可以实现，这也符合设计原则中的开闭原则，能够提供组件系统设计的灵活性。基于此，我们下面来简要分析一下Spring IoC相关的源码</p><span id="more"></span><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><img src="/2016/04/16/spring/uml.jpg" width="60%/"><p>通过上面的类图，可以看到ApplicationContext是基于BeanFactory接口扩展来的，但它还继承了一些其它的接口，所以它是一个Spring提供给我们的一个更高级的IoC容易。<br>下面我们来分析一下ApplicationContext启动部分的源码。我们看到<br><img src="/2016/04/16/spring/refresh.jpg" width="60%/"></p><pre class="line-numbers language-none"><code class="language-none">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)throws BeansException &#123;    super(parent);    setConfigLocations(configLocations);    if (refresh) &#123;        refresh();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于上面的ClassPathXmlApplicationContext可以看到它会调用AbstractApplicationContext的refresh方法，这个也是IoC启动的核心代码，下面就来看下。<br>我们可以看到refresh方法里面又包含很多步骤，我们主要关注一下红线标记出来的那个方法，它就是Spring IoC的初始化。</p><h3 id="refresh的时序图"><a href="#refresh的时序图" class="headerlink" title="refresh的时序图"></a>refresh的时序图</h3><img src="/2016/04/16/spring/shixu.jpg" width="60%/"><p>通过上面的时序图，我们可以看到ioc启动大致可以分为3个过程。</p><ul><li>resource的定位过程，可以简单理解就是找到我们定义bean的相关的xml文件</li><li>BeanDifinition的载入，就是把用户在xml中定义好的bean解析成为IoC的内部数据结构，也就是BeanDifinition。</li><li>向IoC容易注册这些BeanDifinition，把BeanDifinition注册到一个Map中保存。</li></ul><p>下面我们以上面的时序图为基础，分别对上面的3个过程简要分析一下。</p><h3 id="resource的定位"><a href="#resource的定位" class="headerlink" title="resource的定位"></a>resource的定位</h3><ul><li>ClassPathXmlApplicationContext的构造方法setConfigLocations(configLocations);这个最终设置了AbstractRefreshableConfigApplicationContext的configLocations属性</li><li>AbstractXmlApplicationContext.loadBeanDefinitions()方法会调用到XmlBeanDefinitionReader.loadBeanDefinitions(configLocations);</li><li>XmlBeanDefinitionReader.doLoadBeanDefinitions(EncodedResource encodedResource)这就把一开始传入的一个指向xml的路径变成了一个程序可以读的encodedResource，就完成了resource的定位。</li></ul><h3 id="BeanDifinition的载入和解析"><a href="#BeanDifinition的载入和解析" class="headerlink" title="BeanDifinition的载入和解析"></a>BeanDifinition的载入和解析</h3><ul><li>XmlBeanDefinitionReader.doLoadBeanDefinitions(InputSource inputSource, Resource resource)这个方法把资源封装成一个Document</li><li>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)这个方法解析document中的每一个获取到的标签<img src="/2016/04/16/spring/beanParse.jpg" width="60%/"></li><li>最终通过BeanDefinitionParserDelegate..parseBeanDefinitionElement(Element)来解析Element，并用BeanDefinitionHolder来持有BeanDifinition。<img src="/2016/04/16/spring/beanDifinitionHolder.jpg" width="60%/"></li></ul><h3 id="BeanDifinition在IoC容器中的注册"><a href="#BeanDifinition在IoC容器中的注册" class="headerlink" title="BeanDifinition在IoC容器中的注册"></a>BeanDifinition在IoC容器中的注册</h3><ul><li>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());其中这个getReaderContext().getRegistry()返回的就是最早创建的DefaultListableBeanFactory</li><li>DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</li><li>DefaultListableBeanFactory持有下面这个对象<br>private final Map beanDefinitionMap = new ConcurrentHashMap(256);每次基本都是putIfAbsent模式以放到beanDefinitionMap，这样就完成了bean的注册过程。</li></ul><h3 id="IoC容器的依赖注入"><a href="#IoC容器的依赖注入" class="headerlink" title="IoC容器的依赖注入"></a>IoC容器的依赖注入</h3><p>上面3个过程只是完成了每个单独在xml中定义的bean在IoC容器中的注册，但是我们知道很多bean最终的实例化都要依赖其它bean。然而这个依赖注入我们从上面的代码来看，并没有完成这个过程。事实上，依赖注入是在refresh中的</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.finishBeanFactoryInitialization(beanFactory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述方法会调用到getBean(<font color="#08c"><b>从上面代码的注释可以看出它只能实例化没有设置lazy-init的bean，如果设置了lazy-init只能在最终applicationContext.getbean的时候完成依赖注入</b></font>)这个getbean会通过判断当前bean是否有depends-on的bean，若果有，则对依赖的depend-on的bean在递归调用get Bean。最终完成bean的依赖注入。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty源码研究二(请求处理)</title>
      <link href="2016/04/02/netty2/"/>
      <url>2016/04/02/netty2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章中，已经分析了netty的服务器端启动过程，我们知道NioEventLoop.run()方法，是服务器端用来轮询客户端的请求。我们指定创建出的NioServerSocketChannel就是注册到了NioEventLoop中的Selector上。这篇文章，我们接着顺藤摸瓜，来分析下netty是怎么处理每个客户端请求的。</p><span id="more"></span><h2 id="MainReactor"><a href="#MainReactor" class="headerlink" title="MainReactor"></a>MainReactor</h2><h3 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h3><p><font color="#08c"><b>NioEventLoop</b></font><br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/nioEventLoop.jpg" alt="nioEventLoop.run"><br>通过上图我们可以看到run方法中，selector一直在轮询客户端过来的请求。我们看到若接收到一个感兴趣的事件后，会通过调用this.processSelectedKeys()方法来处理被select的key，通过一系列方法调用，会到下图中的方法<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/nioEventLoop.jpg" alt="nioEventLoop.run"></p><pre class="line-numbers language-none"><code class="language-none">if((ignored &amp; 17) !&#x3D; 0 || ignored &#x3D;&#x3D; 0) &#123;    unsafe.read();    if(!ch.isOpen()) &#123;        return;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过“ignored&amp;17”可以看到若事件是OP_ACCEPT活着OP_READ就会调用到unsafe.read()方法。这个方法会调用到NioMessageUnsafe.read();</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p><font color="#08c"><b>AbstractNioMessageChannel</b></font><br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/mainRead.jpg" alt="AbstractNioMessageChannel.read"><br>read()会不断调用doReadMessages()，将产生的readBuf逐一发送给Pipeline.fireChannelRead()去处理。这2个方法也是我们需要重点关注的。</p><ul><li>先来看看doReadMessages()方法。<pre class="line-numbers language-none"><code class="language-none">protected int doReadMessages(List buf) throws Exception &#123;SocketChannel ch &#x3D; this.javaChannel().accept();try &#123;    if(ch !&#x3D; null) &#123;        buf.add(new NioSocketChannel(this, ch));        return 1;    &#125;&#125; catch (Throwable var6) &#123;    logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, var6);    try &#123;        ch.close();    &#125; catch (Throwable var5) &#123;        logger.warn(&quot;Failed to close a socket.&quot;, var5);    &#125;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color="#08c"><b>ServerBootstrapAcceptor</b></font><br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/serverBootstrapAcceptior.jpg" alt="ServerBootstrapAcceptor.channelRead"><br>这里可以看到accept真正与客户端建立连接并创建了SocketChannel，也就是说这里只是创建了连接，但是没有真正的去读取io，这个也就mainreactor做的，只接受客户端连接，可以猜测接下来要把这个socketChannel交给subReactor来真正处理io。</li><li>然后是fireChannelRead。<br>最终会调用ServerBootstrap.ServerBootstrapAcceptor.channelRead()方法。<br>注意this.childGroup.register(child)<br>有没有一种似曾相识的感觉，不错，这个就是subReactor的注册过程，这里就不在啰嗦了<br><font color="#08c"><b>方法调用堆栈图</b></font><br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/duizhan1.jpg" alt="方法调用堆栈图"></li></ul><h2 id="SubReactor"><a href="#SubReactor" class="headerlink" title="SubReactor"></a>SubReactor</h2><p>通过前面的分析能够看到，EventLoop轮询到的事件最终会交给unsafe.read()去处理。NioSocketChannel与NioServerSocketChannel的一个重要区别就是：NioSocketChannel继承AbstractNioByteChannel，而后者继承AbstractNioMessageChannel，两者的unsafe工具类实现是不同的。</p><h3 id="注册读事件"><a href="#注册读事件" class="headerlink" title="注册读事件"></a>注册读事件</h3><p>因为Netty 4中已经完全统一了EventLoopGroup的代码，已经不区分主从Reactor的逻辑了。所以实际上，这里的注册过程我们已经分析过了。子EventLoopGroup会选择出一个EventLoop负责轮询绑定上的Channel的事件，而Channel感兴趣的事件前面也提到了，就是Channel构造方法中传入的。<br>// NioSocketChannel</p><pre class="line-numbers language-none"><code class="language-none">public NioSocketChannel(Channel parent, SocketChannel socket) &#123;    super(parent, socket); config &#x3D; new NioSocketChannelConfig(this, socket.socket());&#125;AbstractNioByteChannel protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;    super(parent, ch, SelectionKey.OP_READ);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建Handler"><a href="#创建Handler" class="headerlink" title="创建Handler"></a>创建Handler</h3><p>使用Netty时我们通常会在ChannelInitializer中初始化Handler，但Netty是什么时候调用它的呢？答案就在Channel注册到子EventLoop之后。之前看到的fireChannelRegistered()会触发ChannelInitializer。所以说：每个客户端Channel建立成功后会创建Handler，并且后续请求处理都由这一组Handler完成。</p><pre class="line-numbers language-none"><code class="language-none">public abstract class ChannelInitializer extends ChannelInboundHandlerAdapter &#123;&#x2F;** * This method will be called once the &#123;@link Channel&#125; was registered. *&#x2F;protected abstract void initChannel(C ch) throws Exception;@Overridepublic final void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;    ChannelPipeline pipeline &#x3D; ctx.pipeline();    try &#123;        initChannel((C) ctx.channel());        pipeline.remove(this);        ctx.fireChannelRegistered();    &#125; catch (Throwable t) &#123;        logger.warn(&quot;Failed to initialize a channel. Closing: &quot; + ctx.channel(), t);    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="处理客户端io"><a href="#处理客户端io" class="headerlink" title="处理客户端io"></a>处理客户端io</h3><p>//AbstractNioByteChannel<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/subRead.jpg" alt="AbstractNioByteChannel.subRead"><br>通过上图，可以看到这里才是真正的读取socketChannel的内容。在AbstractNioMessageChannel中接收到的是SocketChannel，所以并没有发生真正的读操作。而AbstractNioByteChannel是真正地从SocketChannel中读，所以这也是申请缓冲区的地方。每次发生读事件时，都会分配一块ByteBuf，然后尝试从Channel中读出数据写到ByteBuf中。之后触发fireChannelRead()，由Pipeline中的Handler继续处理，最终Tail处理器负责释放掉ByteBuf。</p><h3 id="方法调用堆栈图"><a href="#方法调用堆栈图" class="headerlink" title="方法调用堆栈图"></a>方法调用堆栈图</h3><p><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201604/netty2/duizhan2.jpg" alt="subReactor调用堆栈图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，ServerSocketChannel会由一个EventLoop负责轮询接收事件，得到的SocketChannel是交给子Reactor中的一个EventLoop负责轮询读事件。也就是说多个客户端可能会对应一个EventLoop线程。每个SocketChannel注册完毕就会创建Handler，所以说每个客户端都对应自己的Handler实例，并且一直使用到连接断开。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty源码研究一(服务端启动)</title>
      <link href="2016/03/12/netty1/"/>
      <url>2016/03/12/netty1/</url>
      
        <content type="html"><![CDATA[<h2 id="netty服务端代码分析"><a href="#netty服务端代码分析" class="headerlink" title="netty服务端代码分析"></a>netty服务端代码分析</h2><h3 id="服务端启动配置"><a href="#服务端启动配置" class="headerlink" title="服务端启动配置"></a>服务端启动配置</h3><img src="/2016/03/12/netty1/server.jpg" width="60%/"><span id="more"></span> - 对于ServerBootstrap：ServerBootstrap继承于AbstractBootstrap，它从父类继承了EventLoopGroup group，ChannelFactory<? extends C> channelFactory，自己新增了EventLoopGroup childGroup，ChannelHandler childHandler。上面b.group开始的链式代码就是初始化上面这些属性的值的。 - bossgroup和workergroup：可以看到都是NioEventLoopGroup,可以理解成2个线程池。从bossgroup中随便选一个作为Reactor模型中的acceptor，监听客户端连接，创建socketChannel，然后从workergroup选取一个io线程来处理socketChannel的读取事件。 - 对于NioEventLoopGroup和NioEventLoop：先看下类图<img src="/2016/03/12/netty1/nioEventLoopGroup.jpg" width="60%/"><p><font color="#08c"><b>可以看到NioEventLoopGroup继承了EventLoopGroup</b></font></p><img src="/2016/03/12/netty1/nioEventLoop.jpg" width="60%/"><p><font color="#08c"><b>NioEventLoop实现了EventLoop,而EventLoop又继承自EventLoopGroup。eventloopgroup.next()又可以返回一个eventloop。可以看到EventLoop最终继承于线程池Executor。而最终NioEventLoopGroup又实现了EventLoop，接下来我们还会分析下NioEventLoopGroup</b></font></p><h3 id="服务端注册感兴趣事件和监听端口"><a href="#服务端注册感兴趣事件和监听端口" class="headerlink" title="服务端注册感兴趣事件和监听端口"></a>服务端注册感兴趣事件和监听端口</h3><img src="/2016/03/12/netty1/AbstractBootstrap.jpg" width="60%/"><h4 id="注册感兴趣事件"><a href="#注册感兴趣事件" class="headerlink" title="注册感兴趣事件"></a>注册感兴趣事件</h4><p>b.bind最终调用到AbstractBootstrop的以下方法</p><ul><li>final ChannelFuture initAndRegister() {<br>this.group().register(channel);（中间省略）<br>}这个this.group就是一开始设置的bossgroup（NioEventLoopGroup）,看到这个方法基本可以想到这个应该是把channel注册到某个选择器上</li><li>MultithreadEventLoopGroup<br>public ChannelFuture register(Channel channel) {<br>return this.next().register(channel);<br>}上面的类图已经可以看出NioEventLoopGroup继承自MultithreadEventLoopGroup，最终this.next()又会返回NioEventLoop，所以也就是可以理解是把channel注册到NioEventLoop上（我们猜想NioEventLoop可以想象成封装了一个selector）</li><li>this.next()返回NioEventLoop继承于SingleThreadEventLoop channel.unsafe().register(this, promise);最终调用到AbstractUnsafe的register方法<br>eventLoop.execute(new OneTimeTask() { public void run() { AbstractUnsafe.this.register0(promise); } });<br>这里通过bossgroup启动一个线程</li><li>最终调用到<pre class="line-numbers language-none"><code class="language-none">protected void doRegister() throws Exception &#123;   boolean selected &#x3D; false;       while(true) &#123;           try &#123;               this.selectionKey &#x3D; this.javaChannel().register(this.eventLoop().selector, 0, this);               return;           &#125; catch (CancelledKeyException var3) &#123;               if(selected) &#123;                   throw var3;               &#125;               this.eventLoop().selectNow();               selected &#x3D; true;           &#125;       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h4><p>可以看到第四张截图</p><pre class="line-numbers language-none"><code class="language-none">ChannelFuture regFuture &#x3D; this.initAndRegister();if(regFuture.cause() !&#x3D; null) &#123;    return regFuture;&#125; else if(regFuture.isDone()) &#123;    doBind0(regFuture, channel, localAddress, promise1); return promise1;&#125; else &#123;    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise); &#125; &#125;); return promise;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到initAndRegister()这个方法就是上面我们说的注册感兴趣的事件。后面的else if和else 都有dobind0 方法，这个方法也是通过之前的线程池启动一个线程去监听一个端口。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.boyunjian.com/javadoc/io.netty/netty-transport/4.0.0.Alpha7/_/io/netty/channel/DefaultChannelFuture.html">netty api说明</a><br><a href="http://blog.csdn.net/dc_726/article/details/47858077">Netty 4源码解析：服务端启动</a><br><a href="http://blog.csdn.net/dc_726/article/details/48084367">Netty 4源码解析：请求处理</a><br><a href="http://www.infoq.com/cn/articles/netty-threading-model?utm_source=infoq&utm_medium=popular_links_homepage">Netty系列之Netty线程模型</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见,陆金所</title>
      <link href="2016/03/02/lizhi/"/>
      <url>2016/03/02/lizhi/</url>
      
        <content type="html"><![CDATA[<p>今天刚拿到退工单，陆金所已经成为过去了。从2月5号提出辞职，到今天，差不多一个月的时间。在这一个月里，因为确定要走，所以工作上的事情不是很多。但也并没有闲着，除了每天回去接着敲代码看看书，期间也想了很多事情。有必要总结一下这段工作经历。</p><span id="more"></span><h2 id="初来乍到"><a href="#初来乍到" class="headerlink" title="初来乍到"></a>初来乍到</h2><p>因为是刚来，对公司的各种流程也不是很清楚，再加上技术确实很渣，这段时间大概持续了一个多月吧。这段时间很感谢韫清，袁洁和陈琦的帮助，记得是做单品返赠，现在看来是一个很小很小的功能。虽然从陈琦和袁洁包括翼翔那得到了不小的帮助，但是那时js实在太差，还是搞出了不少bug😂。因为我自身js很水，技术很差，那时候翼翔又是我们组js最好的，当时就觉得翼翔很牛逼。这段时间基本上主要是熟悉 公司流程，也认识了不少新朋友，当然技术上主要提高了js能力。</p><h2 id="基金直连和代销"><a href="#基金直连和代销" class="headerlink" title="基金直连和代销"></a>基金直连和代销</h2><p>度过了前面的菜鸟学习阶段，第一个做的比较大的项目就是基金项目。一开始直连的时候我还是帮忙翼翔一起搞，后来代销的时候完全就是我一个人负责了。刚开始觉得功能有点多，可能不一定搞得下来，但因为性格原因，可能有时候知道有困难，也不愿意主动说出来，尽量自己先扛着（这确实有点不太好）。这段时间写了不少代码，当然如果我去计较写了多少代码，以后可能永远就只能当个码农了😂。在和产品经理槐远—这里插一下，槐远是个有趣的胖子，另外对业务也很熟悉，人也很随和，从他那了解到不少基金相关的知识。现在看来这段时间确实收获颇多，不光是技术进一步提升，最主要开始熟悉金融产品相关的业务。另外值得一提的是，也第一次拿到了项目奖金。😊<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201603/lizhi/fuli.jpg" alt="fuli"></p><h2 id="保险项目"><a href="#保险项目" class="headerlink" title="保险项目"></a>保险项目</h2><p>保险不得不提，我自己觉得做这个项目是一个转折点。之前感觉是做什么就去学习什么，主动性还不是特别够。但是做保险的时候可能自己就变得主动去学习，那段时间平台准备上线很多保险产品，productCategory从602一直到616😱，当然第一个产品上线后，以后要做的其实很简单，就是添加一个类型，但是所有参与的团队却都要为这个东西发版，这个也一直被吐槽（一个好的设计确实比较重要）。这个阶段我利用空余时间clone了保险的代码，当然不是学习怎么写代码�，主要是更好的了解业务。有时间也向李天炜,李华威请教，有时候他们也觉得奇怪，开玩笑说叫我加入保险算了，不得不说和这两个小伙伴每次开发联调都很顺畅。后来保险了解完后，又看了b2c类相关的流程。我每天饭后跟翼翔讨论对这种募集类型以及每日收益(我自己把陆金所产品主要分为这2大类)，这对理解公司金融产品的流程感觉有很大帮助。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>首先，很感谢陆金所(义军总)当时给我一个机会，让我从一个传统企业进入了互联网公司。在陆金所了解了互联网相关的常用技术，对互联网金融产品也有了更好的理解。最重要是认识了一群优秀的小伙伴。陆金所的开发测试技术到位，主动加班;产品经理学历又高，业务又熟悉；项目经理负责协调，安排有方。可能因为是搞金融的，天生就自带高大上光环，所以公司有很多高富帅白富美。很荣幸在陆金所和大家一起共事过。</p><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>虽然我经常自黑“我只是个搬砖的”,但肯定不甘心永远只当一个码农，不想当架构的程序员不是一个好搬砖的😂。我知道现在技术方面还远远不够，所以要一直学习，努力提升自己。感觉现在对一些东西只掌握一些皮毛，像spring，消息，任务调度，netty相关的还只停留在使用阶段，相关的一些源代码还需要去揣摩下。另外，有时间也要把日语也重新捡起来。当然我研究这些东西，不光是工作需要，也是有个人兴趣。<font color="#08c"><b>兴趣是最好的老师，如果这个兴趣自带装逼技能，那么连老师也不需要了</b></font></p><h2 id="再见，小伙伴"><a href="#再见，小伙伴" class="headerlink" title="再见，小伙伴"></a>再见，小伙伴</h2>]]></content>
      
      
      <categories>
          
          <category> 其他分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离职 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nio学习简单理解</title>
      <link href="2016/02/28/nio/"/>
      <url>2016/02/28/nio/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一直在研究netty，netty是一个提供异步事件驱动的网络应用框架，用以开发高并发高可靠的网络服务器和客户端程序。我们可以看到一些优秀的开源框架也采用了netty作为底层的基础通信组件，像淘宝的dubbo和消息中间件RocketMQ。因为Netty是基于JAVA NIO类库开发的，所以我们必须要先了解nio。</p><span id="more"></span><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>nio是java 1.4版本引入的新的io api，可以替代原来标准的io api。首先介绍下nio的组成部分，它主要有一下3个部分组成：channel，buffer，selector，下面将分别介绍各自疼点。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>所有io在nio中都从一个channel开始，数据可以从channel读取到buffer中，也可以从buffer写入到channel中。有点和原来的标准io中的流类似，但又有明显的区别。</p><p>像上面所说的channel是双向的，但是流的读写通常是单向的<br>通道可以异步的读写<br>通道的数据总是总是要先读到一个buffer，或者从一个buffer中写入。<br>Channel的实现有以下几种。</p><p>FileChannel：从文件中读写数据。<br>DatagramChannel：能通过UDP读写网络中的数据。<br>SocketChannel：能通过TCP读写网络中的数据。<br>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer本质上是一块可以写入数据，并且从中可以读取数据的内存，这块内存被封装成了nio buffer对象。为了了解buffer的工作原理，必须先要了解一下3个属性：capacity，limit，position。<br>capacity:作为一个内存块，buffer大小叫capacity。<br>position,limit:这两个在读和写模式下的意义不同。写模式：position初始为0，limit等于capacity－1，没写一个数据，position加1，最多写capacity个亦即position＝limit时。调用buffer.flip()可以将写模式切换到读模式，此时position＝0，limit被设置成之前写模式最后position的值，我们可以读取从position到limit之间的数据。<br>buffer主要有以下几个方法，下面分别介绍。</p><p>flip():上面已经说过<br>clear():“清空”缓冲区的数据，以便重新写入。这里不是真的清空内存，是把positon设置为0，limit设置为capacity－1.<br>compact():和clear类似也是清空数据，只不过是把缓冲区中还未读完的数据移到缓冲区开头。也就是说limit还是capacity－1，position移到未读完数据后一个。<br>rewind():postiton设置为0，limit位置不变，让缓冲区的数据可以被重新读。<br>mark()和reset()配合使用，mark给postion当前位置做个标记，嗲用reset后，postion回到mark的位置。</p><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>选择器我认为是nio中最重要的一个部分，nio的异步事件驱动就是靠这个selector来实现的。我们可以只需要启动一个线程，创建一个selector，将多个channel注册到selector上面，然后关注每个channel上我们感兴趣的事件（connect，accept，read，write）。这中方式和传统相比，显然有很大的优势。<br>传统方式，服务端启动一个serversocket，监听一个端口，accept一个客户端连接后，然后通过线程池创建一个线程去处理这个请求。如果这个这个请求要处理io，那么这个线程可能就会阻塞很长时间，造成资源浪费。另外线程如果太多，频繁的线程切换也会造成不小的开销。而如果采用nio，可以基于reactor模型，用一个selector管理多个通道，这就是io多路复用，另外如果select到一个感兴趣的事件，比如一个通道的read就绪，那么然后操作io就可以直接读了（因为之前我们已经知道读就绪了），这就是非阻塞。总结一下由于采用了io多路复用I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上<br>下面贴一段代码演示一下selector的用法。</p><p>1<br>Selector selector = Selector.open();<br>channel.configureBlocking(false);<br>SelectionKey key = channel.register(selector, SelectionKey.OP_READ);<br>while(true) {<br>  int readyChannels = selector.select();<br>  if(readyChannels == 0) continue;<br>  Set selectedKeys = selector.selectedKeys();<br>  Iterator keyIterator = selectedKeys.iterator();<br>  while(keyIterator.hasNext()) {<br>    SelectionKey key = keyIterator.next();<br>    if(key.isAcceptable()) {<br>        // a connection was accepted by a ServerSocketChannel.<br>    } else if (key.isConnectable()) {<br>        // a connection was established with a remote server.<br>    } else if (key.isReadable()) {<br>        // a channel is ready for reading<br>    } else if (key.isWritable()) {<br>        // a channel is ready for writing<br>    }<br>    keyIterator.remove();<br>  }<br>}</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/19732473">这篇文章对同步异步阻塞与非阻塞讲解的很好</a><br><a href="https://www.zhihu.com/question/27991975">java nio的另一篇同步异步阻塞非阻塞的介绍</a><br><a href="http://www.iteye.com/magazines/132-Java-NIO">这篇对nio讲解的很透彻</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="2016/02/20/first-post/"/>
      <url>2016/02/20/first-post/</url>
      
        <content type="html"><![CDATA[<p>We如你所见，我的个人博客终于搞定了。前前后后大概花了一个多月，经历了种种困难，还好坚持下来了。现在网站既然搞定了，就开始写自己的第一篇博客。主要讲述下创建个人博客的原因、经过以及今后的打算。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="大学毕业找工作经历"><a href="#大学毕业找工作经历" class="headerlink" title="大学毕业找工作经历"></a>大学毕业找工作经历</h3><p>其实从报考交大研究生，由于专业课只考了75分，心有不甘的离开校园。当时就意识到通信专业不太适合我，后来决定当程序员。网上看了各种大神的经验，都说程序员最好要写博客，经常总结一些技术。网上也确实看到很多个人博客，不光界面很好看，也确实分享了一些相关的技术。从那时起，就有了想搞个人博客的想法。</p><h3 id="陆金所的工作经历"><a href="#陆金所的工作经历" class="headerlink" title="陆金所的工作经历"></a>陆金所的工作经历</h3><p>虽然前不久刚刚递交辞职报告，但我对陆金所还是满怀感激的。在陆金所不光技术得到了不小的提升，更重要的是认识了不少优秀的朋友。其中不得不提到翼祥，我们经常吃完饭就去绕一圈。在路上，他要经常吐槽我党以及我党的一些领导人，恕我不敢说出那些大大的名字。暂且忘掉这些吐槽吧，翼祥对计算机技术也是一个很有追求的人，每次饭后和他交流技术，感觉都有不少收获。后来他建议我买一个macbook，说是开发效率高的一笔。后来在他的再三鼓动下，我决定搞一个mac pro，其实也有我自己想装逼的想法。<br><img src="https://lightoheaven.coding.net/p/image2/d/image2/git/raw/master/201602/first-post/macpro.jpg" alt="mac"></p><span id="more"></span><h2 id="制作网站的过程"><a href="#制作网站的过程" class="headerlink" title="制作网站的过程"></a>制作网站的过程</h2><h3 id="首先选择一个开源项目"><a href="#首先选择一个开源项目" class="headerlink" title="首先选择一个开源项目"></a>首先选择一个开源项目</h3><p>应该是1月28号macpro到手后，第一件事就是发到朋友圈装逼一下😂，我也是醉了，哈哈😄。后来终于开始决定大干一翻，首先准备研究下spring，结果由于网速的原因（在这里不得不吐槽一下长城宽带）竟然下不动，就去百度尝试各种不同办法从其他渠道去下载。也就是在这个过程中，我看到了很多大神的个人博客，感觉很是高大上，就又产生想法先搞一下前端，就不怎么怎么的想到先去研究下nodejs。我就是这么喜欢折腾（记得大学有一个寝室的门口贴着活着就是折腾）。</p><h3 id="基于nodejs＋socket-io的聊天室"><a href="#基于nodejs＋socket-io的聊天室" class="headerlink" title="基于nodejs＋socket.io的聊天室"></a>基于nodejs＋socket.io的聊天室</h3><p>最先网上看到一个基于nodejs+socket.io的实时聊天，感觉很有意思的样子。说干就干，就踏上了一条不归路啊,春节在家还写过代码,当然有个原因是刚买mac,不是有个说法说用mac的文艺程序员吗😂😂，。话题转回来，虽然项目中用到过js,当时还感觉很有信心的样子，谁知自己写nodejs的时候实在无从下手，什么require，有时候要new，有时候又不用，真是想放弃了。后来搞了3，4天终于搞好了，才发现只有不超过300行代码，又不得不感叹nodejs的开发效率。</p><h3 id="基于nodejs＋mongodb＋mongoose搭建个人博客"><a href="#基于nodejs＋mongodb＋mongoose搭建个人博客" class="headerlink" title="基于nodejs＋mongodb＋mongoose搭建个人博客"></a>基于nodejs＋mongodb＋mongoose搭建个人博客</h3><p>原谅我前面说了一大堆废话，现在终于要讲建博客的经历了。最开始在github上找了一个demo，clone下来后发现问题多多。没办法，就一个个解决。后来有个报错一直说驱动和server不匹配，困扰一天发现是因为当前项目用的是mongoskin的驱动，我下载的mongodb是最新的3.2.6，两者貌似不匹配。接着百度，后来又了解到还有一个叫mongoose的驱动。这下又要学习mongoose了，并且要把所有的dao层代码全部切换过去，醉了。又折腾几天终于搞定了。</p><h3 id="服务器的选择"><a href="#服务器的选择" class="headerlink" title="服务器的选择"></a>服务器的选择</h3><p>这个时候春节假期结束了，本地调试看网站能运行，从阿里云上买了个xiaoming1990.top的域名,回到公司，下一步就是找个服务器挂在网上了。第一方案是选择阿里云服务器，后来一看太贵了，一年最便宜也要1000多，后来翼祥说叫我研究下动态路由，花生壳之类的。后来发现没有mac用的，没法发后来决定还是买阿里云了。我想买阿里云之前，再把界面搞好看点。人丑了没朋友，网站不好看一样没人访问。刚开始还是很有热情调界面的，后来发现由于能力问题，前端的一些东西实在搞不定，就不和他们抢饭碗了。</p><h3 id="hexo带来的希望"><a href="#hexo带来的希望" class="headerlink" title="hexo带来的希望"></a>hexo带来的希望</h3><p>纠结一番后，基于2个原因：界面太丑；需要服务器支持。否定掉了前面基于mongo的个人博客。就又百度看有啥其他方案。后来还是在github上了解到一个基于nodejs的hexo的静态网站。貌似作者还只是一个台湾的大学生，不得不感叹github上牛人太多。后来选择了一个叫NexT的主题，感觉很不错的样子。后来又咨询了一下嘉庆同学，在gitcafe上发布了这个网站，也就是你们现在看到的样子。</p><h2 id="个人博客规划"><a href="#个人博客规划" class="headerlink" title="个人博客规划"></a>个人博客规划</h2><p>从1.28到今天折腾了一个多月，<a href="http://yeming.me/">Smartの小明http://yeming.me</a>终于上线了，我给自己打99分，哈哈，还有1分怕我骄傲。今后主要就在这个博客上写一些编程相关的技术的，或者一些生活趣事，另外去年刚买的单反也能发挥作用了，拍出来的照片就直接上传个人博客了，感觉这个规划很科学😄。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>在搭建个人博客的过程中，肯定少不了朋友的帮助，除了上文提到的朱翼祥和郑嘉庆同学，还有很多人。尤其要感谢屏幕前面的你们,浪费了你们宝贵时间，坚持到现在，看完了我的第一篇博客😂<br>也许你们是直接拖到最后的,也辛苦你们滑动了不少的屏幕了…</p>]]></content>
      
      
      <categories>
          
          <category> 其他分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客上线 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
